{
    "docs": [
        {
            "location": "/", 
            "text": "NodeMCU Documentation\n\n\nNodeMCU is an \neLua\n based firmware for the \nESP8266 WiFi SOC from Espressif\n.  The NodeMCU \nfirmware\n is a companion project to the popular \nNodeMCU dev kits\n, ready-made open source development boards with ESP8266-12E chips.\n\n\nUp-To-Date Documentation\n\n\nAt the moment the only up-to-date documentation maintained by the current NodeMCU team is in \nEnglish\n. It is part of the source code repository (\n/docs\n subfolder) and kept in sync with the code.\n\n\nWe encourage you to help transferring the outdated translations (see below) into the repository.\n\n\nOutdated And Sparse Documentation\n\n\nThe following translations are based on outdated documentation, use them with caution. The links point to the \nNodeMCU wiki on GitHub\n.\n\n\n\n\nChinese, \n\u4e2d\u6587\n\n\nRussian, \n\u0440\u0443\u0441\u0441\u043a\u0438\u0439\n\n\nSpanish, \nespa\u00f1ol", 
            "title": "Overview"
        }, 
        {
            "location": "/#nodemcu-documentation", 
            "text": "NodeMCU is an  eLua  based firmware for the  ESP8266 WiFi SOC from Espressif .  The NodeMCU  firmware  is a companion project to the popular  NodeMCU dev kits , ready-made open source development boards with ESP8266-12E chips.", 
            "title": "NodeMCU Documentation"
        }, 
        {
            "location": "/#up-to-date-documentation", 
            "text": "At the moment the only up-to-date documentation maintained by the current NodeMCU team is in  English . It is part of the source code repository ( /docs  subfolder) and kept in sync with the code.  We encourage you to help transferring the outdated translations (see below) into the repository.", 
            "title": "Up-To-Date Documentation"
        }, 
        {
            "location": "/#outdated-and-sparse-documentation", 
            "text": "The following translations are based on outdated documentation, use them with caution. The links point to the  NodeMCU wiki on GitHub .   Chinese,  \u4e2d\u6587  Russian,  \u0440\u0443\u0441\u0441\u043a\u0438\u0439  Spanish,  espa\u00f1ol", 
            "title": "Outdated And Sparse Documentation"
        }, 
        {
            "location": "/en/", 
            "text": "NodeMCU Documentation\n\n\nNodeMCU is an \neLua\n based firmware for the \nESP8266 WiFi SOC from Espressif\n. The firmware is based on the Espressif NON-OS SDK and uses a file system based on \nspiffs\n. The code repository consists of 98.1% C-code that glues the thin Lua veneer to the SDK.\n\n\nThe NodeMCU \nfirmware\n is a companion project to the popular \nNodeMCU dev kits\n, ready-made open source development boards with ESP8266-12E chips.\n\n\nProgramming Model\n\n\nThe NodeMCU programming model is similar to that of \nNode.js\n, only in Lua. It is asynchronous and event-driven. Many functions, therefore, have parameters for callback functions. To give you an idea what a NodeMCU program looks like study the short snippets below. For more extensive examples have a look at the \n/lua_examples\n folder in the repository on GitHub.\n\n\n-- a simple HTTP server\nsrv = net.createServer(net.TCP)\nsrv:listen(80, function(conn)\n    conn:on(\nreceive\n, function(sck, payload)\n        print(payload)\n        sck:send(\nHTTP/1.0 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n\nh1\n Hello, NodeMCU.\n/h1\n)\n    end)\n    conn:on(\nsent\n, function(sck) sck:close() end)\nend)\n\n\n\n\n-- connect to WiFi access point\nwifi.setmode(wifi.STATION)\nwifi.sta.config(\nSSID\n, \npassword\n)\n\n\n\n\n-- register event callbacks for WiFi events\nwifi.sta.eventMonReg(wifi.STA_CONNECTING, function(previous_state)\n    if(previous_state==wifi.STA_GOTIP) then \n        print(\nStation lost connection with access point. Attempting to reconnect...\n)\n    else\n        print(\nSTATION_CONNECTING\n)\n    end\nend)\n\n\n\n\n-- manipulate hardware like with Arduino\npin = 1\ngpio.mode(pin, gpio.OUTPUT)\ngpio.write(pin, gpio.HIGH)\nprint(gpio.read(pin))\n\n\n\n\nGetting Started\n\n\n\n\nBuild the firmware\n with the modules you need.\n\n\nFlash the firmware\n to the chip.\n\n\nUpload code\n to the firmware.", 
            "title": "Home"
        }, 
        {
            "location": "/en/#nodemcu-documentation", 
            "text": "NodeMCU is an  eLua  based firmware for the  ESP8266 WiFi SOC from Espressif . The firmware is based on the Espressif NON-OS SDK and uses a file system based on  spiffs . The code repository consists of 98.1% C-code that glues the thin Lua veneer to the SDK.  The NodeMCU  firmware  is a companion project to the popular  NodeMCU dev kits , ready-made open source development boards with ESP8266-12E chips.", 
            "title": "NodeMCU Documentation"
        }, 
        {
            "location": "/en/#programming-model", 
            "text": "The NodeMCU programming model is similar to that of  Node.js , only in Lua. It is asynchronous and event-driven. Many functions, therefore, have parameters for callback functions. To give you an idea what a NodeMCU program looks like study the short snippets below. For more extensive examples have a look at the  /lua_examples  folder in the repository on GitHub.  -- a simple HTTP server\nsrv = net.createServer(net.TCP)\nsrv:listen(80, function(conn)\n    conn:on( receive , function(sck, payload)\n        print(payload)\n        sck:send( HTTP/1.0 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n h1  Hello, NodeMCU. /h1 )\n    end)\n    conn:on( sent , function(sck) sck:close() end)\nend)  -- connect to WiFi access point\nwifi.setmode(wifi.STATION)\nwifi.sta.config( SSID ,  password )  -- register event callbacks for WiFi events\nwifi.sta.eventMonReg(wifi.STA_CONNECTING, function(previous_state)\n    if(previous_state==wifi.STA_GOTIP) then \n        print( Station lost connection with access point. Attempting to reconnect... )\n    else\n        print( STATION_CONNECTING )\n    end\nend)  -- manipulate hardware like with Arduino\npin = 1\ngpio.mode(pin, gpio.OUTPUT)\ngpio.write(pin, gpio.HIGH)\nprint(gpio.read(pin))", 
            "title": "Programming Model"
        }, 
        {
            "location": "/en/#getting-started", 
            "text": "Build the firmware  with the modules you need.  Flash the firmware  to the chip.  Upload code  to the firmware.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/en/build/", 
            "text": "There are essentially three ways to build your NodeMCU firmware: cloud build service, Docker image, dedicated Linux environment (possibly VM).\n\n\nTools\n\n\nCloud Build Service\n\n\nNodeMCU \"application developers\" just need a ready-made firmware. There's a \ncloud build service\n with a nice UI and configuration options for them.\n\n\nDocker Image\n\n\nOccasional NodeMCU firmware hackers don't need full control over the complete tool chain. They might not want to setup a Linux VM with the build environment. Docker to the rescue. Give \nDocker NodeMCU build\n a try.\n\n\nLinux Build Environment\n\n\nNodeMCU firmware developers commit or contribute to the project on GitHub and might want to build their own full fledged build environment with the complete tool chain. There is a \npost in the esp8266.com Wiki\n that describes this.\n\n\nBuild Options\n\n\nThe following sections explain some of the options you have if you want to build your own NodeMCU firmware.\n\n\nSelect Modules\n\n\nDisable modules you won't be using to reduce firmware size and free up some RAM. The ESP8266 is quite limited in available RAM and running out of memory can cause a system panic. The \ndefault configuration\n is designed to run on all ESP modules including the 512 KB modules like ESP-01 and only includes general purpose interface modules which require at most two GPIO pins.\n\n\nEdit \napp/include/user_modules.h\n and comment-out the \n#define\n statement for modules you don't need. Example:\n\n\n...\n#define LUA_USE_MODULES_MQTT\n// #define LUA_USE_MODULES_COAP\n// #define LUA_USE_MODULES_U8G\n...\n\n\n\n\nTLS/SSL Support\n\n\nTo enable TLS support edit \napp/include/user_config.h\n and uncomment the following flag:\n\n\n//#define CLIENT_SSL_ENABLE\n\n\n\n\nThe complete configuration is stored in \napp/include/user_mbedtls.h\n. This is the file to edit if you build your own firmware and want to change mbed TLS behavior. See the \ntls\n documentation\n for details.\n\n\nDebugging\n\n\nTo enable runtime debug messages to serial console edit \napp/include/user_config.h\n\n\n#define DEVELOP_VERSION\n\n\n\n\nSet UART Bit Rate\n\n\nThe initial baud rate at boot time is 115200bps. You can change this by\nediting \nBIT_RATE_DEFAULT\n in \napp/include/user_config.h\n:\n\n\n#define BIT_RATE_DEFAULT BIT_RATE_115200\n\n\n\n\nNote that, by default, the firmware runs an auto-baudrate detection algorithm so that typing a few characters at boot time will cause\nthe firmware to lock onto that baud rate (between 1200 and 230400).\n\n\nInteger build\n\n\nBy default a build will be generated supporting floating-point variables.\nTo reduce memory size an integer build can be created.  You can change this \neither by uncommenting \nLUA_NUMBER_INTEGRAL\n in \napp/include/user_config.h\n:\n\n\n#define LUA_NUMBER_INTEGRAL\n\n\n\n\nOR by overriding this with the \nmake\n command as it's \ndone during the CI\nbuild\n:\n\n\nmake EXTRA_CCFLAGS=\n-DLUA_NUMBER_INTEGRAL ....\n\n\n\n\nTag Your Build\n\n\nIdentify your firmware builds by editing \napp/include/user_version.h\n\n\n#define NODE_VERSION    \nNodeMCU 2.1.0+myname\n\n#ifndef BUILD_DATE\n#define BUILD_DATE      \nYYYYMMDD\n\n#endif\n\n\n\n\nu8g Module Configuration\n\n\nDisplay drivers and embedded fonts are compiled into the firmware image based on the settings in \napp/include/u8g_config.h\n. See the \nu8g\n documentation\n for details.\n\n\nucg Module Configuration\n\n\nDisplay drivers and embedded fonts are compiled into the firmware image based on the settings in \napp/include/ucg_config.h\n. See the \nucg\n documentation\n for details.", 
            "title": "Building the firmware"
        }, 
        {
            "location": "/en/build/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/en/build/#cloud-build-service", 
            "text": "NodeMCU \"application developers\" just need a ready-made firmware. There's a  cloud build service  with a nice UI and configuration options for them.", 
            "title": "Cloud Build Service"
        }, 
        {
            "location": "/en/build/#docker-image", 
            "text": "Occasional NodeMCU firmware hackers don't need full control over the complete tool chain. They might not want to setup a Linux VM with the build environment. Docker to the rescue. Give  Docker NodeMCU build  a try.", 
            "title": "Docker Image"
        }, 
        {
            "location": "/en/build/#linux-build-environment", 
            "text": "NodeMCU firmware developers commit or contribute to the project on GitHub and might want to build their own full fledged build environment with the complete tool chain. There is a  post in the esp8266.com Wiki  that describes this.", 
            "title": "Linux Build Environment"
        }, 
        {
            "location": "/en/build/#build-options", 
            "text": "The following sections explain some of the options you have if you want to build your own NodeMCU firmware.", 
            "title": "Build Options"
        }, 
        {
            "location": "/en/build/#select-modules", 
            "text": "Disable modules you won't be using to reduce firmware size and free up some RAM. The ESP8266 is quite limited in available RAM and running out of memory can cause a system panic. The  default configuration  is designed to run on all ESP modules including the 512 KB modules like ESP-01 and only includes general purpose interface modules which require at most two GPIO pins.  Edit  app/include/user_modules.h  and comment-out the  #define  statement for modules you don't need. Example:  ...\n#define LUA_USE_MODULES_MQTT\n// #define LUA_USE_MODULES_COAP\n// #define LUA_USE_MODULES_U8G\n...", 
            "title": "Select Modules"
        }, 
        {
            "location": "/en/build/#tlsssl-support", 
            "text": "To enable TLS support edit  app/include/user_config.h  and uncomment the following flag:  //#define CLIENT_SSL_ENABLE  The complete configuration is stored in  app/include/user_mbedtls.h . This is the file to edit if you build your own firmware and want to change mbed TLS behavior. See the  tls  documentation  for details.", 
            "title": "TLS/SSL Support"
        }, 
        {
            "location": "/en/build/#debugging", 
            "text": "To enable runtime debug messages to serial console edit  app/include/user_config.h  #define DEVELOP_VERSION", 
            "title": "Debugging"
        }, 
        {
            "location": "/en/build/#set-uart-bit-rate", 
            "text": "The initial baud rate at boot time is 115200bps. You can change this by\nediting  BIT_RATE_DEFAULT  in  app/include/user_config.h :  #define BIT_RATE_DEFAULT BIT_RATE_115200  Note that, by default, the firmware runs an auto-baudrate detection algorithm so that typing a few characters at boot time will cause\nthe firmware to lock onto that baud rate (between 1200 and 230400).", 
            "title": "Set UART Bit Rate"
        }, 
        {
            "location": "/en/build/#integer-build", 
            "text": "By default a build will be generated supporting floating-point variables.\nTo reduce memory size an integer build can be created.  You can change this \neither by uncommenting  LUA_NUMBER_INTEGRAL  in  app/include/user_config.h :  #define LUA_NUMBER_INTEGRAL  OR by overriding this with the  make  command as it's  done during the CI\nbuild :  make EXTRA_CCFLAGS= -DLUA_NUMBER_INTEGRAL ....", 
            "title": "Integer build"
        }, 
        {
            "location": "/en/build/#tag-your-build", 
            "text": "Identify your firmware builds by editing  app/include/user_version.h  #define NODE_VERSION     NodeMCU 2.1.0+myname \n#ifndef BUILD_DATE\n#define BUILD_DATE       YYYYMMDD \n#endif", 
            "title": "Tag Your Build"
        }, 
        {
            "location": "/en/build/#u8g-module-configuration", 
            "text": "Display drivers and embedded fonts are compiled into the firmware image based on the settings in  app/include/u8g_config.h . See the  u8g  documentation  for details.", 
            "title": "u8g Module Configuration"
        }, 
        {
            "location": "/en/build/#ucg-module-configuration", 
            "text": "Display drivers and embedded fonts are compiled into the firmware image based on the settings in  app/include/ucg_config.h . See the  ucg  documentation  for details.", 
            "title": "ucg Module Configuration"
        }, 
        {
            "location": "/en/flash/", 
            "text": "Below you'll find all necessary information to flash a NodeMCU firmware binary to ESP8266 or ESP8285. Note that this is a reference documentation and not a tutorial with fancy screen shots. Turn to your favorite search engine for those. Make sure you follow a recent tutorial rather than one that is several months old!\n\n\n\n\nAttention\n\n\nKeep in mind that the ESP8266 needs to be \nput into flash mode\n before you can flash a new firmware!\n\n\n\n\n\n\nImportant\n\n\nWhen switching between NodeMCU versions, see the notes about\n\nUpgrading Firmware\n.\n\n\n\n\nTool overview\n\n\nesptool.py\n\n\n\n\nA Python-based, open source, platform independent, utility to communicate with the ROM bootloader in Espressif ESP8266.\n\n\n\n\nSource: \nhttps://github.com/espressif/esptool\n\n\nSupported platforms: OS X, Linux, Windows, anything that runs Python\n\n\nRunning esptool.py\n\n\nRun the following command to flash an \naggregated\n binary as is produced for example by the \ncloud build service\n or the \nDocker image\n.\n\n\nesptool.py --port \nserial-port-of-ESP8266\n write_flash -fm \nmode\n 0x00000 \nnodemcu-firmware\n.bin\n\n\nmode\n is \nqio\n for 512\nkByte modules and \ndio\n for \n=4\nMByte modules (\nqio\n might work as well, YMMV).\n\n\nGotchas\n\n\n\n\nSee \nbelow\n if you don't know or are uncertain about the capacity of the flash chip on your device. It might help to double check as e.g. some ESP-01 modules come with 512kB while others are equipped with 1MB.\n\n\nesptool.py is under heavy development. It's advised you run the latest version (check with \nesptool.py version\n). Since this documentation may not have been able to keep up refer to the \nesptool flash modes documentation\n for current options and parameters.\n\n\nThe firmware image file contains default settings \ndio\n for flash mode and \n40m\n for flash frequency.\n\n\nIn some uncommon cases, the \nSDK init data\n may be invalid and NodeMCU may fail to boot. The easiest solution is to fully erase the chip before flashing:\n\nesptool.py --port \nserial-port-of-ESP8266\n erase_flash\n\n\n\n\nNodeMCU Flasher\n\n\n\n\nA firmware Flash tool for NodeMCU...We are working on next version and will use QT framework. It will be cross platform and open-source.\n\n\n\n\nSource: \nhttps://github.com/nodemcu/nodemcu-flasher\n\n\nSupported platforms: Windows\n\n\nNote that this tool was created by the initial developers of the NodeMCU firmware. \nIt hasn't seen updates since September 2015\n and is not maintained by the current NodeMCU \nfirmware\n team. Be careful to not accidentally flash the very old default firmware the tool is shipped with.\n\n\nNodeMCU PyFlasher\n\n\n\n\nSelf-contained \nNodeMCU\n flasher with GUI based on \nesptool.py\n and \nwxPython\n.\n\n\n\n\nSource: \nhttps://github.com/marcelstoer/nodemcu-pyflasher\n\n\nSupported platforms: anything that runs Python, runnable .exe available for Windows\n\n\nDisclaimer: the availability of \nNodeMCU PyFlasher was announced on the NodeMCU Facebook page\n but it is not an official offering of the current NodeMCU firmware team.\n\n\nPutting Device Into Flash Mode\n\n\nTo enable ESP8266 firmware flashing GPIO0 pin must be pulled low before the device is reset. Conversely, for a normal boot, GPIO0 must be pulled high or floating.\n\n\nIf you have a \nNodeMCU dev kit\n then you don't need to do anything, as the USB connection can pull GPIO0 low by asserting DTR and reset your board by asserting RTS.\n\n\nIf you have an ESP-01 or other device without built-in USB, you will need to enable flashing yourself by pulling GPIO0 low or pressing a \"flash\" switch, while powering up or resetting the module.\n\n\nWhich Files To Flash\n\n\nIf you build your firmware with the \ncloud builder or the Docker image\n, or any other method that produces a \ncombined binary\n, then you can flash that file directly to address 0x00000.\n\n\nOtherwise, if you built your own firmware from source code:\n\n\n\n\nbin/0x00000.bin\n to 0x00000\n\n\nbin/0x10000.bin\n to 0x10000\n\n\n\n\nUpgrading Firmware\n\n\nThere are three potential issues that arise from upgrading (or downgrading!) firmware from one NodeMCU version to another:\n\n\n\n\n\n\nLua scripts written for one NodeMCU version (like 0.9.x) may not work error-free on a more recent firmware.  For example, Espressif changed the \nsocket:send\n operation to be asynchronous i.e. non-blocking. See \nAPI documentation\n for details.\n\n\n\n\n\n\nThe NodeMCU flash file system may need to be reformatted, particularly if its address has changed because the new firmware is different in size from the old firmware.  If it is not automatically formatted then it should be valid and have the same contents as before the flash operation. You can still run \nfile.format()\n manually to re-format your flash file system. You will know if you need to do this if your flash files exist but seem empty, or if data cannot be written to new files. However, this should be an exceptional case.\nFormatting a file system on a large flash device (e.g. the 16MB parts) can take some time. So, on the first boot, you shouldn't get worried if nothing appears to happen for a minute. There's a message printed to console to make you aware of this.\n\n\n\n\n\n\nThe Espressif SDK Init Data may change between each NodeMCU firmware version, and may need to be erased or reflashed.  See \nSDK Init Data\n for details.  Fully erasing the module before upgrading firmware will avoid this issue.\n\n\n\n\n\n\nSDK Init Data\n\n\n\n\nNote\n\n\nNormally, NodeMCU will take care of writing the SDK init data when needed. Most users can ignore this section.\n\n\n\n\nNodeMCU versions are compiled against specific versions of the Espressif SDK. The SDK reserves space in flash that is used to store calibration and other data. This data changes between SDK versions, and if it is invalid or not present, the firmware may not boot correctly. Symptoms include messages like \nrf_cal[0] !=0x05,is 0xFF\n, or endless reboot loops and/or fast blinking module LEDs.\n\n\n\n\nTip\n\n\nIf you are seeing one or several of the above symptoms, ensure that your chip is fully erased before flashing, for example:\n\n\nesptool.py --port \nserial-port-of-ESP8266\n erase_flash\n\n\nAlso verify that you are using an up-to-date NodeMCU release, as some early releases of NodeMCU 1.5.4.1 did not write the SDK init data to a freshly erased chip.\n\n\n\n\nEspressif refers to this area as \"System Param\" and it resides in the last four 4\nkB sectors of flash. Since SDK 1.5.4.1 a fifth sector is reserved for RF calibration (and its placement is controlled by NodeMCU) as described by this \npatch notice\n. At minimum, Espressif states that the 4th sector from the end needs to be flashed with \"init data\", and the 2nd sector from the end should be blank.\n\n\nThe default init data is provided as part of the SDK in the file \nesp_init_data_default.bin\n. NodeMCU will automatically flash this file to the right place on first boot if the sector appears to be empty.\n\n\nIf you need to customize init data then first download the \nEspressif SDK 2.1.0\n and extract \nesp_init_data_default.bin\n. Then flash that file just like you'd flash the firmware. The correct address for the init data depends on the capacity of the flash chip. \n\n\n\n\n0x7c000\n for 512 kB, modules like most ESP-01, -03, -07 etc.\n\n\n0xfc000\n for 1 MB, modules like ESP8285, PSF-A85, some ESP-01, -03 etc.\n\n\n0x1fc000\n for 2 MB\n\n\n0x3fc000\n for 4 MB, modules like ESP-12E, NodeMCU devkit 1.0, WeMos D1 mini\n\n\n0x7fc000\n for 8 MB\n\n\n0xffc000\n for 16 MB, modules like WeMos D1 mini pro\n\n\n\n\nSee \"4.1 Non-FOTA Flash Map\" and \"6.3 RF Initialization Configuration\" of the \nESP8266 Getting Started Guide\n for details on init data addresses and customization.\n\n\nDetermine flash size\n\n\nTo determine the capacity of the flash chip \nbefore\n a firmware is installed you can run\n\n\nesptool.py --port \nserial-port\n flash_id\n\n\nIt will return a manufacturer ID and a chip ID like so:\n\n\nConnecting...\nManufacturer: e0\nDevice: 4016\n\n\n\n\nThe chip ID can then be looked up in \nhttps://code.coreboot.org/p/flashrom/source/tree/HEAD/trunk/flashchips.h\n. This leads to a manufacturer name and a chip model name/number e.g. \nAMIC_A25LQ032\n. That information can then be fed into your favorite search engine to find chip descriptions and data sheets.\n\n\nBy convention the last two or three digits in the module name denote the capacity in megabits. So, \nA25LQ032\n in the example above is a 32Mb(=4MB) module.", 
            "title": "Flashing the firmware"
        }, 
        {
            "location": "/en/flash/#tool-overview", 
            "text": "", 
            "title": "Tool overview"
        }, 
        {
            "location": "/en/flash/#esptoolpy", 
            "text": "A Python-based, open source, platform independent, utility to communicate with the ROM bootloader in Espressif ESP8266.   Source:  https://github.com/espressif/esptool  Supported platforms: OS X, Linux, Windows, anything that runs Python  Running esptool.py  Run the following command to flash an  aggregated  binary as is produced for example by the  cloud build service  or the  Docker image .  esptool.py --port  serial-port-of-ESP8266  write_flash -fm  mode  0x00000  nodemcu-firmware .bin  mode  is  qio  for 512 kByte modules and  dio  for  =4 MByte modules ( qio  might work as well, YMMV).  Gotchas   See  below  if you don't know or are uncertain about the capacity of the flash chip on your device. It might help to double check as e.g. some ESP-01 modules come with 512kB while others are equipped with 1MB.  esptool.py is under heavy development. It's advised you run the latest version (check with  esptool.py version ). Since this documentation may not have been able to keep up refer to the  esptool flash modes documentation  for current options and parameters.  The firmware image file contains default settings  dio  for flash mode and  40m  for flash frequency.  In some uncommon cases, the  SDK init data  may be invalid and NodeMCU may fail to boot. The easiest solution is to fully erase the chip before flashing: esptool.py --port  serial-port-of-ESP8266  erase_flash", 
            "title": "esptool.py"
        }, 
        {
            "location": "/en/flash/#nodemcu-flasher", 
            "text": "A firmware Flash tool for NodeMCU...We are working on next version and will use QT framework. It will be cross platform and open-source.   Source:  https://github.com/nodemcu/nodemcu-flasher  Supported platforms: Windows  Note that this tool was created by the initial developers of the NodeMCU firmware.  It hasn't seen updates since September 2015  and is not maintained by the current NodeMCU  firmware  team. Be careful to not accidentally flash the very old default firmware the tool is shipped with.", 
            "title": "NodeMCU Flasher"
        }, 
        {
            "location": "/en/flash/#nodemcu-pyflasher", 
            "text": "Self-contained  NodeMCU  flasher with GUI based on  esptool.py  and  wxPython .   Source:  https://github.com/marcelstoer/nodemcu-pyflasher  Supported platforms: anything that runs Python, runnable .exe available for Windows  Disclaimer: the availability of  NodeMCU PyFlasher was announced on the NodeMCU Facebook page  but it is not an official offering of the current NodeMCU firmware team.", 
            "title": "NodeMCU PyFlasher"
        }, 
        {
            "location": "/en/flash/#putting-device-into-flash-mode", 
            "text": "To enable ESP8266 firmware flashing GPIO0 pin must be pulled low before the device is reset. Conversely, for a normal boot, GPIO0 must be pulled high or floating.  If you have a  NodeMCU dev kit  then you don't need to do anything, as the USB connection can pull GPIO0 low by asserting DTR and reset your board by asserting RTS.  If you have an ESP-01 or other device without built-in USB, you will need to enable flashing yourself by pulling GPIO0 low or pressing a \"flash\" switch, while powering up or resetting the module.", 
            "title": "Putting Device Into Flash Mode"
        }, 
        {
            "location": "/en/flash/#which-files-to-flash", 
            "text": "If you build your firmware with the  cloud builder or the Docker image , or any other method that produces a  combined binary , then you can flash that file directly to address 0x00000.  Otherwise, if you built your own firmware from source code:   bin/0x00000.bin  to 0x00000  bin/0x10000.bin  to 0x10000", 
            "title": "Which Files To Flash"
        }, 
        {
            "location": "/en/flash/#upgrading-firmware", 
            "text": "There are three potential issues that arise from upgrading (or downgrading!) firmware from one NodeMCU version to another:    Lua scripts written for one NodeMCU version (like 0.9.x) may not work error-free on a more recent firmware.  For example, Espressif changed the  socket:send  operation to be asynchronous i.e. non-blocking. See  API documentation  for details.    The NodeMCU flash file system may need to be reformatted, particularly if its address has changed because the new firmware is different in size from the old firmware.  If it is not automatically formatted then it should be valid and have the same contents as before the flash operation. You can still run  file.format()  manually to re-format your flash file system. You will know if you need to do this if your flash files exist but seem empty, or if data cannot be written to new files. However, this should be an exceptional case.\nFormatting a file system on a large flash device (e.g. the 16MB parts) can take some time. So, on the first boot, you shouldn't get worried if nothing appears to happen for a minute. There's a message printed to console to make you aware of this.    The Espressif SDK Init Data may change between each NodeMCU firmware version, and may need to be erased or reflashed.  See  SDK Init Data  for details.  Fully erasing the module before upgrading firmware will avoid this issue.", 
            "title": "Upgrading Firmware"
        }, 
        {
            "location": "/en/flash/#sdk-init-data", 
            "text": "Note  Normally, NodeMCU will take care of writing the SDK init data when needed. Most users can ignore this section.   NodeMCU versions are compiled against specific versions of the Espressif SDK. The SDK reserves space in flash that is used to store calibration and other data. This data changes between SDK versions, and if it is invalid or not present, the firmware may not boot correctly. Symptoms include messages like  rf_cal[0] !=0x05,is 0xFF , or endless reboot loops and/or fast blinking module LEDs.   Tip  If you are seeing one or several of the above symptoms, ensure that your chip is fully erased before flashing, for example:  esptool.py --port  serial-port-of-ESP8266  erase_flash  Also verify that you are using an up-to-date NodeMCU release, as some early releases of NodeMCU 1.5.4.1 did not write the SDK init data to a freshly erased chip.   Espressif refers to this area as \"System Param\" and it resides in the last four 4 kB sectors of flash. Since SDK 1.5.4.1 a fifth sector is reserved for RF calibration (and its placement is controlled by NodeMCU) as described by this  patch notice . At minimum, Espressif states that the 4th sector from the end needs to be flashed with \"init data\", and the 2nd sector from the end should be blank.  The default init data is provided as part of the SDK in the file  esp_init_data_default.bin . NodeMCU will automatically flash this file to the right place on first boot if the sector appears to be empty.  If you need to customize init data then first download the  Espressif SDK 2.1.0  and extract  esp_init_data_default.bin . Then flash that file just like you'd flash the firmware. The correct address for the init data depends on the capacity of the flash chip.    0x7c000  for 512 kB, modules like most ESP-01, -03, -07 etc.  0xfc000  for 1 MB, modules like ESP8285, PSF-A85, some ESP-01, -03 etc.  0x1fc000  for 2 MB  0x3fc000  for 4 MB, modules like ESP-12E, NodeMCU devkit 1.0, WeMos D1 mini  0x7fc000  for 8 MB  0xffc000  for 16 MB, modules like WeMos D1 mini pro   See \"4.1 Non-FOTA Flash Map\" and \"6.3 RF Initialization Configuration\" of the  ESP8266 Getting Started Guide  for details on init data addresses and customization.", 
            "title": "SDK Init Data"
        }, 
        {
            "location": "/en/flash/#determine-flash-size", 
            "text": "To determine the capacity of the flash chip  before  a firmware is installed you can run  esptool.py --port  serial-port  flash_id  It will return a manufacturer ID and a chip ID like so:  Connecting...\nManufacturer: e0\nDevice: 4016  The chip ID can then be looked up in  https://code.coreboot.org/p/flashrom/source/tree/HEAD/trunk/flashchips.h . This leads to a manufacturer name and a chip model name/number e.g.  AMIC_A25LQ032 . That information can then be fed into your favorite search engine to find chip descriptions and data sheets.  By convention the last two or three digits in the module name denote the capacity in megabits. So,  A25LQ032  in the example above is a 32Mb(=4MB) module.", 
            "title": "Determine flash size"
        }, 
        {
            "location": "/en/spiffs/", 
            "text": "SPIFFS File System\n\n\nThe NodeMCU project uses the \nSPIFFS\n \nfilesystem to store files in the flash chip. The technical details about how this is configured can be found below, along with various build time options.\n\n\nspiffsimg - Manipulate SPI Flash File System disk images\n\n\nEver wished you could prepare a SPIFFS image offline and flash the whole\nthing onto your microprocessor's storage instead of painstakingly upload\nfile-by-file through your app on the micro? With spiffsimg you can!\n\n\nNodeMCU uses a SPIFFS filesystem that knows how big it is -- i.e. when you build a file system\nimage, it must fit into the flash chip, and it cannot be expanded once flashed.\nIt is important to give the \nspiffimg\n tool the correct size. You can provide either the \n-c\n option or both the \n-U\n and \n-S\n options.\n\n\nSyntax\n\n\nspiffsimg -f \nfilename\n \n    [-o \noffsetfile\n]\n    [-c \nsize\n] \n    [-S \nflashsize\n]\n    [-U \nusedsize\n]\n    [-d]\n    [-l | -i | -r \nscriptname\n ]\n\n\n\n\nSupported operations:\n\n\n\n\n-f\n specifies the filename for the disk image. '%x' will be replaced by the calculated offset of the file system (\n-U\n must also be specified to calculate the offset).\n\n\n-o\n specifies the filename which is to contain the calculated offset.\n\n\n-S\n specifies the size of the flash chip. \n32m\n is 32 mbits, \n4MB\n is 4 megabytes.\n\n\n-U\n specifies the amount of flash used by the firmware. Decimal or Hex bytes (if starts with 0x).\n\n\n-c\n Create a blank disk image of the given size. Decimal or Hex bytes (if starts with 0x).\n\n\n-l\n List the contents of the given disk image.\n\n\n-i\n Interactive commands.\n\n\n-r\n Scripted commands from filename.\n\n\n-d\n causes the disk image to be deleted on error. This makes it easier to script.\n\n\n\n\nAvailable commands:\n\n\n\n\nls\n List contents. Output format is {type} {size} {name}.\n\n\ncat \nfilename\n Dump file contents to stdout.\n\n\nrm \nfilename\n Delete file.\n\n\ninfo\n Display SPIFFS usage estimates.\n\n\nimport \nsrcfile\n \nspiffsname\n Import a file into the disk image.\n\n\nexport \nspiffsname\n \ndstfile\n Export a file from the disk image.\n\n\n\n\nExample:\n\n\n# spiffsimg -f flash.img -S 32m -U 524288 -i\n\n import myapp/lua/init.lua init.lua\n\n import myapp/lua/httpd.lua httpd.lua\n\n import myapp/html/index.html http/index.html\n\n import myapp/html/favicon.ico http/favicon.ico\n\n ls\nf    122 init.lua\nf   5169 httpd.lua\nf   2121 http/index.html\nf    880 http/favicon.ico\n\n^D\n#\n\n\n\n\nKnown limitations:\n\n\n\n\nThe block \n page sizes are hard-coded to be compatible with nodemcu.\n\n\nError handling is not entirely consistent, some errors result in an\n    early exit, others just print an error (both cause a non-zero exit though).\n\n\nOnly flat SPIFFS is supported.\n\n\n\n\nTechnical Details\n\n\nThe SPIFFS configuration is 4k sectors (the only size supported by the SDK) and 8k blocks. 256 byte pages. Magic is enabled and magic_len is also enabled. This allows the firmware to find the start of the filesystem (and also the size).\nOne of the goals is to make the filsystem more persistent across reflashing of the firmware. However, there are still cases\nwhere spiffs detects a filesystem and uses it when it isn't valid. If you are getting weirdness with the filesystem, then just reformat it.\n\n\nThere are two significant sizes of flash -- the 512K and 4M (or bigger). \n\n\nThe file system has to start on a 4k boundary, but since it ends on a much bigger boundary (a 16k boundary), it also starts on an 8k boundary. For the small flash chip, there is \nnot much spare space, so a newly formatted file system will start as low as possible (to get as much space as possible). For the large flash, the \nfile system will start on a 64k boundary. A newly formatted file system will start between 64k and 128k from the end of the firmware. This means that the file \nsystem will survive lots of reflashing and at least 64k of firmware growth. \n\n\nThe standard build process for the firmware builds the \nspiffsimg\n tool (found in the \ntools/spiffsimg\n subdirectory).\nThe top level Makfile also checks if\nthere is any data in the \nlocal/fs\n directory tree, and it will then copy these files\ninto the flash disk image. Two images will normally be created -- one for the 512k flash part and the other for the 4M flash part. If the data doesn't \nfit into the 512k part after the firmware is included, then the file will not be generated.\nThe disk image file is placed into the \nbin\n directory and it is named \n0x\noffset\n-\nsize\n.bin\n where the offset is the location where it should be \nflashed, and the size is the size of the flash part. It is quite valid (and quicker) to flash the 512k image into a 4M part. However, there will probably be\nlimited space in the file system for creating new files.\n\n\nThe default configuration will try and build three different file systems for 512KB, 1MB and 4MB flash sizes. The 1MB size is suitable for the ESP8285. This can be overridden by specifying the FLASHSIZE parameter to the makefile.\n\n\nIf the \nlocal/fs\n directory is empty, then no flash images will be created (and the ones from the last build will be removed). The \nspiffsimg\n tool can \nthen be used to build an image as required. \n\n\nIf no file system is found during platform boot, then a new file system will be formatted. This can take some time on the first boot.\n\n\nNote that the last 16k of the flash chip is reserved for the SDK to store parameters (such as the client wifi settings).\n\n\nIn order to speed up the boot time, it is possible to define (at build time) the size of the SPIFFS Filesystem to be formatted. This can be as small as 32768 bytes which gives a filesystem with about 15k bytes of usable space.\nJust place the following define in \nuser_config.h\n or some other file that is included during the build.\n\n\n#define SPIFFS_MAX_FILESYSTEM_SIZE  32768\n\n\n\n\nThis filesystem size limit only affects the formatting of a file system -- if the firm finds an existing valid filesystem (of any size) it will use that. However, if the \nfilesystem is reformatted from Lua (using file.format()) then the new file system will obey the size limit. \n\n\nThere is also an option to control the positioning of the SPIFFS file system:\n\n\n#define SPIFFS_FIXED_LOCATION       0x100000\n\n\n\n\nThis specifies that the SPIFFS filesystem starts at 1Mb from the start of the flash. Unless otherwise specified, it will run to the end of the flash (excluding the 16k of space reserved by the SDK). \n\n\nThere is an option that limits the size of the file system to run up to the next 1MB boundary (minus the 16k for the parameter space). This may be useful when dealing with OTA upgrades.\n\n\n#define SPIFFS_SIZE_1M_BOUNDARY", 
            "title": "Internal filesystem notes"
        }, 
        {
            "location": "/en/spiffs/#spiffs-file-system", 
            "text": "The NodeMCU project uses the  SPIFFS  \nfilesystem to store files in the flash chip. The technical details about how this is configured can be found below, along with various build time options.", 
            "title": "SPIFFS File System"
        }, 
        {
            "location": "/en/spiffs/#spiffsimg-manipulate-spi-flash-file-system-disk-images", 
            "text": "Ever wished you could prepare a SPIFFS image offline and flash the whole\nthing onto your microprocessor's storage instead of painstakingly upload\nfile-by-file through your app on the micro? With spiffsimg you can!  NodeMCU uses a SPIFFS filesystem that knows how big it is -- i.e. when you build a file system\nimage, it must fit into the flash chip, and it cannot be expanded once flashed.\nIt is important to give the  spiffimg  tool the correct size. You can provide either the  -c  option or both the  -U  and  -S  options.", 
            "title": "spiffsimg - Manipulate SPI Flash File System disk images"
        }, 
        {
            "location": "/en/spiffs/#syntax", 
            "text": "spiffsimg -f  filename  \n    [-o  offsetfile ]\n    [-c  size ] \n    [-S  flashsize ]\n    [-U  usedsize ]\n    [-d]\n    [-l | -i | -r  scriptname  ]", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/spiffs/#supported-operations", 
            "text": "-f  specifies the filename for the disk image. '%x' will be replaced by the calculated offset of the file system ( -U  must also be specified to calculate the offset).  -o  specifies the filename which is to contain the calculated offset.  -S  specifies the size of the flash chip.  32m  is 32 mbits,  4MB  is 4 megabytes.  -U  specifies the amount of flash used by the firmware. Decimal or Hex bytes (if starts with 0x).  -c  Create a blank disk image of the given size. Decimal or Hex bytes (if starts with 0x).  -l  List the contents of the given disk image.  -i  Interactive commands.  -r  Scripted commands from filename.  -d  causes the disk image to be deleted on error. This makes it easier to script.", 
            "title": "Supported operations:"
        }, 
        {
            "location": "/en/spiffs/#available-commands", 
            "text": "ls  List contents. Output format is {type} {size} {name}.  cat  filename  Dump file contents to stdout.  rm  filename  Delete file.  info  Display SPIFFS usage estimates.  import  srcfile   spiffsname  Import a file into the disk image.  export  spiffsname   dstfile  Export a file from the disk image.", 
            "title": "Available commands:"
        }, 
        {
            "location": "/en/spiffs/#example", 
            "text": "# spiffsimg -f flash.img -S 32m -U 524288 -i  import myapp/lua/init.lua init.lua  import myapp/lua/httpd.lua httpd.lua  import myapp/html/index.html http/index.html  import myapp/html/favicon.ico http/favicon.ico  ls\nf    122 init.lua\nf   5169 httpd.lua\nf   2121 http/index.html\nf    880 http/favicon.ico ^D\n#", 
            "title": "Example:"
        }, 
        {
            "location": "/en/spiffs/#known-limitations", 
            "text": "The block   page sizes are hard-coded to be compatible with nodemcu.  Error handling is not entirely consistent, some errors result in an\n    early exit, others just print an error (both cause a non-zero exit though).  Only flat SPIFFS is supported.", 
            "title": "Known limitations:"
        }, 
        {
            "location": "/en/spiffs/#technical-details", 
            "text": "The SPIFFS configuration is 4k sectors (the only size supported by the SDK) and 8k blocks. 256 byte pages. Magic is enabled and magic_len is also enabled. This allows the firmware to find the start of the filesystem (and also the size).\nOne of the goals is to make the filsystem more persistent across reflashing of the firmware. However, there are still cases\nwhere spiffs detects a filesystem and uses it when it isn't valid. If you are getting weirdness with the filesystem, then just reformat it.  There are two significant sizes of flash -- the 512K and 4M (or bigger).   The file system has to start on a 4k boundary, but since it ends on a much bigger boundary (a 16k boundary), it also starts on an 8k boundary. For the small flash chip, there is \nnot much spare space, so a newly formatted file system will start as low as possible (to get as much space as possible). For the large flash, the \nfile system will start on a 64k boundary. A newly formatted file system will start between 64k and 128k from the end of the firmware. This means that the file \nsystem will survive lots of reflashing and at least 64k of firmware growth.   The standard build process for the firmware builds the  spiffsimg  tool (found in the  tools/spiffsimg  subdirectory).\nThe top level Makfile also checks if\nthere is any data in the  local/fs  directory tree, and it will then copy these files\ninto the flash disk image. Two images will normally be created -- one for the 512k flash part and the other for the 4M flash part. If the data doesn't \nfit into the 512k part after the firmware is included, then the file will not be generated.\nThe disk image file is placed into the  bin  directory and it is named  0x offset - size .bin  where the offset is the location where it should be \nflashed, and the size is the size of the flash part. It is quite valid (and quicker) to flash the 512k image into a 4M part. However, there will probably be\nlimited space in the file system for creating new files.  The default configuration will try and build three different file systems for 512KB, 1MB and 4MB flash sizes. The 1MB size is suitable for the ESP8285. This can be overridden by specifying the FLASHSIZE parameter to the makefile.  If the  local/fs  directory is empty, then no flash images will be created (and the ones from the last build will be removed). The  spiffsimg  tool can \nthen be used to build an image as required.   If no file system is found during platform boot, then a new file system will be formatted. This can take some time on the first boot.  Note that the last 16k of the flash chip is reserved for the SDK to store parameters (such as the client wifi settings).  In order to speed up the boot time, it is possible to define (at build time) the size of the SPIFFS Filesystem to be formatted. This can be as small as 32768 bytes which gives a filesystem with about 15k bytes of usable space.\nJust place the following define in  user_config.h  or some other file that is included during the build.  #define SPIFFS_MAX_FILESYSTEM_SIZE  32768  This filesystem size limit only affects the formatting of a file system -- if the firm finds an existing valid filesystem (of any size) it will use that. However, if the \nfilesystem is reformatted from Lua (using file.format()) then the new file system will obey the size limit.   There is also an option to control the positioning of the SPIFFS file system:  #define SPIFFS_FIXED_LOCATION       0x100000  This specifies that the SPIFFS filesystem starts at 1Mb from the start of the flash. Unless otherwise specified, it will run to the end of the flash (excluding the 16k of space reserved by the SDK).   There is an option that limits the size of the file system to run up to the next 1MB boundary (minus the 16k for the parameter space). This may be useful when dealing with OTA upgrades.  #define SPIFFS_SIZE_1M_BOUNDARY", 
            "title": "Technical Details"
        }, 
        {
            "location": "/en/sdcard/", 
            "text": "FAT File System on SD Card\n\n\nAccessing files on external SD cards is currently only supported from the \nfile\n module. This imposes the same overall restrictions of internal SPIFFS to SD cards:\n\n\n\n\nno support for sub-folders\n\n\nno timestamps\n\n\nno file attributes (read-only, system, etc.)\n\n\n\n\nWork is in progress to extend the \nfile\n API with support for the missing features.\n\n\nEnabling FatFs\n\n\nThe FAT file system is implemented by \nChan's FatFs\n version \nR0.12a\n. It's disabled by default to save memory space and has to be enabled before compiling the firmware:\n\n\nUncomment \n#define BUILD_FATFS\n in \nuser_config.h\n.\n\n\nSD Card connection\n\n\nThe SD card is operated in SPI mode, thus the card has to be wired to the respective ESP pins of the HSPI interface. There are several naming schemes used on different adapters - the following list shows alternative terms:\n\n\n\n\nCK, CLK, SCLK\n to pin5 / GPIO14\n\n\nDO, DAT0, MISO\n to pin 6 / GPIO12\n\n\nDI, CMD, MOSI\n to pin 7 / GPIO13\n\n\nCS, DAT3, SS\n to pin 8 / GPIO15 recommended\n\n\nVCC, VDD\n to 3V3 supply\n\n\nVSS, GND\n to common ground\n\n\n\n\nConnection of \nSS/CS\n can be done to any of the GPIOs on pins 1 to 12. This allows coexistence of the SD card with other SPI slaves on the same bus. There's no support for detection of card presence or the write protection switch. These would need to be handled as additional GPIOs in the user application.\n\n\n\n\nCaution\n\n\nThe adapter does not require level shifters since SD and ESP are supposed to be powered with the same voltage. If your specific model contains level shifters then make sure that both sides can be operated at 3V3.\n\n\n\n\n\n\n\n\nLua bindings\n\n\nBefore mounting the volume(s) on the SD card, you need to initialize the SPI interface from Lua.\n\n\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)\n\n-- initialize other spi slaves\n\n-- then mount the sd\n-- note: the card initialization process during `file.mount()` will set spi divider temporarily to 200 (400 kHz)\n-- it's reverted back to the current user setting before `file.mount()` finishes\nvol = file.mount(\n/SD0\n, 8)   -- 2nd parameter is optional for non-standard SS/CS pin\nif not vol then\n  print(\nretry mounting\n)\n  vol = file.mount(\n/SD0\n, 8)\n  if not vol then\n    error(\nmount failed\n)\n  end\nend\nfile.open(\n/SD0/path/to/somefile\n)\nprint(file.read())\nfile.close()\n\n\n\n\n\n\nNote\n\n\nIf the card doesn't work when calling \nfile.mount()\n for the first time then re-try the command. It's possible that certain cards time out during the first initialization after power-up.\n\n\n\n\nThe logical drives are mounted at the root of a unified directory tree where the mount points distinguish between internal flash (\n/FLASH\n) and the card's paritions (\n/SD0\n to \n/SD3\n). Files are accessed via either the absolute hierarchical path or relative to the current working directory. It defaults to \n/FLASH\n and can be changed with \nfile.chdir(path)\n.\n\n\nSubdirectories are supported on FAT volumes only.\n\n\nMultiple partitions / multiple cards\n\n\nThe mapping from logical volumes (eg. \n/SD0\n) to partitions on an SD card is defined in \nfatfs_config.h\n. More volumes can be added to the \nVolToPart\n array with any combination of physical drive number (aka SS/CS pin) and partition number. Their names have to be added to \n_VOLUME_STRS\n in \nffconf.h\n as well.", 
            "title": "Filesystem on SD card"
        }, 
        {
            "location": "/en/sdcard/#fat-file-system-on-sd-card", 
            "text": "Accessing files on external SD cards is currently only supported from the  file  module. This imposes the same overall restrictions of internal SPIFFS to SD cards:   no support for sub-folders  no timestamps  no file attributes (read-only, system, etc.)   Work is in progress to extend the  file  API with support for the missing features.", 
            "title": "FAT File System on SD Card"
        }, 
        {
            "location": "/en/sdcard/#enabling-fatfs", 
            "text": "The FAT file system is implemented by  Chan's FatFs  version  R0.12a . It's disabled by default to save memory space and has to be enabled before compiling the firmware:  Uncomment  #define BUILD_FATFS  in  user_config.h .", 
            "title": "Enabling FatFs"
        }, 
        {
            "location": "/en/sdcard/#sd-card-connection", 
            "text": "The SD card is operated in SPI mode, thus the card has to be wired to the respective ESP pins of the HSPI interface. There are several naming schemes used on different adapters - the following list shows alternative terms:   CK, CLK, SCLK  to pin5 / GPIO14  DO, DAT0, MISO  to pin 6 / GPIO12  DI, CMD, MOSI  to pin 7 / GPIO13  CS, DAT3, SS  to pin 8 / GPIO15 recommended  VCC, VDD  to 3V3 supply  VSS, GND  to common ground   Connection of  SS/CS  can be done to any of the GPIOs on pins 1 to 12. This allows coexistence of the SD card with other SPI slaves on the same bus. There's no support for detection of card presence or the write protection switch. These would need to be handled as additional GPIOs in the user application.   Caution  The adapter does not require level shifters since SD and ESP are supposed to be powered with the same voltage. If your specific model contains level shifters then make sure that both sides can be operated at 3V3.", 
            "title": "SD Card connection"
        }, 
        {
            "location": "/en/sdcard/#lua-bindings", 
            "text": "Before mounting the volume(s) on the SD card, you need to initialize the SPI interface from Lua.  spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)\n\n-- initialize other spi slaves\n\n-- then mount the sd\n-- note: the card initialization process during `file.mount()` will set spi divider temporarily to 200 (400 kHz)\n-- it's reverted back to the current user setting before `file.mount()` finishes\nvol = file.mount( /SD0 , 8)   -- 2nd parameter is optional for non-standard SS/CS pin\nif not vol then\n  print( retry mounting )\n  vol = file.mount( /SD0 , 8)\n  if not vol then\n    error( mount failed )\n  end\nend\nfile.open( /SD0/path/to/somefile )\nprint(file.read())\nfile.close()   Note  If the card doesn't work when calling  file.mount()  for the first time then re-try the command. It's possible that certain cards time out during the first initialization after power-up.   The logical drives are mounted at the root of a unified directory tree where the mount points distinguish between internal flash ( /FLASH ) and the card's paritions ( /SD0  to  /SD3 ). Files are accessed via either the absolute hierarchical path or relative to the current working directory. It defaults to  /FLASH  and can be changed with  file.chdir(path) .  Subdirectories are supported on FAT volumes only.", 
            "title": "Lua bindings"
        }, 
        {
            "location": "/en/sdcard/#multiple-partitions-multiple-cards", 
            "text": "The mapping from logical volumes (eg.  /SD0 ) to partitions on an SD card is defined in  fatfs_config.h . More volumes can be added to the  VolToPart  array with any combination of physical drive number (aka SS/CS pin) and partition number. Their names have to be added to  _VOLUME_STRS  in  ffconf.h  as well.", 
            "title": "Multiple partitions / multiple cards"
        }, 
        {
            "location": "/en/upload/", 
            "text": "As with \nflashing\n there are several ways to upload code from your computer to the device.\n\n\n\n\nNote\n\n\nThe NodeMCU serial interface uses 115'200bps at boot time. To change the speed after booting, issue \nuart.setup(0,9600,8,0,1,1)\n. If the device panics and resets at any time, errors will be written to the serial interface at 115'200 bps.\n\n\n\n\nTools\n\n\nTransferring application code to ESP8266/8285 is an essential task, one that you'll perform quite frequently. Hence, it does make sense to try a few different uploading tools until you find one you feel comfortable with. \nhttps://frightanic.com/iot/tools-ides-nodemcu/\n lists almost a dozen classical uploaders - in addition to IDEs or IDE-like applications which of course transfer code as well.\n\n\nThe NodeMCU firmware team does not give any recommendations as for which uploader to use nor are there any \"NodeMCU approved\" tools. The below listed tools are just three, in no particular order, which seem popular and/or reasonably well maintained.\n\n\nESPlorer\n\n\n\n\nThe essential multiplatforms tools for any ESP8266 developer from luatool author\u2019s, including Lua for NodeMCU and MicroPython. Also, all AT commands are supported. Requires Java (Standard Edition - SE ver 7 and above) installed.\n\n\n\n\n\n\nSource: \nhttps://github.com/4refr0nt/ESPlorer\n\n\nSupported platforms: macOS, Linux, Windows, anything that runs Java\n\n\nnodemcu-uploader.py\n\n\n\n\nA simple tool for uploading files to the filesystem of an ESP8266 running NodeMCU as well as some other useful commands.\n\n\n\n\nSource: \nhttps://github.com/kmpm/nodemcu-uploader\n\n\nSupported platforms: macOS, Linux, Windows, anything that runs Python\n\n\nNodeMCU-Tool\n\n\n\n\nUpload/Download Lua files to your ESP8266 module with NodeMCU firmware.\nSimple. Command Line. Cross-Platform. File Management. NodeMCU.\n\n\n\n\nSource: \nhttps://github.com/andidittrich/NodeMCU-Tool\n\n\nSupported platforms: macOS, Linux Windows, anything that runs Node.js\n\n\ninit.lua\n\n\nYou will see \"lua: cannot open init.lua\" printed to the serial console when the device boots after it's been freshly flashed. If NodeMCU finds a \ninit.lua\n in the root of the file system it will execute it as part of the boot sequence (standard Lua feature). Hence, your application is initialized and triggered from \ninit.lua\n. Usually you first set up the WiFi connection and only continue once that has been successful.\n\n\nBe very careful not to lock yourself out! If there's a bug in your \ninit.lua\n you may be stuck in an infinite reboot loop. It is, therefore, advisable to build a small delay into your startup sequence that would allow you to interrupt the sequence by e.g. deleting or renaming \ninit.lua\n (see also \nFAQ\n). Your \ninit.lua\n is most likely going to be different than the one below but it's a good starting point for customizations:\n\n\n-- load credentials, 'SSID' and 'PASSWORD' declared and initialize in there\ndofile(\ncredentials.lua\n)\n\nfunction startup()\n    if file.open(\ninit.lua\n) == nil then\n        print(\ninit.lua deleted or renamed\n)\n    else\n        print(\nRunning\n)\n        file.close(\ninit.lua\n)\n        -- the actual application is stored in 'application.lua'\n        -- dofile(\napplication.lua\n)\n    end\nend\n\n-- Define WiFi station event callbacks \nwifi_connect_event = function(T) \n  print(\nConnection to AP(\n..T.SSID..\n) established!\n)\n  print(\nWaiting for IP address...\n)\n  if disconnect_ct ~= nil then disconnect_ct = nil end  \nend\n\nwifi_got_ip_event = function(T) \n  -- Note: Having an IP address does not mean there is internet access!\n  -- Internet connectivity can be determined with net.dns.resolve().    \n  print(\nWifi connection is ready! IP address is: \n..T.IP)\n  print(\nStartup will resume momentarily, you have 3 seconds to abort.\n)\n  print(\nWaiting...\n) \n  tmr.create():alarm(3000, tmr.ALARM_SINGLE, startup)\nend\n\nwifi_disconnect_event = function(T)\n  if T.reason == wifi.eventmon.reason.ASSOC_LEAVE then \n    --the station has disassociated from a previously connected AP\n    return \n  end\n  -- total_tries: how many times the station will attempt to connect to the AP. Should consider AP reboot duration.\n  local total_tries = 75\n  print(\n\\nWiFi connection to AP(\n..T.SSID..\n) has failed!\n)\n\n  --There are many possible disconnect reasons, the following iterates through \n  --the list and returns the string corresponding to the disconnect reason.\n  for key,val in pairs(wifi.eventmon.reason) do\n    if val == T.reason then\n      print(\nDisconnect reason: \n..val..\n(\n..key..\n)\n)\n      break\n    end\n  end\n\n  if disconnect_ct == nil then \n    disconnect_ct = 1 \n  else\n    disconnect_ct = disconnect_ct + 1 \n  end\n  if disconnect_ct \n total_tries then \n    print(\nRetrying connection...(attempt \n..(disconnect_ct+1)..\n of \n..total_tries..\n)\n)\n  else\n    wifi.sta.disconnect()\n    print(\nAborting connection to AP!\n)\n    disconnect_ct = nil  \n  end\nend\n\n-- Register WiFi Station event callbacks\nwifi.eventmon.register(wifi.eventmon.STA_CONNECTED, wifi_connect_event)\nwifi.eventmon.register(wifi.eventmon.STA_GOT_IP, wifi_got_ip_event)\nwifi.eventmon.register(wifi.eventmon.STA_DISCONNECTED, wifi_disconnect_event)\n\nprint(\nConnecting to WiFi access point...\n)\nwifi.setmode(wifi.STATION)\nwifi.sta.config({ssid=SSID, pwd=PASSWORD})\n-- wifi.sta.connect() not necessary because config() uses auto-connect=true by default\n\n\n\n\n\nCompiling Lua on your PC for Uploading\n\n\nIf you install \nlua\n on your development PC or Laptop then you can use the standard Lua\ncompiler to syntax check any Lua source before downloading it to the ESP8266 module.  However,\nthe NodeMCU compiler output uses different data types (e.g. it supports ROMtables) so the\ncompiled output cannot run on the ESP8266.  \n\n\nCompiling source on one platform for use on another (e.g. Intel x38 Window to ESP8266) is \nknown as \ncross-compilation\n and the NodeMCU firmware supports the compilation of \nluac.cross\n \non *nix patforms which have Lua 5.1, the Lua filesystem module (lfs), and the essential\nGCC tools. Simply change directory to the firmware root directoy and run the command:\n\n\nlua tools/cross-lua.lua\n\n\n\nThis will generate a \nluac.cross\n executable in your root directory which can be used to\ncompile and to syntax-check Lua source on the Development machine for execution under \nNodeMCU Lua on the ESP8266.", 
            "title": "Uploading code"
        }, 
        {
            "location": "/en/upload/#tools", 
            "text": "Transferring application code to ESP8266/8285 is an essential task, one that you'll perform quite frequently. Hence, it does make sense to try a few different uploading tools until you find one you feel comfortable with.  https://frightanic.com/iot/tools-ides-nodemcu/  lists almost a dozen classical uploaders - in addition to IDEs or IDE-like applications which of course transfer code as well.  The NodeMCU firmware team does not give any recommendations as for which uploader to use nor are there any \"NodeMCU approved\" tools. The below listed tools are just three, in no particular order, which seem popular and/or reasonably well maintained.", 
            "title": "Tools"
        }, 
        {
            "location": "/en/upload/#esplorer", 
            "text": "The essential multiplatforms tools for any ESP8266 developer from luatool author\u2019s, including Lua for NodeMCU and MicroPython. Also, all AT commands are supported. Requires Java (Standard Edition - SE ver 7 and above) installed.    Source:  https://github.com/4refr0nt/ESPlorer  Supported platforms: macOS, Linux, Windows, anything that runs Java", 
            "title": "ESPlorer"
        }, 
        {
            "location": "/en/upload/#nodemcu-uploaderpy", 
            "text": "A simple tool for uploading files to the filesystem of an ESP8266 running NodeMCU as well as some other useful commands.   Source:  https://github.com/kmpm/nodemcu-uploader  Supported platforms: macOS, Linux, Windows, anything that runs Python", 
            "title": "nodemcu-uploader.py"
        }, 
        {
            "location": "/en/upload/#nodemcu-tool", 
            "text": "Upload/Download Lua files to your ESP8266 module with NodeMCU firmware.\nSimple. Command Line. Cross-Platform. File Management. NodeMCU.   Source:  https://github.com/andidittrich/NodeMCU-Tool  Supported platforms: macOS, Linux Windows, anything that runs Node.js", 
            "title": "NodeMCU-Tool"
        }, 
        {
            "location": "/en/upload/#initlua", 
            "text": "You will see \"lua: cannot open init.lua\" printed to the serial console when the device boots after it's been freshly flashed. If NodeMCU finds a  init.lua  in the root of the file system it will execute it as part of the boot sequence (standard Lua feature). Hence, your application is initialized and triggered from  init.lua . Usually you first set up the WiFi connection and only continue once that has been successful.  Be very careful not to lock yourself out! If there's a bug in your  init.lua  you may be stuck in an infinite reboot loop. It is, therefore, advisable to build a small delay into your startup sequence that would allow you to interrupt the sequence by e.g. deleting or renaming  init.lua  (see also  FAQ ). Your  init.lua  is most likely going to be different than the one below but it's a good starting point for customizations:  -- load credentials, 'SSID' and 'PASSWORD' declared and initialize in there\ndofile( credentials.lua )\n\nfunction startup()\n    if file.open( init.lua ) == nil then\n        print( init.lua deleted or renamed )\n    else\n        print( Running )\n        file.close( init.lua )\n        -- the actual application is stored in 'application.lua'\n        -- dofile( application.lua )\n    end\nend\n\n-- Define WiFi station event callbacks \nwifi_connect_event = function(T) \n  print( Connection to AP( ..T.SSID.. ) established! )\n  print( Waiting for IP address... )\n  if disconnect_ct ~= nil then disconnect_ct = nil end  \nend\n\nwifi_got_ip_event = function(T) \n  -- Note: Having an IP address does not mean there is internet access!\n  -- Internet connectivity can be determined with net.dns.resolve().    \n  print( Wifi connection is ready! IP address is:  ..T.IP)\n  print( Startup will resume momentarily, you have 3 seconds to abort. )\n  print( Waiting... ) \n  tmr.create():alarm(3000, tmr.ALARM_SINGLE, startup)\nend\n\nwifi_disconnect_event = function(T)\n  if T.reason == wifi.eventmon.reason.ASSOC_LEAVE then \n    --the station has disassociated from a previously connected AP\n    return \n  end\n  -- total_tries: how many times the station will attempt to connect to the AP. Should consider AP reboot duration.\n  local total_tries = 75\n  print( \\nWiFi connection to AP( ..T.SSID.. ) has failed! )\n\n  --There are many possible disconnect reasons, the following iterates through \n  --the list and returns the string corresponding to the disconnect reason.\n  for key,val in pairs(wifi.eventmon.reason) do\n    if val == T.reason then\n      print( Disconnect reason:  ..val.. ( ..key.. ) )\n      break\n    end\n  end\n\n  if disconnect_ct == nil then \n    disconnect_ct = 1 \n  else\n    disconnect_ct = disconnect_ct + 1 \n  end\n  if disconnect_ct   total_tries then \n    print( Retrying connection...(attempt  ..(disconnect_ct+1)..  of  ..total_tries.. ) )\n  else\n    wifi.sta.disconnect()\n    print( Aborting connection to AP! )\n    disconnect_ct = nil  \n  end\nend\n\n-- Register WiFi Station event callbacks\nwifi.eventmon.register(wifi.eventmon.STA_CONNECTED, wifi_connect_event)\nwifi.eventmon.register(wifi.eventmon.STA_GOT_IP, wifi_got_ip_event)\nwifi.eventmon.register(wifi.eventmon.STA_DISCONNECTED, wifi_disconnect_event)\n\nprint( Connecting to WiFi access point... )\nwifi.setmode(wifi.STATION)\nwifi.sta.config({ssid=SSID, pwd=PASSWORD})\n-- wifi.sta.connect() not necessary because config() uses auto-connect=true by default", 
            "title": "init.lua"
        }, 
        {
            "location": "/en/upload/#compiling-lua-on-your-pc-for-uploading", 
            "text": "If you install  lua  on your development PC or Laptop then you can use the standard Lua\ncompiler to syntax check any Lua source before downloading it to the ESP8266 module.  However,\nthe NodeMCU compiler output uses different data types (e.g. it supports ROMtables) so the\ncompiled output cannot run on the ESP8266.    Compiling source on one platform for use on another (e.g. Intel x38 Window to ESP8266) is \nknown as  cross-compilation  and the NodeMCU firmware supports the compilation of  luac.cross  \non *nix patforms which have Lua 5.1, the Lua filesystem module (lfs), and the essential\nGCC tools. Simply change directory to the firmware root directoy and run the command:  lua tools/cross-lua.lua  This will generate a  luac.cross  executable in your root directory which can be used to\ncompile and to syntax-check Lua source on the Development machine for execution under \nNodeMCU Lua on the ESP8266.", 
            "title": "Compiling Lua on your PC for Uploading"
        }, 
        {
            "location": "/en/lua-developer-faq/", 
            "text": "FAQ\n\n\nThis FAQ was started by \nTerry Ellison\n as an unofficial FAQ in mid 2015.  This version as at April 2017 includes some significant rewrites.\n\n\nWhat is this FAQ for?\n\n\nThis FAQ does not aim to help you to learn to program or even how to program in Lua.  There are plenty of resources on the Internet for this, some of which are listed in \nWhere to start\n.  What this FAQ does is to answer some of the common questions that a competent Lua developer would ask in learning how to develop Lua applications for the ESP8266 based boards running the \nNodeMcu firmware\n.  This includes the NodeMCU Devkits.  However, the scope of the firmware is far wider than this as it can be used on any ESP8266 module.\n\n\nWhat has changed since the first version of this FAQ?\n\n\nThe \nNodeMCU company\n was set up by \nZeroday\n to develop and to market a set of Lua firmware-based development boards which employ the Espressif ESP8266 SoC.  The initial development of the firmware was done by Zeroday and a colleague, Vowstar, in-house with the firmware being first open-sourced on Github in late 2014.  In mid-2015, Zeroday decided to open the firmware development to a wider group of community developers, so the core group of developers now comprises 6 community developers (including this author), and we are also supported by another dozen or so active contributors, and two NodeMCU originators.\n\n\nThis larger active team has allowed us to address most of the outstanding issues present at the first version of this FAQ.  These include:\n\n\n\n\nFor some time the project was locked into an old SDK version, but we now regularly rebaseline to the current SDK version.\n\n\nJohny Mattsson's software exception handler and my LCD patch have allowed us to move the bulk of constant data out of RAM and into the firmware address space, and as a result current builds now typically boot with over 40Kb free RAM instead of 15Kb free and the code density is roughly 40% better.\n\n\nWe have  fixed error reporting so errors now correctly report line numbers in tracebacks.\n\n\nWe have addressed most of the various library resource leaks, so memory exhaustion is much less of an issue.\n\n\nWe have reimplemented the network stack natively over the now Open-sourced Espressif implementation of LwIP.\n\n\nThanks to a documentation effort lead by Marcel St\u00f6r, we now have a complete documentation online, and this FAQ forms a small part.\n\n\nWe have fixed various stability issues relating to the use of GPIO trigger callbacks.\n\n\nJohny Mattsson is currently leading an ESP32 port.\n\n\nWe have a lot more hardware modules supported.\n\n\n\n\nBecause the development is active this list will no doubt continue to be revised and updated.  See the \ndevelopment README\n for more details.\n\n\nLua Language\n\n\nWhere to start\n\n\nThe NodeMCU firmware implements Lua 5.1 over the Espressif SDK for its ESP8266 SoC and the IoT modules based on this.\n\n\n\n\nThe official lua.org \nLua Language specification\n  gives a terse but complete language specification.\n\n\nIts \nFAQ\n  provides information on Lua availability and licensing issues.\n\n\nThe \nunofficial Lua FAQ\n provides a lot of useful Q and A content, and is extremely useful for those learning Lua as a second language.\n\n\nThe \nLua User's Wiki\n  gives useful example source and relevant discussion. In particular, its \nLua Learning Lua\n  section is a good place to start learning Lua.\n\n\nThe best book to learn Lua is \nProgramming in Lua\n by Roberto Ierusalimschy, one of the creators of Lua. It's first edition is available free \nonline\n . The second edition was aimed at Lua 5.1, but is out of print. The third edition is still in print and available in paperback.  It contains a lot more material and clearly identifies Lua 5.1 vs Lua 5.2 differences. \nThis third edition is widely available for purchase and probably the best value for money\n. References of the format [PiL \nn.m\n] refer to section \nn.m\n in this edition.\n\n\nThe Espressif ESP8266 architecture is closed source, but the Espressif SDK itself is continually being updated so the best way to get the documentation for this is to \ngoogle Espressif IoT SDK Programming Guide\n or to look at the Espressif \ndownloads forum\n .\n\n\nThe \nNodeMCU documentation\n is now available online, and this FAQ forms part of this.\n\n\nAs with all Open Source projects the source for the NodeMCU firmware is openly available on the \nGitHub NodeMCU-firmware\n repository.\n\n\n\n\nHow is NodeMCU Lua different to standard Lua?\n\n\nWhilst the Lua standard distribution includes a stand-alone Lua interpreter, Lua itself is primarily an \nextension language\n that makes no assumptions about a \"main\" program: Lua works embedded in a host application to provide a powerful, lightweight scripting language for use within the application. This host application can then invoke functions to execute a piece of Lua code, can write and read Lua variables, and can register C functions to be called by Lua code. Through the use of C functions, Lua can be augmented to cope with a wide range of different domains, thus creating customized programming languages sharing a syntactical framework.\n\n\nThe ESP8266 was designed and is fabricated in China by \nEspressif Systems\n.  Espressif have also developed and released a companion software development kit (SDK) to enable developers to build practical IoT applications for the ESP8266.  The SDK is made freely available to developers in the form of binary libraries and SDK documentation.  However this is in a \nclosed format\n, with no developer access to the source files, so anyone developing ESP8266 applications must rely solely on the SDK API (and the somewhat Spartan SDK API documentation).  (Note that for the ESP32, Espressif have moved to an open-source approach for its ESP-IDF.)\n\n\nThe NodeMCU Lua firmware is an ESP8266 application and must therefore be layered over the ESP8266 SDK. However, the hooks and features of Lua enable it to be seamlessly integrated without losing any of the standard Lua language features.  The firmware has replaced some standard Lua modules that don't align well with the SDK structure with ESP8266-specific versions.  For example, the standard  \nio\n and \nos\n libraries don't work, but have been largely replaced by the NodeMCU \nnode\n and \nfile\n libraries.  The \ndebug\n and \nmath\n libraries have also been omitted to reduce the runtime footprint (\nmodulo\n can be done via \n%\n, \npower\n via \n^\n).\n\n\nNodeMCU Lua is based on \neLua\n, a fully featured implementation of Lua 5.1 that has been optimized for embedded system development and execution to provide a scripting framework that can be used to deliver useful applications within the limited RAM and Flash memory resources of embedded processors such as the ESP8266. One of the main changes introduced in the eLua fork is to use read-only tables and constants wherever practical for library modules.  On a typical build this approach reduces the RAM footprint by some 20-25KB and this makes a Lua implementation for the ESP8266 feasible. This technique is called LTR and this is documented in detail in an eLua technical paper: \nLua Tiny RAM\n.\n\n\nThe main impacts of the ESP8266 SDK and together with its hardware resource limitations are not in the Lua language implementation itself, but in how \napplication programmers must approach developing and structuring their applications\n. As discussed in detail below, the SDK is non-preemptive and event driven.  Tasks can be associated with given events by using the SDK API to registering callback functions to the corresponding events.  Events are queued internally within the SDK, and it then calls the associated tasks one at a time, with each task returning control to the SDK on completion. \nThe SDK states that if any tasks run for more than 15 mSec, then services such as WiFi can fail.\n\n\nThe NodeMCU libraries act as C wrappers around registered Lua callback functions to enable these to be used as SDK tasks. \nYou must therefore use an Event-driven programming style in writing your ESP8266 Lua programs\n.  Most programmers are used to writing in a procedural style where there is a clear single flow of execution, and the program interfaces to operating system services by a set of synchronous API calls to do network I/O, etc.  Whilst the logic of each individual task is procedural, this is not how you code up ESP8266 applications.\n\n\nESP8266 Specifics\n\n\nHow is coding for the ESP8266 the same as standard Lua?\n\n\n\n\nThis is a fully featured Lua 5.1 implementation so all standard Lua language constructs and data types work.\n\n\nThe main standard Lua libraries -- \ncore\n, \ncoroutine\n, \nstring\n and \ntable\n are implemented.\n\n\n\n\nHow is coding for the ESP8266 different to standard Lua?\n\n\n\n\nThe ESP8266 uses a combination of on-chip RAM and off-chip Flash memory connected using a dedicated SPI interface.  Code can be executed directly from Flash-mapped address space. In fact the ESP hardware actually executes code in RAM, and in the case of Flash-mapped addresses it executes this code from a RAM-based L1 cache which maps onto the Flash addresses.  If the addressed line is in the cache then the code runs at full clock speed, but if not then the hardware transparently handles the adress fault by first copying the code from Flash to RAM.  This is largely transparent in terms of programming ESP8266 applications, though the faulting access runs at SRAM speeds and this code runs perhaps 13\u00d7 slower than already cached code.  The Lua firmware largely runs out of Flash, but even so, both the RAM and the Flash memory are \nvery\n limited when compared to systems that most application programmers use.\n\n\nOver the last two years, both the Espressif non-OS SDK developers and the NodeMCU team have made a range of improvements and optimisations to increase the amount of RAM available to developers, from a typical 15Kb or so with Version 0.9 builds to some 45Kb with the current firmware Version 2.x builds.  See the \nESP8266 Non-OS SDK API Reference\n for more detals on the SDK.\n\n\nThe early ESP8266 modules were typically configured with 512Kb Flash.  Fitting a fully featured Lua build with a number of optional libraries and still enough usable Flash to hold a Lua application was a struggle.  However the code-size of the SDK has grown significantly between the early versions and the current 2.0 version.  Applications based on the current SDK can no longer fit in 512Kb Flash memory, and so all currently produced ESP modules now contain a minimum of 1Mb with 4 and 16Mb becoming more common. The current NodeMCU firmware will fit comfortably in a 1Mb Flash and still have ample remaining Flash memory to support Lua IoT applications. Note that the \n1.5.4.1-final\n branch\n is the last available release if you still wish to develop applications for 512Kb modules\n\n\nThe NodeMCU firmware makes any unused Flash memory available as a \nSPI Flash File System (SPIFFS)\n through the \nfile\n library. The SPIFFS file system is designed for SPI NOR flash devices on embedded targets, and is optimised for static wear levelling and low RAM footprint.  For further details, see the link.  How much Flash is available as SPIFFS file space depends on the number of modules included in the specific firmware build.\n\n\nThe firmware has a wide range of libraries available to support common hardware options.  Including any library will increase both the code and RAM size of the build, so our recommended practice is for application developers to choose a custom build that only includes the library that are needed for your application and hardware variants. The developers that don't want to bother with setting up their own build environment can use Marcel St\u00f6r's excellent \nCloud build service\n instead.\n\n\nThere are also further tailoring options available, for example you can choose to have a firmware build which uses 32-bit integer arithmetic instead of floating point.  Our integer builds have a smaller Flash footprint and execute faster, but working in integer also has a number of pitfalls, so our general recommendation is to use floating point builds.\n\n\nUnlike Arduino or ESP8266 development, where each application change requires the flashing of a new copy of the firmware, in the case of Lua the firmware is normally flashed once, and all application development is done by updating files on the SPIFFS file system.  In this respect, Lua development on the ESP8266 is far more like developing applications on a more traditional PC.  The firmware will only be reflashed if the developer wants to add or update one or more of the hardware-related libraries. \n\n\nThose developers who are used to dealing in MB or GB of RAM and file systems can easily run out of memory resources, but with care and using some of the techniques discussed below can go a long way to mitigate this.\n\n\nThe ESP8266 runs the SDK over the native hardware, so there is no underlying operating system to capture errors and to provide graceful failure modes.  Hence system or application errors can easily \"PANIC\" the system causing it to reboot. Error handling has been kept simple to save on the limited code space, and this exacerbates this tendency. Running out of a system resource such as RAM will invariably cause a messy failure and system reboot.\n\n\nNote that in the 3 years since the firmware was first developed, Espressif has developed and released a new RTOS alternative to the non-OS SDK, and and the latest version of the SDK API reference recommends using RTOS.  Unfortunately, the richer RTOS has a significantly larger RAM footprint.  Whilst our port to the ESP-32 (with its significantly larger RAM) uses the \nESP-IDF\n which is based on RTOS, the ESP8266 RTOS versions don't have enough free RAM for a RTOS-based NodeMCU firmware build to have sufficient free RAM to write usable applications. \n\n\nThere is currently no \ndebug\n library support. So you have to use 1980s-style \"binary-chop\" to locate errors and use print statement diagnostics though the system's UART interface.  (This omission was largely because of the Flash memory footprint of this library, but there is no reason in principle why we couldn't make this library available in the near future as a custom build option).\n\n\nThe LTR implementation means that you can't extend standard libraries as easily as you can in normal Lua, so for example an attempt to define \nfunction table.pack()\n will cause a runtime error because you can't write to the global \ntable\n. Standard sand-boxing techniques can be used to achieve the same effect by using metatable based inheritance, but if you choose this option, then you need to be aware of the potential runtime and RAM impacts of this approach.\n\n\nThere are standard libraries to provide access to the various hardware options supported by the hardware: WiFi, GPIO, One-wire, I\u00b2C, SPI, ADC, PWM, UART, etc.\n\n\nThe runtime system runs in interactive-mode.  In this mode it first executes any \ninit.lua\n script.  It then \"listens\" to the serial port for input Lua chunks, and executes them once syntactically complete. \n\n\nThere is no batch support, although automated embedded processing is normally achieved by setting up the necessary event triggers in the \ninit.lua\n script.\n\n\nThe various libraries (\nnet\n, \ntmr\n, \nwifi\n, etc.) use the SDK callback mechanism to bind Lua processing to individual events (for example a timer alarm firing).  Developers should make full use of these events to keep Lua execution sequences short.\n\n\nNon-Lua processing (e.g. network functions) will usually only take place once the current Lua chunk has completed execution.  So any network calls should be viewed at an asynchronous request. A common coding mistake is to assume that they are synchronous, that is if two \nsocket:send()\n are on consecutive lines in a Lua programme, then the first has completed by the time the second is executed.  This is wrong. A \nsocket:send()\n request simply queues the send task for dispatch by the SDK.  This task can't start to process until the Lua code has returned to is calling C function to allow this running task to exit. Stacking up such requests in a single Lua task function burns scarce RAM and can trigger a PANIC.  This is true for timer, network, and other callbacks.  It is even the case for actions such as requesting a system restart, as can be seen by the following example which will print twenty \"not quite yet\" messages before restarting.\n\n\n\n\nnode.restart(); for i = 1, 20 do print(\nnot quite yet -- \n,i); end\n\n\n\n\n\n\nYou therefore \nhave\n to implement ESP8266 Lua applications using an event driven approach.  You have to understand which SDK API requests schedule asynchronous processing, and which define event actions through Lua callbacks.  Yes, such an event-driven approach makes it difficult to develop procedurally structured applications, but it is well suited to developing the sorts of application that you will typically want to implement on an IoT device.\n\n\n\n\nSo how does the SDK event / tasking system work in Lua?\n\n\n\n\nThe SDK uses a small number of Interrupt Service Routines (ISRs) to handle short time critical hardware interrupt related processing. These are very short duration and can interrupt a running task for up to 10\u00b5Sec.  (Modifying these ISRs or adding new ones is not a viable options for most developers.)\n\n\nAll other service and application processing is split into code execution blocks, known as \ntasks\n.  The individual tasks are executed one at a time and run to completion. No task can never pre-empt another.\n\n\nRunnable tasks are queued in one of three priority queues and the SDK contains a simple scheduler which executes queued tasks FIFO within priority.  The high priority queue is used for hardware-related task, the middle for timer and event-driven tasks and the low priority queue for all other tasks.\n\n\nIt is important to keep task times as short as practical so that the overall system can work smoothly and responsively.  The general recommendation is to keep medium priority tasks under 2mSec and low priority tasks under 15 mSec in duration.  This is a guideline, and your application \nmight\n work stably if you exceed this, but you might also start to experience intermittent problems because of internal timeout within the WiFi and network services, etc..\n\n\nIf tasks take longer than 500mSec then the watchdog timer will reset the processor.  This watchdog can be reset at an application level using the \ntmr.wdclr()\n function, but this should be avoided.\n\n\nApplication tasks can disable interrupts to prevent an ISR interrupting a time-critical code section,  The SDK guideline is that system ISRs might overrun if such critical code section last more than 10\u00b5Sec.  This means that such disabling can only be done within hardware-related library modules, written in C; it is not available at a Lua application level.\n\n\nThe SDK provide a C API for interfacing to it; this includes a set of functions for declaring application functions (written in C) as callbacks to associate application tasks with specific hardware and timer events, and their execution will be interleaved with the SDKs Wifi and Network processing tasks.\n\n\n\n\nIn essence, the NodeMCU firmware is a C application which exploits the ability of Lua to execute as a embedded language and runtime to mirror this structure at a Lua scripting level.  All of the complexities of, and interface to, the SDK and the hardware are wrapped in firmware libraries which translate the appropriate calls into the corresponding Lua API.\n\n\n\n\nThe SDK invokes a startup hook within the firmware on boot-up.  This firmware code initialises the Lua environment and then attempts to execute the Lua module \ninit.lua\n from the SPIFFS file system.  This \ninit.lua\n  module can then be used to do any application initialisation required and to call the necessary timer alarms or library calls to bind and callback routines to implement the tasks needed in response to any system events.\n\n\nBy default, the Lua runtime also 'listens' to UART 0, the serial port, in interactive mode and will execute any Lua commands input through this serial port.  Using the serial port in this way is the most common method of developing and debugging Lua applications on the ESP8266/\n\n\nThe Lua libraries provide a set of functions for declaring application functions (written in Lua) as callbacks (which are stored in the \nLua registry\n) to associate application tasks with specific hardware and timer events.  These are also non-preemptive at an applications level. The Lua libraries work in consort with the SDK to queue pending events and invoke any registered Lua callback routines, which then run to completion uninterrupted.  For example the Lua \nmytimer:alarm(interval, repeat, callback)\n calls a function in the \ntmr\n library which registers a C function for this alarm using the SDK, and when this C alarm callback function is called it then in turn invokes the Lua callback.\n\n\nExcessively long-running Lua functions (or Lua code chunks executed at the interactive prompt through UART 0) can cause other system functions and services to timeout, or to allocate scarce RAM resources to buffer queued data, which can then trigger either the watchdog timer or memory exhaustion, both of which will ultimately cause the system to reboot.\n\n\nJust like their C counterparts, Lua tasks initiated by timer, network, GPIO and other callbacks run non pre-emptively to completion before the next task can run, and this includes SDK tasks. Printing to the default serial port is done by the Lua runtime libraries, but SDK services including even a reboot request are run as individual tasks.  This is why in the previous example printout out twenty copies of \"not quite yet --\" before completing and return control the SDK which then allows the reboot to occur. \n\n\n\n\nThis event-driven approach is very different to a conventional procedural applications written in Lua, and different from how you develop C sketches and applications for the Arduino architectures.  \nThere is little point in constructing poll loops in your NodeMCU Lua code since almost always the event that you are polling will not be delivered by the SDK until after your Lua code returns control to the SDK.\n  The most robust and efficient approach to coding ESP8266 Lua applications is to embrace this event model paradigm, and to decompose your application into atomic tasks that are threaded by events which themselves initiate callback functions.  Each event task is established by a callback in an API call in an earlier task. \n\n\nUnderstanding how the system executes your code can help you structure it better and improve both performance and memory usage. \n\n\n\n\n\n\nIf you are not using timers and other callback, then you are using the wrong approach.\n\n\n\n\n\n\nIf you are using poll loops, then you are using the wrong approach.\n\n\n\n\n\n\nIf you are executing more an a few hundred lines of Lua per callback, then you are using the wrong approach.\n\n\n\n\n\n\nSo what Lua library functions enable the registration of Lua callbacks?\n\n\nSDK Callbacks include:\n\n\n\n\n\n\n\n\nLua Module\n\n\nFunctions which define or remove callbacks\n\n\n\n\n\n\n\n\n\n\ntmr\n\n\nregister([id,] interval, mode, function())\n\n\n\n\n\n\nnode\n\n\ntask.post([task_priority], function)\n, \noutput(function(str), serial_debug)\n\n\n\n\n\n\nwifi\n\n\nstartsmart(chan, function())\n, \nsta.getap(function(table))\n\n\n\n\n\n\nnet.server\n\n\nsk:listen(port,[ip],function(socket))\n\n\n\n\n\n\nnet\n\n\nsk:on(event, function(socket, [, data]))\n, \nsk:send(string, function(sent))\n, \nsk:dns(domain, function(socket,ip))\n\n\n\n\n\n\ngpio\n\n\ntrig(pin, type, function(level))\n\n\n\n\n\n\nmqtt\n\n\nclient:m:on(event, function(conn[, topic, data])\n\n\n\n\n\n\nuart\n\n\nuart.on(event, cnt, [function(data)], [run_input])\n\n\n\n\n\n\n\n\nFor a comprehensive list refer to the Module documentation on this site.\n\n\nSo what are the different ways of declaring variables and how is NodeMCU different here?\n\n\nThe following is all standard Lua and is explained in detail in PiL etc., but it is worth summarising here because understanding this is of particular importance in the NodeMCU environment. \n\n\n\n\nAll variables in Lua can be classed as globals, locals or upvalues.  But by default any variable that is referenced and not previously declared as \nlocal\n is \nglobal\n and this variable will persist in the global table until it is explicitly deleted. If you want to see what global variables are in scope then try\n\n\n\n\n   for k,v in pairs(_G) do print(k,v) end\n\n\n\n\n\n\nLocal variables are 'lexically scoped', and you may declare any variables as local within nested blocks or functions without affecting the enclosing scope.\n\n\nBecause locals are lexically scoped you can also refer to local variables in an outer scope and these are still accessible within the inner scope. Such variables are know as \nupvalues\n..\n\n\nLua variable can be assigned two broad types of data: \nvalues\n such as numbers, booleans, and strings and \nreferences\n such as functions, tables and userdata.  You can see the difference here  when you assign the contents of a variable \na\n to \nb\n.  In the case of a value then it is simply copied into \nb\n.  In the case of a reference, both \na\n and \nb\n now refer to the \nsame object\n, and no copying of content takes place.  This process of referencing can have some counter-intuitive consequences. For example, in the following code by the time it exists, the variable \ntimer2func\n is out of scope.  However a reference to the function has now been stored in the Lua registry by the alarm API call, so it and any upvalues that it uses will persist until it is eventually entirely dereferenced (e.g. by \ntmr2:unregister()\n.\n\n\n\n\n  do\n    local tmr2func = function() ds.convert_T(true); tmr1:start() end\n    tmr2:alarm(300000, tmr.ALARM_AUTO, tmr2func)\n  end\n  -- \n\n\n\n\n\n\nYou need to understand the difference between when a function is compiled, when it is bound as a closure and when it is invoked at runtime. The closure is normally bound once pretty much immediately after compile, but this isn't necessarily the case.  Consider the following example from my MCP23008 module below.\n\n\n\n\n  --  Bind the read and write functions for commonly accessed registers\n\n  for reg, regAddr in pairs {\n    IODOR = 0x00,\n    GPPU  = 0x06,  -- Pull-up resistors register for MCP23008\n    GPIO  = 0x09,\n    OLAT = 0x0A,\n    } do  \n    dev['write'..reg] = function(o, dataByte)\n                          write(MCP23008addr, regAddr, dataByte)\n                        end\n    dev['read'..reg]  = function(o)\n                          return read(MCP23008addr, regAddr)\n                        end\n  end\n\n\n\n\n\n\nThis loop is compiled once when the module is required.   The opcode vectors for the read and write functions are created during the compile, along with a header which defines how many upvalues and locals are used by each function. However, these two functions are then bound \nfour\n times as different functions (e.g. \nmcp23008.writeIODOR()\n) and each closure inherits its own copies of the upvalues it uses so the \nregAddr\n for this function is \n0x00\n). The upvalue list is created when the closure is created and through some Lua magic, even if the outer routine that initially declared them is no longer in scope and has been GCed (Garbage Collected), the Lua RTS ensures that any upvalue will still persist whilst the closure persists.\n\n\nOn the other hand the storage for any locals is allocated each time the routine is called, and this can be many times in a running application.\n\n\nThe Lua runtime uses hashed key access internally to retrieve keyed data from a table.  On the other hand locals and upvalues are stored as a contiguous vector and are accessed directly by an index, which is a lot faster.  In NodeMCU Lua accesses to Firmware-based tables is particularly slow, which is why you will often see statements like the following at the beginning of modules.  \nUsing locals and upvalues this way is both a lot faster at runtime and generates less bytecode instructions for their access.\n\n\n\n\nlocal i2c = i2c\nlocal i2c_start, i2c_stop, i2c_address, i2c_read, i2c_write, i2c_TRANSMITTER, i2c_RECEIVER = \n      i2c.start, i2c.stop, i2c.address, i2c.read, i2c.write, i2c.TRANSMITTER, i2c.RECEIVER\n\n\n\n\n\n\nI will cover some useful Global and Upvalue techniques in later Qs.\n\n\n\n\nSo how is context passed between Lua event tasks?\n\n\n\n\nIt is important to understand that a single Lua function is associated with / bound to any event callback task. This function is executed from within the relevant NodeMCU library C code using a \nlua_call()\n. Even system initialisation which executes the \ndofile(\"init.lua\")\n is really a special case of this.  Each function can invoke other functions and so on, but it must ultimately return control to the C library code which then returns control the SDK, terminating the task. \n\n\nBy their very nature Lua \nlocal\n variables only exist within the context of an executing Lua function, and so locals are unreferenced on exit and any local data (unless also a reference type such as a function, table, or user data which is also referenced elsewhere) can therefore be garbage collected between these \nlua_call()\n actions. \n\n\n\n\nSo context can only be passed between event routines by one of the following mechanisms:\n\n\n\n\nGlobals\n are by nature globally accessible.  Any global will persist until explicitly dereferenced by assigning \nnil\n to it.  Globals can be readily enumerated, e.g. by a \nfor k,v in pairs(_G) do\n, so their use is transparent.\n\n\nThe \nFile system\n is a special case of persistent global, so there is no reason in principle why it and the files it contains can't be used to pass context.  However the ESP8266 file system uses flash memory and even with the SPIFFS file system still has a limited write cycle lifetime, so it is best to avoid using the file system to store frequently changing content except as a mechanism of last resort.\n\n\nThe \nLua Registry\n.  This is a normally hidden table used by the library modules to store callback functions and other Lua data types. The GC treats the registry as in scope and hence any content referenced in the registry will not be garbage collected. \n\n\nUpvalues\n.  These are a standard feature of Lua as described above that is fully implemented in NodeMCU.  When a function is declared within an outer function, all of the local variables within the outer scope are available to the inner function.  Ierusalimschy's paper, \nClosures in Lua\n, gives a lot more detail for those that want to dig deeper.\n\n\n\n\nSo how is the Lua Registry used and why is this important?\n\n\nAll Lua callbacks are called by C wrapper functions within the NodeMCU libraries that are themselves callbacks that have been activated by the SDK as a result of a given event.  Such C wrapper functions themselves frequently need to store state for passing between calls or to other wrapper C functions.  The Lua registry is a special Lua table which is used for this purpose, except that it is hidden from direct Lua access, but using a standard Lua table for this store enables standard garbage collection algorithms to operate on its content.  Any content that needs to be saved is created with a unique key.  The upvalues for functions that are global or referenced in the Lua Registry will persist between event routines, and hence any upvalues used by them will also persist and can be used for passing context.\n\n\n\n\nIf you are running out of memory, then you might not be correctly clearing down Registry entries.  One example is as above where you are setting up timers but not unregistering them.  Another occurs in the following code fragment. The \non()\n function passes the socket to the connection callback as it's first argument \nsck\n.  This is local variable in the callback function, and it also references the same socket as the upvalue \nsrv\n.  So functionally \nsrv\n and \nsck\n are interchangeable.  So why pass it as an argument?  Normally garbage collecting a socket will automatically unregister any of its callbacks, but if you use a socket as an upvalue in the callback, the socket is now referenced through the Register, and now it won't be GCed because it is referenced.  Catch-22 and a programming error, not a bug. \n\n\n\n\nsrv:on(\nconnection\n, function(sck, c)\n  svr:send(reply)\nend)\n\n\n\n\n\n\nOne way to check the registry is to use the construct \nfor k,v in pairs(debug.getregistry()) do print (k,v) end\n to track the registry size.  If this is growing then you've got a leak.\n\n\n\n\nHow do I track globals\n\n\n\n\n\n\nSee the Unofficial LUA FAQ: \nDetecting Undefined Variables\n.\n\n\n\n\n\n\nMy approach is to avoid using them unless I have a \nvery\n good reason to justify this. I track them statically by running a \nluac -p -l XXX.lua | grep GLOBAL\n filter on any new modules and replace any accidental globals by local or upvalued local declarations. \n\n\n\n\n\n\nOn NodeMCU, _G's metatable is _G, so you can create any globals that you need and then 'close the barn door' by assigning\n\n_G.__newindex=function(g,k,v) error (\"attempting to set global \"..k..\" to \"..v) end\n and any attempt to create new globals with now throw an error and give you a traceback of where this has happened.\n\n\n\n\n\n\nWhy is it importance to understand how upvalues are implemented when programming for the ESP8266?\n\n\nThe use of upvalues is a core Lua feature.  This is explained in detail in PiL.  Any Lua routines defined within an outer scope my use them.  This can include routines directly or indirectly referenced in the globals table, \n_G\n, or in the Lua Registry. \n\n\nThe number of upvalues associated with a given routine is calculated during compile and a stack vector is allocated for them when the closure is bound to hold these references.  Each upvalues is classed as open or closed. All upvalues are initially open which means that the upvalue references back to the outer function's register set.  However, upvalues must be able to outlive the scope of the outer routine where they are declared as a local variable.  The runtime VM does this by adding extra checks when executing a function return to scan any defined closures within its scope for back references and allocate memory to hold the upvalue and points the upvalue's reference to this.  This is known as a closed upvalue. \n\n\nThis processing is a mature part of the Lua 5.x runtime system, and for normal Lua applications development this \"behind-the-scenes\" magic ensures that upvalues just work as any programmer might expect.  Sufficient garbage collector metadata is also stored so that these hidden values will be garbage collected correctly \nwhen properly dereferenced\n.\n\n\nOne further complication is that some library functions don't implicitly dereference expired callback references and as a result their upvalues may not be garbage collected and this application error can be be manifested as a memory leak. So using upvalues can cause more frequent and difficult to diagnose PANICs during testing. So my general recommendation is still to stick to globals during initial development, and explicitly dereference resources by setting them to \nnil\n when you have done with them.\n\n\nCan I encapsulate actions such as sending an email in a Lua function?\n\n\nThink about the implications of these last few answers.\n\n An action such as composing and sending an email involves a message dialogue with a mail server over TCP.  This in turn requires calling multiple API calls to the SDK and your Lua code must return control to the C calling library for this to be scheduled, otherwise these requests will just queue up, you'll run out of RAM and your application will PANIC.\n\n Hence it is simply \nimpossible\n to write a Lua module so that you can do something like:\n\n\n-- prepare message\nstatus = mail.send(to, subject, body)\n-- move on to next phase of processing.\n\n\n\n\n\n\nBut you could code up a event-driven task to do this and pass it a callback to be executed on completion of the mail send, something along the lines of the following.  Note that since this involves a lot of asynchronous processing and which therefore won't take place until you've returned control to the calling library C code, you will typically execute this as the last step in a function and therefore this is best done as a tailcall [PiL 6.3].\n\n\n\n\n  -- prepare message\n  local ms = require(\nmail_sender\n)\n  return ms.send(to, subject, body, function(status)\n      loadfile(\nprocess_next.lua\n)(status)\n    end)\n\n\n\n\n\n\nBuilding an application on the ESP8266 is a bit like threading pearls onto a necklace.  Each pearl is an event task which must be small enough to run within its RAM resources and the string is the variable context that links the pearls together.\n\n\n\n\nWhen and why should I avoid using tmr.delay()?\n\n\nIf you are used coding in a procedural paradigm then it is understandable that you consider using \ntmr.delay()\n to time sequence your application.  However as discussed in the previous section, with NodeMCU Lua you are coding in an event-driven paradigm.  \n\n\nIf you look at the \napp/modules/tmr.c\n code for this function, then you will see that it executes a low level  \nets_delay_us(delay)\n.  This function isn't part of the NodeMCU code or the SDK; it's actually part of the xtensa-lx106 boot ROM, and is a simple timing loop which polls against the internal CPU clock.  \ntmr.delay()\n is really intended to be used where you need to have more precise timing control on an external hardware I/O (e.g. lifting a GPIO pin high for 20  \u03bcSec).  It does this with interrupts enabled, because so there is no guarantee that the delay will be as requested, and the Lua RTS itself may inject operations such as GC, so if you do this level of precise control then you should encode your application as a C library. \n\n\nIt will achieve no functional purpose in pretty much every other usecase, as any other system code-based activity will be blocked from execution; at worst it will break your application and create hard-to-diagnose timeout errors. We therefore deprecate its general use.\n\n\nHow do I avoid a PANIC loop in init.lua?\n\n\nMost of us have fallen into the trap of creating an \ninit.lua\n that has a bug in it, which then causes the system to reboot and hence gets stuck in a reboot loop.  If you haven't then you probably will do so at least once.\n\n\n\n\nWhen this happens, the only robust solution is to reflash the firmware.\n\n\nThe simplest way to avoid having to do this is to keep the \ninit.lua\n as simple as possible -- say configure the wifi and then start your app using a one-time \ntmr.alarm()\n after a 2-3 sec delay.  This delay is long enough to issue a \nfile.remove(\"init.lua\")\n through the serial port and recover control that way.\n\n\nAnother trick is to poll a spare GPIO input pin in your startup.  I do this on my boards by taking this GPIO plus Vcc to a jumper on the board, so that I can set the jumper to jump into debug mode or reprovision the software.\n\n\nAlso it is always best to test any new \ninit.lua\n by creating it as \ninit_test.lua\n, say, and manually issuing a \ndofile(\"init_test.lua\")\n through the serial port, and then only rename it when you are certain it is working as you require.\n\n\n\n\nSee \n\"Uploading code\" \u2192 init.lua\n for an example.\n\n\nCompiling and Debugging\n\n\n\n\n\n\nWe recommend that you install Lua 5.1 on your delopment host.  This often is useful for debugging Lua fragments on your PC.  You also use it for compile validation.\n\n\n\n\n\n\nYou can also build \nluac.cross\n on your development host if you have Lua locally installed.  This runs on your host and has all of the features of standard \nluac\n, except that the output code file will run under NodeMCU as an \nlc\n file.\n\n\n\n\n\n\nTechniques for Reducing RAM and SPIFFS footprint\n\n\nHow do I minimise the footprint of an application?\n\n\n\n\nPerhaps the simplest aspect of reducing the footprint of an application is to get its scope correct.  The ESP8266 is an IoT device and not a general purpose system.  It is typically used to attach real-world monitors, controls, etc. to an intranet and is therefore designed to implement functions that have limited scope.  We commonly come across developers who are trying to treat the ESP8266 as a general purpose device and can't understand why their application can't run.  \n\n\nThe simplest and safest way to use IoT devices is to control them through a dedicated general purpose system on the same network.  This could be a low cost system such as a \nRaspberryPi (RPi)\n server, running your custom code or an open source home automation (HA) application. Such systems have orders of magnitude more capacity than the ESP8266, for example the RPi has 2GB RAM and its SD card can be up to 32GB in capacity, and it can support the full range of USB-attached disk drives and other devices.  It also runs a fully featured Linux OS, and has a rich selection of applications pre configured for it. There are plenty of alternative systems available in this under $50 price range, as well as proprietary HA systems which can cost 10-50 times more.\n\n\nUsing a tiered approach where all user access to the ESP8266 is passed through a controlling server means that the end-user interface (or smartphone connector), together with all of the associated validation and security can be implemented on a system designed to have the capacity to do this.  This means that you can limit the scope of your ESP8266 application to a limited set of functions being sent to or responding to requests from this system.\n\n\nIf you are trying to implement a user-interface or HTTP webserver in your ESP8266 then you are really abusing its intended purpose.  When it comes to scoping your ESP8266 applications, the adage \nK\neep \nI\nt \nS\nimple \nS\ntupid truly applies.\n\n\n\n\nHow do I minimise the footprint of an application on the file system\n\n\n\n\nIt is possible to write Lua code in a very compact format which is very dense in terms of functionality per KB of source code.\n\n\nHowever if you do this then you will also find it extremely difficult to debug or maintain your application.\n\n\nA good compromise is to use a tool such as \nLuaSrcDiet\n, which you can use to compact production code for downloading to the ESP8266:\n\n\nKeep a master repository of your code on your PC or a cloud-based versioning repository such as \nGitHub\n\n\nLay it out and comment it for ease of maintenance and debugging \n\n\nUse a package such as \nEsplorer\n to download modules that you are debugging and to test them.\n\n\nOnce the code is tested and stable, then compress it using LuaSrcDiet before downloading to the ESP8266.  Doing this will reduce the code footprint on the SPIFFS by 2-3x.  Also note that LuaSrcDiet has a mode which achieves perhaps 95% of the possible code compaction but which still preserves line numbering.  This means that any line number-based error messages will still be usable.\n\n\nStandard Lua compiled code includes a lot of debug information which almost doubles its RAM size.  \nnode.stripdebug()\n can be used to change this default setting either to increase the debug information for a given module or to remove line number information to save a little more space.  Using \nnode.compile()\n to pre-compile any production code will remove all compiled code including error line info and so is not recommended except for stable production code where line numbers are not needed.\n\n\n\n\nHow do I minimise the footprint of running application?\n\n\n\n\nThe Lua Garbage collector is very aggressive at scanning and recovering dead resources.  It uses an incremental mark-and-sweep strategy which means that any data which is not ultimately referenced back to the Globals table, the Lua registry or in-scope local variables in the current Lua code will be collected.\n\n\nSetting any variable to \nnil\n dereferences the previous context of that variable.  (Note that reference-based variables such as tables, strings and functions can have multiple variables referencing the same object, but once the last reference has been set to \nnil\n, the collector will recover the storage.\n\n\nUnlike other compile-on-load languages such as PHP, Lua compiled code is treated the same way as any other variable type when it comes to garbage collection and can be collected when fully dereferenced, so that the code-space can be reused.\n\n\nThe default garbage collection mode is very aggressive and results in a GC sweep after every allocation.  See \nnode.egc.setmode()\n for how to turn this down. \nnode.egc.setmode(node.egc.ON_MEM_LIMIT, 4096)\n is a good compromise of performance and having enough free headboard.\n\n\nLua execution is intrinsically divided into separate event tasks with each bound to a Lua callback.  This, when coupled with the strong dispose on dereference feature, means that it is very easy to structure your application using an classic technique which dates back to the 1950s known as Overlays.\n\n\nVarious approaches can be use to implement this.  One is described by DP Whittaker in his \nMassive memory optimization: flash functions\n topic.  Another is to use \nvolatile modules\n.  There are standard Lua templates for creating modules, but the \nrequire()\n library function creates a reference for the loaded module in the \npackage.loaded\n table, and this reference prevents the module from being garbage collected.  To make a module volatile, you should remove this reference to the loaded module by setting its corresponding entry in \npackage.loaded\n to \nnil\n.  You can't do this in the outermost level of the module (since the reference is only created once execution has returned from the module code), but you can do it in any module function, and typically an initialisation function for the module, as in the following example:\n\n\n\n\nlocal s=net.createServer(net.TCP) \ns:listen(80,function(c) require(\nconnector\n).init(c) end) \n\n\n\n\n\n\nconnector.lua\n would be a standard module pattern except that the \nM.init()\n routine must include the lines\n\n\n\n\nlocal M, module = {}, ...\n...\nfunction M.init(csocket)\n  package.loaded[module]=nil\n  ...\nend\n--\nreturn M \n\n\n\n\n\n\nThis approach ensures that the module can be fully dereferenced on completion.  OK, in this case, this also means that the module has to be reloaded on each TCP connection to port 80; however, loading a compiled module from SPIFFS only takes a few mSec, so surely this is an acceptable overhead if it enables you to break down your application into RAM-sized chunks.  Note that \nrequire()\n will automatically search for \nconnector.lc\n followed by \nconnector.lua\n, so the code will work for both source and compiled variants. \n\n\nWhilst the general practice is for a module to return a table, [PiL 15.1] suggests that it is sometimes appropriate to return a single function instead as this avoids the memory overhead of an additional table. This pattern would look as follows:\n\n\n\n\n--\nlocal s=net.createServer(net.TCP) \ns:listen(80,function(c) require(\nconnector\n)(c) end) \n\n\n\n\nlocal module = _  -- this is a situation where using an upvalue is essential!\nreturn function (csocket)\n  package.loaded[module]=nil\n  module = nil\n  ...\nend\n\n\n\n\n\n\nAlso note that you should \nnot\n normally code this up listener call as the following because the RAM now has to accommodate both the module which creates the server \nand\n the connector logic.\n\n\n\n\n...\nlocal s=net.createServer(net.TCP)\nlocal connector = require(\nconnector\n) -- don't do this unless you've got the RAM available! \ns:listen(80,connector) \n\n\n\n\nHow do I reduce the size of my compiled code?\n\n\nNote that there are two methods of saving compiled Lua to SPIFFS:\n  - The first is to use \nnode.compile()\n on the \n.lua\n source file, which generates the equivalent bytecode \n.lc\n file. This approach strips out all the debug line and variable information.\n  - The second is to use \nloadfile()\n to load the source file into memory, followed by \nstring.dump()\n to convert it in-memory to a serialised load format which can then be written back to a \n.lc\n file.  The amount of debug saved will depend on the \nnode.stripdebug()\n settings.\n\n\nThe memory footprint of the bytecode created by method (2) is the same as when executing source files directly, but the footprint of bytecode created by method (1) is typically 10% smaller than a dump with the stripdebug level of 2 or 60% smaller than a dump with a  stripdebug level of 0, because the debug information is almost as large as the code itself.\n\n\nIn general consider method (1) if you have stable production code that you want to run in as low a RAM footprint as possible.  Yes, method (2) can be used if you are still debugging, but you will probably be changing this code quite frequently, so it is easier to stick with \n.lua\n files for code that you are still developing.\n\n\nNote that if you use \nrequire(\"XXX\")\n to load your code then this will automatically search for \nXXX.lc\n then \nXXX.lua\n so you don't need to include the conditional logic to load the bytecode version if it exists, falling back to the source version otherwise.\n\n\nHow do I get a feel for how much memory my functions use?\n\n\n\n\nYou should get an overall understanding of the VM model if you want to make good use of the limited resources available to Lua applications.  An essential reference here is \nA No Frills Introduction to Lua 5.1 VM Instructions\n .  This explain how the code generator works, how much memory overhead is involved with each table, function, string etc..\n\n\nYou can't easily get a bytecode listing of your ESP8266 code; however there are two broad options for doing this:\n\n\nGenerate a bytecode listing on your development PC\n. The Lua 5.1 code generator is basically the same on the PC and on the ESP8266, so whilst it isn't identical, using the standard Lua batch compiler \nluac\n against your source on your PC with the \n-l -s\n option will give you a good idea of what your code will generate.  The main difference between these two variants is the size_t for ESP8266 is 4 bytes rather than the 8 bytes size_t found on modern 64bit development PCs; and the eLua variants generate different access references for ROM data types.  If you want to see what the \nstring.dump()\n version generates then drop the \n-s\n option to retain the debug information.  You can also build \nluac.cross\n with this firmware and this generate lc code for the target ESP architecture.\n\n\nUpload your \n.lc\n files to the PC and disassemble them there\n. There are a number of Lua code disassemblers which can list off the compiled code that your application modules will generate, \nif\n you have a script to upload files from your ESP8266 to your development PC.  I use \nChunkSpy\n  which can be downloaded \nhere\n , but you will need to apply the following patch so that ChunkSpy understands eLua data types:\n\n\n\n\n --- a/ChunkSpy-0.9.8/5.1/ChunkSpy.lua   2015-05-04 12:39:01.267975498 +0100\n +++ b/ChunkSpy-0.9.8/5.1/ChunkSpy.lua   2015-05-04 12:35:59.623983095 +0100\n @@ -2193,6 +2193,9 @@\n            config.AUTO_DETECT = true\n          elseif a == \n--brief\n then\n            config.DISPLAY_BRIEF = true\n +        elseif a == \n--elua\n then\n +          config.LUA_TNUMBER = 5\n +          config.LUA_TSTRING = 6\n          elseif a == \n--interact\n then\n            perform = ChunkSpy_Interact\n\n\n\n\n\n\nYour other great friend is to use \nnode.heap()\n regularly through your code.\n\n\nUse these tools and play with coding approaches to see how many instructions each typical line of code takes in your coding style.  The Lua Wiki gives some general optimisation tips, but in general just remember that these focus on optimising for execution speed and you will be interested mainly in optimising for code and variable space as these are what consumes precious RAM.\n\n\n\n\nWhat is the cost of using functions?\n\n\nFunctions have fixed overheads, so in general the more that you group your application code into larger functions, then the less RAM used will be used overall.  The main caveat here is that if you are starting to do \"copy and paste\" coding across functions then you are wasting resources.  So of course you should still use functions to structure your code and encapsulate common repeated processing, but just bear in mind that each function definition has a relatively high overhead for its header record and stack frame.  \nSo try to avoid overusing functions. If there are less than a dozen or so lines in the function then you should consider putting this code inline if it makes sense to do so.\n\n\nWhat other resources are available?\n\n\n\n\nInstall lua and luac on your development PC.  This is freely available for Windows, Mac and Linux distributions, but we strongly suggest that you use Lua 5.1 to maintain source compatibility with ESP8266 code.  This will allow you not only to unit test some modules on your PC in a rich development environment, but you can also use \nluac\n to generate a bytecode listing of your code and to validate new code syntactically before downloading to the ESP8266.  This will also allow you to develop server-side applications and embedded applications in a common language. \n\n\n\n\nFirmware and Lua app development\n\n\nHow to reduce the size of the firmware?\n\n\n\n\nWe recommend that you use a tailored firmware build; one which only includes the modules that you plan to use in developing any Lua application. Once you have the ability to make and flash custom builds, the you also have the option of moving time sensitive or logic intensive code into your own custom module. Doing this can save a large amount of RAM as C code can be run directly from Flash memory. See \nBuilding the firmware\n for more details and options.", 
            "title": "Lua Developer FAQ"
        }, 
        {
            "location": "/en/lua-developer-faq/#faq", 
            "text": "This FAQ was started by  Terry Ellison  as an unofficial FAQ in mid 2015.  This version as at April 2017 includes some significant rewrites.", 
            "title": "FAQ"
        }, 
        {
            "location": "/en/lua-developer-faq/#what-is-this-faq-for", 
            "text": "This FAQ does not aim to help you to learn to program or even how to program in Lua.  There are plenty of resources on the Internet for this, some of which are listed in  Where to start .  What this FAQ does is to answer some of the common questions that a competent Lua developer would ask in learning how to develop Lua applications for the ESP8266 based boards running the  NodeMcu firmware .  This includes the NodeMCU Devkits.  However, the scope of the firmware is far wider than this as it can be used on any ESP8266 module.", 
            "title": "What is this FAQ for?"
        }, 
        {
            "location": "/en/lua-developer-faq/#what-has-changed-since-the-first-version-of-this-faq", 
            "text": "The  NodeMCU company  was set up by  Zeroday  to develop and to market a set of Lua firmware-based development boards which employ the Espressif ESP8266 SoC.  The initial development of the firmware was done by Zeroday and a colleague, Vowstar, in-house with the firmware being first open-sourced on Github in late 2014.  In mid-2015, Zeroday decided to open the firmware development to a wider group of community developers, so the core group of developers now comprises 6 community developers (including this author), and we are also supported by another dozen or so active contributors, and two NodeMCU originators.  This larger active team has allowed us to address most of the outstanding issues present at the first version of this FAQ.  These include:   For some time the project was locked into an old SDK version, but we now regularly rebaseline to the current SDK version.  Johny Mattsson's software exception handler and my LCD patch have allowed us to move the bulk of constant data out of RAM and into the firmware address space, and as a result current builds now typically boot with over 40Kb free RAM instead of 15Kb free and the code density is roughly 40% better.  We have  fixed error reporting so errors now correctly report line numbers in tracebacks.  We have addressed most of the various library resource leaks, so memory exhaustion is much less of an issue.  We have reimplemented the network stack natively over the now Open-sourced Espressif implementation of LwIP.  Thanks to a documentation effort lead by Marcel St\u00f6r, we now have a complete documentation online, and this FAQ forms a small part.  We have fixed various stability issues relating to the use of GPIO trigger callbacks.  Johny Mattsson is currently leading an ESP32 port.  We have a lot more hardware modules supported.   Because the development is active this list will no doubt continue to be revised and updated.  See the  development README  for more details.", 
            "title": "What has changed since the first version of this FAQ?"
        }, 
        {
            "location": "/en/lua-developer-faq/#lua-language", 
            "text": "", 
            "title": "Lua Language"
        }, 
        {
            "location": "/en/lua-developer-faq/#where-to-start", 
            "text": "The NodeMCU firmware implements Lua 5.1 over the Espressif SDK for its ESP8266 SoC and the IoT modules based on this.   The official lua.org  Lua Language specification   gives a terse but complete language specification.  Its  FAQ   provides information on Lua availability and licensing issues.  The  unofficial Lua FAQ  provides a lot of useful Q and A content, and is extremely useful for those learning Lua as a second language.  The  Lua User's Wiki   gives useful example source and relevant discussion. In particular, its  Lua Learning Lua   section is a good place to start learning Lua.  The best book to learn Lua is  Programming in Lua  by Roberto Ierusalimschy, one of the creators of Lua. It's first edition is available free  online  . The second edition was aimed at Lua 5.1, but is out of print. The third edition is still in print and available in paperback.  It contains a lot more material and clearly identifies Lua 5.1 vs Lua 5.2 differences.  This third edition is widely available for purchase and probably the best value for money . References of the format [PiL  n.m ] refer to section  n.m  in this edition.  The Espressif ESP8266 architecture is closed source, but the Espressif SDK itself is continually being updated so the best way to get the documentation for this is to  google Espressif IoT SDK Programming Guide  or to look at the Espressif  downloads forum  .  The  NodeMCU documentation  is now available online, and this FAQ forms part of this.  As with all Open Source projects the source for the NodeMCU firmware is openly available on the  GitHub NodeMCU-firmware  repository.", 
            "title": "Where to start"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-is-nodemcu-lua-different-to-standard-lua", 
            "text": "Whilst the Lua standard distribution includes a stand-alone Lua interpreter, Lua itself is primarily an  extension language  that makes no assumptions about a \"main\" program: Lua works embedded in a host application to provide a powerful, lightweight scripting language for use within the application. This host application can then invoke functions to execute a piece of Lua code, can write and read Lua variables, and can register C functions to be called by Lua code. Through the use of C functions, Lua can be augmented to cope with a wide range of different domains, thus creating customized programming languages sharing a syntactical framework.  The ESP8266 was designed and is fabricated in China by  Espressif Systems .  Espressif have also developed and released a companion software development kit (SDK) to enable developers to build practical IoT applications for the ESP8266.  The SDK is made freely available to developers in the form of binary libraries and SDK documentation.  However this is in a  closed format , with no developer access to the source files, so anyone developing ESP8266 applications must rely solely on the SDK API (and the somewhat Spartan SDK API documentation).  (Note that for the ESP32, Espressif have moved to an open-source approach for its ESP-IDF.)  The NodeMCU Lua firmware is an ESP8266 application and must therefore be layered over the ESP8266 SDK. However, the hooks and features of Lua enable it to be seamlessly integrated without losing any of the standard Lua language features.  The firmware has replaced some standard Lua modules that don't align well with the SDK structure with ESP8266-specific versions.  For example, the standard   io  and  os  libraries don't work, but have been largely replaced by the NodeMCU  node  and  file  libraries.  The  debug  and  math  libraries have also been omitted to reduce the runtime footprint ( modulo  can be done via  % ,  power  via  ^ ).  NodeMCU Lua is based on  eLua , a fully featured implementation of Lua 5.1 that has been optimized for embedded system development and execution to provide a scripting framework that can be used to deliver useful applications within the limited RAM and Flash memory resources of embedded processors such as the ESP8266. One of the main changes introduced in the eLua fork is to use read-only tables and constants wherever practical for library modules.  On a typical build this approach reduces the RAM footprint by some 20-25KB and this makes a Lua implementation for the ESP8266 feasible. This technique is called LTR and this is documented in detail in an eLua technical paper:  Lua Tiny RAM .  The main impacts of the ESP8266 SDK and together with its hardware resource limitations are not in the Lua language implementation itself, but in how  application programmers must approach developing and structuring their applications . As discussed in detail below, the SDK is non-preemptive and event driven.  Tasks can be associated with given events by using the SDK API to registering callback functions to the corresponding events.  Events are queued internally within the SDK, and it then calls the associated tasks one at a time, with each task returning control to the SDK on completion.  The SDK states that if any tasks run for more than 15 mSec, then services such as WiFi can fail.  The NodeMCU libraries act as C wrappers around registered Lua callback functions to enable these to be used as SDK tasks.  You must therefore use an Event-driven programming style in writing your ESP8266 Lua programs .  Most programmers are used to writing in a procedural style where there is a clear single flow of execution, and the program interfaces to operating system services by a set of synchronous API calls to do network I/O, etc.  Whilst the logic of each individual task is procedural, this is not how you code up ESP8266 applications.", 
            "title": "How is NodeMCU Lua different to standard Lua?"
        }, 
        {
            "location": "/en/lua-developer-faq/#esp8266-specifics", 
            "text": "", 
            "title": "ESP8266 Specifics"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-is-coding-for-the-esp8266-the-same-as-standard-lua", 
            "text": "This is a fully featured Lua 5.1 implementation so all standard Lua language constructs and data types work.  The main standard Lua libraries --  core ,  coroutine ,  string  and  table  are implemented.", 
            "title": "How is coding for the ESP8266 the same as standard Lua?"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-is-coding-for-the-esp8266-different-to-standard-lua", 
            "text": "The ESP8266 uses a combination of on-chip RAM and off-chip Flash memory connected using a dedicated SPI interface.  Code can be executed directly from Flash-mapped address space. In fact the ESP hardware actually executes code in RAM, and in the case of Flash-mapped addresses it executes this code from a RAM-based L1 cache which maps onto the Flash addresses.  If the addressed line is in the cache then the code runs at full clock speed, but if not then the hardware transparently handles the adress fault by first copying the code from Flash to RAM.  This is largely transparent in terms of programming ESP8266 applications, though the faulting access runs at SRAM speeds and this code runs perhaps 13\u00d7 slower than already cached code.  The Lua firmware largely runs out of Flash, but even so, both the RAM and the Flash memory are  very  limited when compared to systems that most application programmers use.  Over the last two years, both the Espressif non-OS SDK developers and the NodeMCU team have made a range of improvements and optimisations to increase the amount of RAM available to developers, from a typical 15Kb or so with Version 0.9 builds to some 45Kb with the current firmware Version 2.x builds.  See the  ESP8266 Non-OS SDK API Reference  for more detals on the SDK.  The early ESP8266 modules were typically configured with 512Kb Flash.  Fitting a fully featured Lua build with a number of optional libraries and still enough usable Flash to hold a Lua application was a struggle.  However the code-size of the SDK has grown significantly between the early versions and the current 2.0 version.  Applications based on the current SDK can no longer fit in 512Kb Flash memory, and so all currently produced ESP modules now contain a minimum of 1Mb with 4 and 16Mb becoming more common. The current NodeMCU firmware will fit comfortably in a 1Mb Flash and still have ample remaining Flash memory to support Lua IoT applications. Note that the  1.5.4.1-final  branch  is the last available release if you still wish to develop applications for 512Kb modules  The NodeMCU firmware makes any unused Flash memory available as a  SPI Flash File System (SPIFFS)  through the  file  library. The SPIFFS file system is designed for SPI NOR flash devices on embedded targets, and is optimised for static wear levelling and low RAM footprint.  For further details, see the link.  How much Flash is available as SPIFFS file space depends on the number of modules included in the specific firmware build.  The firmware has a wide range of libraries available to support common hardware options.  Including any library will increase both the code and RAM size of the build, so our recommended practice is for application developers to choose a custom build that only includes the library that are needed for your application and hardware variants. The developers that don't want to bother with setting up their own build environment can use Marcel St\u00f6r's excellent  Cloud build service  instead.  There are also further tailoring options available, for example you can choose to have a firmware build which uses 32-bit integer arithmetic instead of floating point.  Our integer builds have a smaller Flash footprint and execute faster, but working in integer also has a number of pitfalls, so our general recommendation is to use floating point builds.  Unlike Arduino or ESP8266 development, where each application change requires the flashing of a new copy of the firmware, in the case of Lua the firmware is normally flashed once, and all application development is done by updating files on the SPIFFS file system.  In this respect, Lua development on the ESP8266 is far more like developing applications on a more traditional PC.  The firmware will only be reflashed if the developer wants to add or update one or more of the hardware-related libraries.   Those developers who are used to dealing in MB or GB of RAM and file systems can easily run out of memory resources, but with care and using some of the techniques discussed below can go a long way to mitigate this.  The ESP8266 runs the SDK over the native hardware, so there is no underlying operating system to capture errors and to provide graceful failure modes.  Hence system or application errors can easily \"PANIC\" the system causing it to reboot. Error handling has been kept simple to save on the limited code space, and this exacerbates this tendency. Running out of a system resource such as RAM will invariably cause a messy failure and system reboot.  Note that in the 3 years since the firmware was first developed, Espressif has developed and released a new RTOS alternative to the non-OS SDK, and and the latest version of the SDK API reference recommends using RTOS.  Unfortunately, the richer RTOS has a significantly larger RAM footprint.  Whilst our port to the ESP-32 (with its significantly larger RAM) uses the  ESP-IDF  which is based on RTOS, the ESP8266 RTOS versions don't have enough free RAM for a RTOS-based NodeMCU firmware build to have sufficient free RAM to write usable applications.   There is currently no  debug  library support. So you have to use 1980s-style \"binary-chop\" to locate errors and use print statement diagnostics though the system's UART interface.  (This omission was largely because of the Flash memory footprint of this library, but there is no reason in principle why we couldn't make this library available in the near future as a custom build option).  The LTR implementation means that you can't extend standard libraries as easily as you can in normal Lua, so for example an attempt to define  function table.pack()  will cause a runtime error because you can't write to the global  table . Standard sand-boxing techniques can be used to achieve the same effect by using metatable based inheritance, but if you choose this option, then you need to be aware of the potential runtime and RAM impacts of this approach.  There are standard libraries to provide access to the various hardware options supported by the hardware: WiFi, GPIO, One-wire, I\u00b2C, SPI, ADC, PWM, UART, etc.  The runtime system runs in interactive-mode.  In this mode it first executes any  init.lua  script.  It then \"listens\" to the serial port for input Lua chunks, and executes them once syntactically complete.   There is no batch support, although automated embedded processing is normally achieved by setting up the necessary event triggers in the  init.lua  script.  The various libraries ( net ,  tmr ,  wifi , etc.) use the SDK callback mechanism to bind Lua processing to individual events (for example a timer alarm firing).  Developers should make full use of these events to keep Lua execution sequences short.  Non-Lua processing (e.g. network functions) will usually only take place once the current Lua chunk has completed execution.  So any network calls should be viewed at an asynchronous request. A common coding mistake is to assume that they are synchronous, that is if two  socket:send()  are on consecutive lines in a Lua programme, then the first has completed by the time the second is executed.  This is wrong. A  socket:send()  request simply queues the send task for dispatch by the SDK.  This task can't start to process until the Lua code has returned to is calling C function to allow this running task to exit. Stacking up such requests in a single Lua task function burns scarce RAM and can trigger a PANIC.  This is true for timer, network, and other callbacks.  It is even the case for actions such as requesting a system restart, as can be seen by the following example which will print twenty \"not quite yet\" messages before restarting.   node.restart(); for i = 1, 20 do print( not quite yet --  ,i); end   You therefore  have  to implement ESP8266 Lua applications using an event driven approach.  You have to understand which SDK API requests schedule asynchronous processing, and which define event actions through Lua callbacks.  Yes, such an event-driven approach makes it difficult to develop procedurally structured applications, but it is well suited to developing the sorts of application that you will typically want to implement on an IoT device.", 
            "title": "How is coding for the ESP8266 different to standard Lua?"
        }, 
        {
            "location": "/en/lua-developer-faq/#so-how-does-the-sdk-event-tasking-system-work-in-lua", 
            "text": "The SDK uses a small number of Interrupt Service Routines (ISRs) to handle short time critical hardware interrupt related processing. These are very short duration and can interrupt a running task for up to 10\u00b5Sec.  (Modifying these ISRs or adding new ones is not a viable options for most developers.)  All other service and application processing is split into code execution blocks, known as  tasks .  The individual tasks are executed one at a time and run to completion. No task can never pre-empt another.  Runnable tasks are queued in one of three priority queues and the SDK contains a simple scheduler which executes queued tasks FIFO within priority.  The high priority queue is used for hardware-related task, the middle for timer and event-driven tasks and the low priority queue for all other tasks.  It is important to keep task times as short as practical so that the overall system can work smoothly and responsively.  The general recommendation is to keep medium priority tasks under 2mSec and low priority tasks under 15 mSec in duration.  This is a guideline, and your application  might  work stably if you exceed this, but you might also start to experience intermittent problems because of internal timeout within the WiFi and network services, etc..  If tasks take longer than 500mSec then the watchdog timer will reset the processor.  This watchdog can be reset at an application level using the  tmr.wdclr()  function, but this should be avoided.  Application tasks can disable interrupts to prevent an ISR interrupting a time-critical code section,  The SDK guideline is that system ISRs might overrun if such critical code section last more than 10\u00b5Sec.  This means that such disabling can only be done within hardware-related library modules, written in C; it is not available at a Lua application level.  The SDK provide a C API for interfacing to it; this includes a set of functions for declaring application functions (written in C) as callbacks to associate application tasks with specific hardware and timer events, and their execution will be interleaved with the SDKs Wifi and Network processing tasks.   In essence, the NodeMCU firmware is a C application which exploits the ability of Lua to execute as a embedded language and runtime to mirror this structure at a Lua scripting level.  All of the complexities of, and interface to, the SDK and the hardware are wrapped in firmware libraries which translate the appropriate calls into the corresponding Lua API.   The SDK invokes a startup hook within the firmware on boot-up.  This firmware code initialises the Lua environment and then attempts to execute the Lua module  init.lua  from the SPIFFS file system.  This  init.lua   module can then be used to do any application initialisation required and to call the necessary timer alarms or library calls to bind and callback routines to implement the tasks needed in response to any system events.  By default, the Lua runtime also 'listens' to UART 0, the serial port, in interactive mode and will execute any Lua commands input through this serial port.  Using the serial port in this way is the most common method of developing and debugging Lua applications on the ESP8266/  The Lua libraries provide a set of functions for declaring application functions (written in Lua) as callbacks (which are stored in the  Lua registry ) to associate application tasks with specific hardware and timer events.  These are also non-preemptive at an applications level. The Lua libraries work in consort with the SDK to queue pending events and invoke any registered Lua callback routines, which then run to completion uninterrupted.  For example the Lua  mytimer:alarm(interval, repeat, callback)  calls a function in the  tmr  library which registers a C function for this alarm using the SDK, and when this C alarm callback function is called it then in turn invokes the Lua callback.  Excessively long-running Lua functions (or Lua code chunks executed at the interactive prompt through UART 0) can cause other system functions and services to timeout, or to allocate scarce RAM resources to buffer queued data, which can then trigger either the watchdog timer or memory exhaustion, both of which will ultimately cause the system to reboot.  Just like their C counterparts, Lua tasks initiated by timer, network, GPIO and other callbacks run non pre-emptively to completion before the next task can run, and this includes SDK tasks. Printing to the default serial port is done by the Lua runtime libraries, but SDK services including even a reboot request are run as individual tasks.  This is why in the previous example printout out twenty copies of \"not quite yet --\" before completing and return control the SDK which then allows the reboot to occur.    This event-driven approach is very different to a conventional procedural applications written in Lua, and different from how you develop C sketches and applications for the Arduino architectures.   There is little point in constructing poll loops in your NodeMCU Lua code since almost always the event that you are polling will not be delivered by the SDK until after your Lua code returns control to the SDK.   The most robust and efficient approach to coding ESP8266 Lua applications is to embrace this event model paradigm, and to decompose your application into atomic tasks that are threaded by events which themselves initiate callback functions.  Each event task is established by a callback in an API call in an earlier task.   Understanding how the system executes your code can help you structure it better and improve both performance and memory usage.     If you are not using timers and other callback, then you are using the wrong approach.    If you are using poll loops, then you are using the wrong approach.    If you are executing more an a few hundred lines of Lua per callback, then you are using the wrong approach.", 
            "title": "So how does the SDK event / tasking system work in Lua?"
        }, 
        {
            "location": "/en/lua-developer-faq/#so-what-lua-library-functions-enable-the-registration-of-lua-callbacks", 
            "text": "SDK Callbacks include:     Lua Module  Functions which define or remove callbacks      tmr  register([id,] interval, mode, function())    node  task.post([task_priority], function) ,  output(function(str), serial_debug)    wifi  startsmart(chan, function()) ,  sta.getap(function(table))    net.server  sk:listen(port,[ip],function(socket))    net  sk:on(event, function(socket, [, data])) ,  sk:send(string, function(sent)) ,  sk:dns(domain, function(socket,ip))    gpio  trig(pin, type, function(level))    mqtt  client:m:on(event, function(conn[, topic, data])    uart  uart.on(event, cnt, [function(data)], [run_input])     For a comprehensive list refer to the Module documentation on this site.", 
            "title": "So what Lua library functions enable the registration of Lua callbacks?"
        }, 
        {
            "location": "/en/lua-developer-faq/#so-what-are-the-different-ways-of-declaring-variables-and-how-is-nodemcu-different-here", 
            "text": "The following is all standard Lua and is explained in detail in PiL etc., but it is worth summarising here because understanding this is of particular importance in the NodeMCU environment.    All variables in Lua can be classed as globals, locals or upvalues.  But by default any variable that is referenced and not previously declared as  local  is  global  and this variable will persist in the global table until it is explicitly deleted. If you want to see what global variables are in scope then try      for k,v in pairs(_G) do print(k,v) end   Local variables are 'lexically scoped', and you may declare any variables as local within nested blocks or functions without affecting the enclosing scope.  Because locals are lexically scoped you can also refer to local variables in an outer scope and these are still accessible within the inner scope. Such variables are know as  upvalues ..  Lua variable can be assigned two broad types of data:  values  such as numbers, booleans, and strings and  references  such as functions, tables and userdata.  You can see the difference here  when you assign the contents of a variable  a  to  b .  In the case of a value then it is simply copied into  b .  In the case of a reference, both  a  and  b  now refer to the  same object , and no copying of content takes place.  This process of referencing can have some counter-intuitive consequences. For example, in the following code by the time it exists, the variable  timer2func  is out of scope.  However a reference to the function has now been stored in the Lua registry by the alarm API call, so it and any upvalues that it uses will persist until it is eventually entirely dereferenced (e.g. by  tmr2:unregister() .     do\n    local tmr2func = function() ds.convert_T(true); tmr1:start() end\n    tmr2:alarm(300000, tmr.ALARM_AUTO, tmr2func)\n  end\n  --    You need to understand the difference between when a function is compiled, when it is bound as a closure and when it is invoked at runtime. The closure is normally bound once pretty much immediately after compile, but this isn't necessarily the case.  Consider the following example from my MCP23008 module below.     --  Bind the read and write functions for commonly accessed registers\n\n  for reg, regAddr in pairs {\n    IODOR = 0x00,\n    GPPU  = 0x06,  -- Pull-up resistors register for MCP23008\n    GPIO  = 0x09,\n    OLAT = 0x0A,\n    } do  \n    dev['write'..reg] = function(o, dataByte)\n                          write(MCP23008addr, regAddr, dataByte)\n                        end\n    dev['read'..reg]  = function(o)\n                          return read(MCP23008addr, regAddr)\n                        end\n  end   This loop is compiled once when the module is required.   The opcode vectors for the read and write functions are created during the compile, along with a header which defines how many upvalues and locals are used by each function. However, these two functions are then bound  four  times as different functions (e.g.  mcp23008.writeIODOR() ) and each closure inherits its own copies of the upvalues it uses so the  regAddr  for this function is  0x00 ). The upvalue list is created when the closure is created and through some Lua magic, even if the outer routine that initially declared them is no longer in scope and has been GCed (Garbage Collected), the Lua RTS ensures that any upvalue will still persist whilst the closure persists.  On the other hand the storage for any locals is allocated each time the routine is called, and this can be many times in a running application.  The Lua runtime uses hashed key access internally to retrieve keyed data from a table.  On the other hand locals and upvalues are stored as a contiguous vector and are accessed directly by an index, which is a lot faster.  In NodeMCU Lua accesses to Firmware-based tables is particularly slow, which is why you will often see statements like the following at the beginning of modules.   Using locals and upvalues this way is both a lot faster at runtime and generates less bytecode instructions for their access.   local i2c = i2c\nlocal i2c_start, i2c_stop, i2c_address, i2c_read, i2c_write, i2c_TRANSMITTER, i2c_RECEIVER = \n      i2c.start, i2c.stop, i2c.address, i2c.read, i2c.write, i2c.TRANSMITTER, i2c.RECEIVER   I will cover some useful Global and Upvalue techniques in later Qs.", 
            "title": "So what are the different ways of declaring variables and how is NodeMCU different here?"
        }, 
        {
            "location": "/en/lua-developer-faq/#so-how-is-context-passed-between-lua-event-tasks", 
            "text": "It is important to understand that a single Lua function is associated with / bound to any event callback task. This function is executed from within the relevant NodeMCU library C code using a  lua_call() . Even system initialisation which executes the  dofile(\"init.lua\")  is really a special case of this.  Each function can invoke other functions and so on, but it must ultimately return control to the C library code which then returns control the SDK, terminating the task.   By their very nature Lua  local  variables only exist within the context of an executing Lua function, and so locals are unreferenced on exit and any local data (unless also a reference type such as a function, table, or user data which is also referenced elsewhere) can therefore be garbage collected between these  lua_call()  actions.    So context can only be passed between event routines by one of the following mechanisms:   Globals  are by nature globally accessible.  Any global will persist until explicitly dereferenced by assigning  nil  to it.  Globals can be readily enumerated, e.g. by a  for k,v in pairs(_G) do , so their use is transparent.  The  File system  is a special case of persistent global, so there is no reason in principle why it and the files it contains can't be used to pass context.  However the ESP8266 file system uses flash memory and even with the SPIFFS file system still has a limited write cycle lifetime, so it is best to avoid using the file system to store frequently changing content except as a mechanism of last resort.  The  Lua Registry .  This is a normally hidden table used by the library modules to store callback functions and other Lua data types. The GC treats the registry as in scope and hence any content referenced in the registry will not be garbage collected.   Upvalues .  These are a standard feature of Lua as described above that is fully implemented in NodeMCU.  When a function is declared within an outer function, all of the local variables within the outer scope are available to the inner function.  Ierusalimschy's paper,  Closures in Lua , gives a lot more detail for those that want to dig deeper.", 
            "title": "So how is context passed between Lua event tasks?"
        }, 
        {
            "location": "/en/lua-developer-faq/#so-how-is-the-lua-registry-used-and-why-is-this-important", 
            "text": "All Lua callbacks are called by C wrapper functions within the NodeMCU libraries that are themselves callbacks that have been activated by the SDK as a result of a given event.  Such C wrapper functions themselves frequently need to store state for passing between calls or to other wrapper C functions.  The Lua registry is a special Lua table which is used for this purpose, except that it is hidden from direct Lua access, but using a standard Lua table for this store enables standard garbage collection algorithms to operate on its content.  Any content that needs to be saved is created with a unique key.  The upvalues for functions that are global or referenced in the Lua Registry will persist between event routines, and hence any upvalues used by them will also persist and can be used for passing context.   If you are running out of memory, then you might not be correctly clearing down Registry entries.  One example is as above where you are setting up timers but not unregistering them.  Another occurs in the following code fragment. The  on()  function passes the socket to the connection callback as it's first argument  sck .  This is local variable in the callback function, and it also references the same socket as the upvalue  srv .  So functionally  srv  and  sck  are interchangeable.  So why pass it as an argument?  Normally garbage collecting a socket will automatically unregister any of its callbacks, but if you use a socket as an upvalue in the callback, the socket is now referenced through the Register, and now it won't be GCed because it is referenced.  Catch-22 and a programming error, not a bug.    srv:on( connection , function(sck, c)\n  svr:send(reply)\nend)   One way to check the registry is to use the construct  for k,v in pairs(debug.getregistry()) do print (k,v) end  to track the registry size.  If this is growing then you've got a leak.", 
            "title": "So how is the Lua Registry used and why is this important?"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-do-i-track-globals", 
            "text": "See the Unofficial LUA FAQ:  Detecting Undefined Variables .    My approach is to avoid using them unless I have a  very  good reason to justify this. I track them statically by running a  luac -p -l XXX.lua | grep GLOBAL  filter on any new modules and replace any accidental globals by local or upvalued local declarations.     On NodeMCU, _G's metatable is _G, so you can create any globals that you need and then 'close the barn door' by assigning _G.__newindex=function(g,k,v) error (\"attempting to set global \"..k..\" to \"..v) end  and any attempt to create new globals with now throw an error and give you a traceback of where this has happened.", 
            "title": "How do I track globals"
        }, 
        {
            "location": "/en/lua-developer-faq/#why-is-it-importance-to-understand-how-upvalues-are-implemented-when-programming-for-the-esp8266", 
            "text": "The use of upvalues is a core Lua feature.  This is explained in detail in PiL.  Any Lua routines defined within an outer scope my use them.  This can include routines directly or indirectly referenced in the globals table,  _G , or in the Lua Registry.   The number of upvalues associated with a given routine is calculated during compile and a stack vector is allocated for them when the closure is bound to hold these references.  Each upvalues is classed as open or closed. All upvalues are initially open which means that the upvalue references back to the outer function's register set.  However, upvalues must be able to outlive the scope of the outer routine where they are declared as a local variable.  The runtime VM does this by adding extra checks when executing a function return to scan any defined closures within its scope for back references and allocate memory to hold the upvalue and points the upvalue's reference to this.  This is known as a closed upvalue.   This processing is a mature part of the Lua 5.x runtime system, and for normal Lua applications development this \"behind-the-scenes\" magic ensures that upvalues just work as any programmer might expect.  Sufficient garbage collector metadata is also stored so that these hidden values will be garbage collected correctly  when properly dereferenced .  One further complication is that some library functions don't implicitly dereference expired callback references and as a result their upvalues may not be garbage collected and this application error can be be manifested as a memory leak. So using upvalues can cause more frequent and difficult to diagnose PANICs during testing. So my general recommendation is still to stick to globals during initial development, and explicitly dereference resources by setting them to  nil  when you have done with them.", 
            "title": "Why is it importance to understand how upvalues are implemented when programming for the ESP8266?"
        }, 
        {
            "location": "/en/lua-developer-faq/#can-i-encapsulate-actions-such-as-sending-an-email-in-a-lua-function", 
            "text": "Think about the implications of these last few answers.  An action such as composing and sending an email involves a message dialogue with a mail server over TCP.  This in turn requires calling multiple API calls to the SDK and your Lua code must return control to the C calling library for this to be scheduled, otherwise these requests will just queue up, you'll run out of RAM and your application will PANIC.  Hence it is simply  impossible  to write a Lua module so that you can do something like:  -- prepare message\nstatus = mail.send(to, subject, body)\n-- move on to next phase of processing.   But you could code up a event-driven task to do this and pass it a callback to be executed on completion of the mail send, something along the lines of the following.  Note that since this involves a lot of asynchronous processing and which therefore won't take place until you've returned control to the calling library C code, you will typically execute this as the last step in a function and therefore this is best done as a tailcall [PiL 6.3].     -- prepare message\n  local ms = require( mail_sender )\n  return ms.send(to, subject, body, function(status)\n      loadfile( process_next.lua )(status)\n    end)   Building an application on the ESP8266 is a bit like threading pearls onto a necklace.  Each pearl is an event task which must be small enough to run within its RAM resources and the string is the variable context that links the pearls together.", 
            "title": "Can I encapsulate actions such as sending an email in a Lua function?"
        }, 
        {
            "location": "/en/lua-developer-faq/#when-and-why-should-i-avoid-using-tmrdelay", 
            "text": "If you are used coding in a procedural paradigm then it is understandable that you consider using  tmr.delay()  to time sequence your application.  However as discussed in the previous section, with NodeMCU Lua you are coding in an event-driven paradigm.    If you look at the  app/modules/tmr.c  code for this function, then you will see that it executes a low level   ets_delay_us(delay) .  This function isn't part of the NodeMCU code or the SDK; it's actually part of the xtensa-lx106 boot ROM, and is a simple timing loop which polls against the internal CPU clock.   tmr.delay()  is really intended to be used where you need to have more precise timing control on an external hardware I/O (e.g. lifting a GPIO pin high for 20  \u03bcSec).  It does this with interrupts enabled, because so there is no guarantee that the delay will be as requested, and the Lua RTS itself may inject operations such as GC, so if you do this level of precise control then you should encode your application as a C library.   It will achieve no functional purpose in pretty much every other usecase, as any other system code-based activity will be blocked from execution; at worst it will break your application and create hard-to-diagnose timeout errors. We therefore deprecate its general use.", 
            "title": "When and why should I avoid using tmr.delay()?"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-do-i-avoid-a-panic-loop-in-initlua", 
            "text": "Most of us have fallen into the trap of creating an  init.lua  that has a bug in it, which then causes the system to reboot and hence gets stuck in a reboot loop.  If you haven't then you probably will do so at least once.   When this happens, the only robust solution is to reflash the firmware.  The simplest way to avoid having to do this is to keep the  init.lua  as simple as possible -- say configure the wifi and then start your app using a one-time  tmr.alarm()  after a 2-3 sec delay.  This delay is long enough to issue a  file.remove(\"init.lua\")  through the serial port and recover control that way.  Another trick is to poll a spare GPIO input pin in your startup.  I do this on my boards by taking this GPIO plus Vcc to a jumper on the board, so that I can set the jumper to jump into debug mode or reprovision the software.  Also it is always best to test any new  init.lua  by creating it as  init_test.lua , say, and manually issuing a  dofile(\"init_test.lua\")  through the serial port, and then only rename it when you are certain it is working as you require.   See  \"Uploading code\" \u2192 init.lua  for an example.", 
            "title": "How do I avoid a PANIC loop in init.lua?"
        }, 
        {
            "location": "/en/lua-developer-faq/#compiling-and-debugging", 
            "text": "We recommend that you install Lua 5.1 on your delopment host.  This often is useful for debugging Lua fragments on your PC.  You also use it for compile validation.    You can also build  luac.cross  on your development host if you have Lua locally installed.  This runs on your host and has all of the features of standard  luac , except that the output code file will run under NodeMCU as an  lc  file.", 
            "title": "Compiling and Debugging"
        }, 
        {
            "location": "/en/lua-developer-faq/#techniques-for-reducing-ram-and-spiffs-footprint", 
            "text": "", 
            "title": "Techniques for Reducing RAM and SPIFFS footprint"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-do-i-minimise-the-footprint-of-an-application", 
            "text": "Perhaps the simplest aspect of reducing the footprint of an application is to get its scope correct.  The ESP8266 is an IoT device and not a general purpose system.  It is typically used to attach real-world monitors, controls, etc. to an intranet and is therefore designed to implement functions that have limited scope.  We commonly come across developers who are trying to treat the ESP8266 as a general purpose device and can't understand why their application can't run.    The simplest and safest way to use IoT devices is to control them through a dedicated general purpose system on the same network.  This could be a low cost system such as a  RaspberryPi (RPi)  server, running your custom code or an open source home automation (HA) application. Such systems have orders of magnitude more capacity than the ESP8266, for example the RPi has 2GB RAM and its SD card can be up to 32GB in capacity, and it can support the full range of USB-attached disk drives and other devices.  It also runs a fully featured Linux OS, and has a rich selection of applications pre configured for it. There are plenty of alternative systems available in this under $50 price range, as well as proprietary HA systems which can cost 10-50 times more.  Using a tiered approach where all user access to the ESP8266 is passed through a controlling server means that the end-user interface (or smartphone connector), together with all of the associated validation and security can be implemented on a system designed to have the capacity to do this.  This means that you can limit the scope of your ESP8266 application to a limited set of functions being sent to or responding to requests from this system.  If you are trying to implement a user-interface or HTTP webserver in your ESP8266 then you are really abusing its intended purpose.  When it comes to scoping your ESP8266 applications, the adage  K eep  I t  S imple  S tupid truly applies.", 
            "title": "How do I minimise the footprint of an application?"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-do-i-minimise-the-footprint-of-an-application-on-the-file-system", 
            "text": "It is possible to write Lua code in a very compact format which is very dense in terms of functionality per KB of source code.  However if you do this then you will also find it extremely difficult to debug or maintain your application.  A good compromise is to use a tool such as  LuaSrcDiet , which you can use to compact production code for downloading to the ESP8266:  Keep a master repository of your code on your PC or a cloud-based versioning repository such as  GitHub  Lay it out and comment it for ease of maintenance and debugging   Use a package such as  Esplorer  to download modules that you are debugging and to test them.  Once the code is tested and stable, then compress it using LuaSrcDiet before downloading to the ESP8266.  Doing this will reduce the code footprint on the SPIFFS by 2-3x.  Also note that LuaSrcDiet has a mode which achieves perhaps 95% of the possible code compaction but which still preserves line numbering.  This means that any line number-based error messages will still be usable.  Standard Lua compiled code includes a lot of debug information which almost doubles its RAM size.   node.stripdebug()  can be used to change this default setting either to increase the debug information for a given module or to remove line number information to save a little more space.  Using  node.compile()  to pre-compile any production code will remove all compiled code including error line info and so is not recommended except for stable production code where line numbers are not needed.", 
            "title": "How do I minimise the footprint of an application on the file system"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-do-i-minimise-the-footprint-of-running-application", 
            "text": "The Lua Garbage collector is very aggressive at scanning and recovering dead resources.  It uses an incremental mark-and-sweep strategy which means that any data which is not ultimately referenced back to the Globals table, the Lua registry or in-scope local variables in the current Lua code will be collected.  Setting any variable to  nil  dereferences the previous context of that variable.  (Note that reference-based variables such as tables, strings and functions can have multiple variables referencing the same object, but once the last reference has been set to  nil , the collector will recover the storage.  Unlike other compile-on-load languages such as PHP, Lua compiled code is treated the same way as any other variable type when it comes to garbage collection and can be collected when fully dereferenced, so that the code-space can be reused.  The default garbage collection mode is very aggressive and results in a GC sweep after every allocation.  See  node.egc.setmode()  for how to turn this down.  node.egc.setmode(node.egc.ON_MEM_LIMIT, 4096)  is a good compromise of performance and having enough free headboard.  Lua execution is intrinsically divided into separate event tasks with each bound to a Lua callback.  This, when coupled with the strong dispose on dereference feature, means that it is very easy to structure your application using an classic technique which dates back to the 1950s known as Overlays.  Various approaches can be use to implement this.  One is described by DP Whittaker in his  Massive memory optimization: flash functions  topic.  Another is to use  volatile modules .  There are standard Lua templates for creating modules, but the  require()  library function creates a reference for the loaded module in the  package.loaded  table, and this reference prevents the module from being garbage collected.  To make a module volatile, you should remove this reference to the loaded module by setting its corresponding entry in  package.loaded  to  nil .  You can't do this in the outermost level of the module (since the reference is only created once execution has returned from the module code), but you can do it in any module function, and typically an initialisation function for the module, as in the following example:   local s=net.createServer(net.TCP) \ns:listen(80,function(c) require( connector ).init(c) end)    connector.lua  would be a standard module pattern except that the  M.init()  routine must include the lines   local M, module = {}, ...\n...\nfunction M.init(csocket)\n  package.loaded[module]=nil\n  ...\nend\n--\nreturn M    This approach ensures that the module can be fully dereferenced on completion.  OK, in this case, this also means that the module has to be reloaded on each TCP connection to port 80; however, loading a compiled module from SPIFFS only takes a few mSec, so surely this is an acceptable overhead if it enables you to break down your application into RAM-sized chunks.  Note that  require()  will automatically search for  connector.lc  followed by  connector.lua , so the code will work for both source and compiled variants.   Whilst the general practice is for a module to return a table, [PiL 15.1] suggests that it is sometimes appropriate to return a single function instead as this avoids the memory overhead of an additional table. This pattern would look as follows:   --\nlocal s=net.createServer(net.TCP) \ns:listen(80,function(c) require( connector )(c) end)   local module = _  -- this is a situation where using an upvalue is essential!\nreturn function (csocket)\n  package.loaded[module]=nil\n  module = nil\n  ...\nend   Also note that you should  not  normally code this up listener call as the following because the RAM now has to accommodate both the module which creates the server  and  the connector logic.   ...\nlocal s=net.createServer(net.TCP)\nlocal connector = require( connector ) -- don't do this unless you've got the RAM available! \ns:listen(80,connector)", 
            "title": "How do I minimise the footprint of running application?"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-do-i-reduce-the-size-of-my-compiled-code", 
            "text": "Note that there are two methods of saving compiled Lua to SPIFFS:\n  - The first is to use  node.compile()  on the  .lua  source file, which generates the equivalent bytecode  .lc  file. This approach strips out all the debug line and variable information.\n  - The second is to use  loadfile()  to load the source file into memory, followed by  string.dump()  to convert it in-memory to a serialised load format which can then be written back to a  .lc  file.  The amount of debug saved will depend on the  node.stripdebug()  settings.  The memory footprint of the bytecode created by method (2) is the same as when executing source files directly, but the footprint of bytecode created by method (1) is typically 10% smaller than a dump with the stripdebug level of 2 or 60% smaller than a dump with a  stripdebug level of 0, because the debug information is almost as large as the code itself.  In general consider method (1) if you have stable production code that you want to run in as low a RAM footprint as possible.  Yes, method (2) can be used if you are still debugging, but you will probably be changing this code quite frequently, so it is easier to stick with  .lua  files for code that you are still developing.  Note that if you use  require(\"XXX\")  to load your code then this will automatically search for  XXX.lc  then  XXX.lua  so you don't need to include the conditional logic to load the bytecode version if it exists, falling back to the source version otherwise.", 
            "title": "How do I reduce the size of my compiled code?"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-do-i-get-a-feel-for-how-much-memory-my-functions-use", 
            "text": "You should get an overall understanding of the VM model if you want to make good use of the limited resources available to Lua applications.  An essential reference here is  A No Frills Introduction to Lua 5.1 VM Instructions  .  This explain how the code generator works, how much memory overhead is involved with each table, function, string etc..  You can't easily get a bytecode listing of your ESP8266 code; however there are two broad options for doing this:  Generate a bytecode listing on your development PC . The Lua 5.1 code generator is basically the same on the PC and on the ESP8266, so whilst it isn't identical, using the standard Lua batch compiler  luac  against your source on your PC with the  -l -s  option will give you a good idea of what your code will generate.  The main difference between these two variants is the size_t for ESP8266 is 4 bytes rather than the 8 bytes size_t found on modern 64bit development PCs; and the eLua variants generate different access references for ROM data types.  If you want to see what the  string.dump()  version generates then drop the  -s  option to retain the debug information.  You can also build  luac.cross  with this firmware and this generate lc code for the target ESP architecture.  Upload your  .lc  files to the PC and disassemble them there . There are a number of Lua code disassemblers which can list off the compiled code that your application modules will generate,  if  you have a script to upload files from your ESP8266 to your development PC.  I use  ChunkSpy   which can be downloaded  here  , but you will need to apply the following patch so that ChunkSpy understands eLua data types:    --- a/ChunkSpy-0.9.8/5.1/ChunkSpy.lua   2015-05-04 12:39:01.267975498 +0100\n +++ b/ChunkSpy-0.9.8/5.1/ChunkSpy.lua   2015-05-04 12:35:59.623983095 +0100\n @@ -2193,6 +2193,9 @@\n            config.AUTO_DETECT = true\n          elseif a ==  --brief  then\n            config.DISPLAY_BRIEF = true\n +        elseif a ==  --elua  then\n +          config.LUA_TNUMBER = 5\n +          config.LUA_TSTRING = 6\n          elseif a ==  --interact  then\n            perform = ChunkSpy_Interact   Your other great friend is to use  node.heap()  regularly through your code.  Use these tools and play with coding approaches to see how many instructions each typical line of code takes in your coding style.  The Lua Wiki gives some general optimisation tips, but in general just remember that these focus on optimising for execution speed and you will be interested mainly in optimising for code and variable space as these are what consumes precious RAM.", 
            "title": "How do I get a feel for how much memory my functions use?"
        }, 
        {
            "location": "/en/lua-developer-faq/#what-is-the-cost-of-using-functions", 
            "text": "Functions have fixed overheads, so in general the more that you group your application code into larger functions, then the less RAM used will be used overall.  The main caveat here is that if you are starting to do \"copy and paste\" coding across functions then you are wasting resources.  So of course you should still use functions to structure your code and encapsulate common repeated processing, but just bear in mind that each function definition has a relatively high overhead for its header record and stack frame.   So try to avoid overusing functions. If there are less than a dozen or so lines in the function then you should consider putting this code inline if it makes sense to do so.", 
            "title": "What is the cost of using functions?"
        }, 
        {
            "location": "/en/lua-developer-faq/#what-other-resources-are-available", 
            "text": "Install lua and luac on your development PC.  This is freely available for Windows, Mac and Linux distributions, but we strongly suggest that you use Lua 5.1 to maintain source compatibility with ESP8266 code.  This will allow you not only to unit test some modules on your PC in a rich development environment, but you can also use  luac  to generate a bytecode listing of your code and to validate new code syntactically before downloading to the ESP8266.  This will also allow you to develop server-side applications and embedded applications in a common language.", 
            "title": "What other resources are available?"
        }, 
        {
            "location": "/en/lua-developer-faq/#firmware-and-lua-app-development", 
            "text": "", 
            "title": "Firmware and Lua app development"
        }, 
        {
            "location": "/en/lua-developer-faq/#how-to-reduce-the-size-of-the-firmware", 
            "text": "We recommend that you use a tailored firmware build; one which only includes the modules that you plan to use in developing any Lua application. Once you have the ability to make and flash custom builds, the you also have the option of moving time sensitive or logic intensive code into your own custom module. Doing this can save a large amount of RAM as C code can be run directly from Flash memory. See  Building the firmware  for more details and options.", 
            "title": "How to reduce the size of the firmware?"
        }, 
        {
            "location": "/en/extn-developer-faq/", 
            "text": "Extension Developer FAQ\n\n\nFirmware build options\n\n\nBuilding the firmware \u2192 Build Options\n lists a few of the common parameters to customize your firmware \nat build time\n.\n\n\nHow does the non-OS SDK structure execution\n\n\nDetails of the execution model for the \nnon-OS SDK\n is not well documented by \nEspressif. This section summarises the project's understanding of how this execution\nmodel works based on the Espressif-supplied examples and SDK documentation, plus\nvarious posts on the Espressif BBS and other forums, and an examination of the\nBootROM code.\n\n\nThe ESP8266 boot ROM contains a set of primitive tasking and dispatch functions\nwhich are also used by the SDK. In this model, execution units are either:\n\n\n\n\n\n\nINTERRUPT SERVICE ROUTINES (ISRs)\n which are declared and controlled\n    through the \nets_isr_attach()\n and other \nets_isr_*\n and \nets_intr_*\n\n    functions. ISRs can be defined on a range of priorities, where a higher\n    priority ISR is able to interrupt a lower priority one. ISRs are time\n    critical and should complete in no more than 50 \u00b5Sec.\n\n\nISR code and data constants should be run out of RAM or ROM, for two reasons:\nif an ISR interrupts a flash I/O operation (which must disable the Flash \ninstruction cache) and a cache miss occurs, then the ISR will trigger a\nfatal exception; secondly, the\nexecution time for Flash memory (that is located in the \nirom0\n load section)\nis indeterminate: whilst cache-hits can run at full memory bandwidth, any\ncache-misses require the code to be read from Flash; and even though\nH/W-based, this is at roughly 26x slower than memory bandwidth (for DIO\nflash); this will cause ISR execution to fall outside the require time\nguidelines. (Note that any time critical code within normal execution and that\nis bracketed by interrupt lock / unlock guards should also follow this 50\n\u00b5Sec guideline.)\n\n\n\n\n\n\nTASKS\n. A task is a normal execution unit running at a non-interrupt priority.\n    Tasks can be executed from Flash memory. An executing task can be interrupted\n    by one or more ISRs being delivered, but it won't be preempted by another\n    queued task. The Espressif guideline is that no individual task should run for\n    more than 15 mSec, before returning control to the SDK.\n\n\nThe ROM will queue up to 32 pending tasks at priorities 0..31 and will\nexecute the highest priority queued task next (or wait on interrupt if none\nis runnable). The SDK tasking system is layered on this ROM dispatcher and\nit reserves 29 of these task priorities for its own use, including the\nimplementation of the various SDK timer, WiFi and other callback mechanisms\nsuch as the software WDT.\n\n\nThree of these task priorities are allocated for and exposed directly at an\napplication level. The application can declare a single task handler for each\nlevel, and associate a task queue with the level. Tasks can be posted to this\nqueue. (The post will fail is the queue is full). Tasks are then delivered\nFIFO within task priority.\n\n\nHow the three user task priorities USER0 .. USER2 are positioned relative to\nthe SDK task priorities is undocumented, but some SDK tasks definitely run at\na lower priority than USER0. As a result if you always have a USER task queued\nfor execution, then you can starve SDK housekeeping tasks and you will start\nto get WiFi and other failures. Espressif therefore recommends that you don't\nstay computable for more than 500 mSec to avoid such timeouts.\n\n\n\n\n\n\nNote that the 50\u00b5S, 15mSec and 500mSec limits are guidelines\nand not hard constraints -- that is if you break them (slightly) then your code\nmay (usually) work, but you can get very difficult to diagnose and intermittent\nfailures. Also running ISRs from Flash may work until there is a collision with\nSPIFFS I/O which will then a cause CPU exception.\n\n\nAlso note that the SDK API function \nsystem_os_post()\n, and the \ntask_post_*()\n\nmacros which generate this can be safely called from an ISR.\n\n\nThe Lua runtime is NOT reentrant, and hence any code which calls any Lua API\nmust run within a task context. Any such task is what we call a \nLua-Land Task\n\n(or \nLLT\n). \nISRs must not access the Lua API or Lua resources.\n LLTs can be\nexecuted as SDK API callbacks or OS tasks. They can also, of course, call the\nLua execution system to execute Lua code (e.g. \nluaL_dofile()\n and related\ncalls).\n\n\nAlso since the application has no control over the relative time ordering of\ntasks and SDK API callbacks, LLTs can't make any assumptions about whether a\ntask and any posted successors will run consecutively.\n\n\nThis API is designed to complement the Lua library model, so that a library can\ndeclare one or more task handlers and that both ISPs and LLTs can then post a\nmessage for delivery to a task handler. Each task handler has a unique message\nassociated with it, and may bind a single uint32 parameter. How this parameter\nis interpreted is left to the task poster and task handler to coordinate.\n\n\nThe interface is exposed through \n#include \"task/task.h\"\n and involves two API\ncalls. Any task handlers are declared, typically in the module_init function by\nassigning \ntask_get_id(some_task_callback)\n to a (typically globally) accessible\nhandle variable, say \nXXX_callback_handle\n. This can then be used in an ISR or\nnormal LLT to execute a \ntask_post_YYY(XXX_callback_handle,param)\n where YYY is\none of \nlow\n, \nmedium\n, \nhigh\n. The callback will then be executed when the SDK\ndelivers the task.\n\n\nNote\n: \ntask_post_YYY\n can fail with a false return if the task Q is full.", 
            "title": "Extension Developer FAQ"
        }, 
        {
            "location": "/en/extn-developer-faq/#extension-developer-faq", 
            "text": "", 
            "title": "Extension Developer FAQ"
        }, 
        {
            "location": "/en/extn-developer-faq/#firmware-build-options", 
            "text": "Building the firmware \u2192 Build Options  lists a few of the common parameters to customize your firmware  at build time .", 
            "title": "Firmware build options"
        }, 
        {
            "location": "/en/extn-developer-faq/#how-does-the-non-os-sdk-structure-execution", 
            "text": "Details of the execution model for the  non-OS SDK  is not well documented by \nEspressif. This section summarises the project's understanding of how this execution\nmodel works based on the Espressif-supplied examples and SDK documentation, plus\nvarious posts on the Espressif BBS and other forums, and an examination of the\nBootROM code.  The ESP8266 boot ROM contains a set of primitive tasking and dispatch functions\nwhich are also used by the SDK. In this model, execution units are either:    INTERRUPT SERVICE ROUTINES (ISRs)  which are declared and controlled\n    through the  ets_isr_attach()  and other  ets_isr_*  and  ets_intr_* \n    functions. ISRs can be defined on a range of priorities, where a higher\n    priority ISR is able to interrupt a lower priority one. ISRs are time\n    critical and should complete in no more than 50 \u00b5Sec.  ISR code and data constants should be run out of RAM or ROM, for two reasons:\nif an ISR interrupts a flash I/O operation (which must disable the Flash \ninstruction cache) and a cache miss occurs, then the ISR will trigger a\nfatal exception; secondly, the\nexecution time for Flash memory (that is located in the  irom0  load section)\nis indeterminate: whilst cache-hits can run at full memory bandwidth, any\ncache-misses require the code to be read from Flash; and even though\nH/W-based, this is at roughly 26x slower than memory bandwidth (for DIO\nflash); this will cause ISR execution to fall outside the require time\nguidelines. (Note that any time critical code within normal execution and that\nis bracketed by interrupt lock / unlock guards should also follow this 50\n\u00b5Sec guideline.)    TASKS . A task is a normal execution unit running at a non-interrupt priority.\n    Tasks can be executed from Flash memory. An executing task can be interrupted\n    by one or more ISRs being delivered, but it won't be preempted by another\n    queued task. The Espressif guideline is that no individual task should run for\n    more than 15 mSec, before returning control to the SDK.  The ROM will queue up to 32 pending tasks at priorities 0..31 and will\nexecute the highest priority queued task next (or wait on interrupt if none\nis runnable). The SDK tasking system is layered on this ROM dispatcher and\nit reserves 29 of these task priorities for its own use, including the\nimplementation of the various SDK timer, WiFi and other callback mechanisms\nsuch as the software WDT.  Three of these task priorities are allocated for and exposed directly at an\napplication level. The application can declare a single task handler for each\nlevel, and associate a task queue with the level. Tasks can be posted to this\nqueue. (The post will fail is the queue is full). Tasks are then delivered\nFIFO within task priority.  How the three user task priorities USER0 .. USER2 are positioned relative to\nthe SDK task priorities is undocumented, but some SDK tasks definitely run at\na lower priority than USER0. As a result if you always have a USER task queued\nfor execution, then you can starve SDK housekeeping tasks and you will start\nto get WiFi and other failures. Espressif therefore recommends that you don't\nstay computable for more than 500 mSec to avoid such timeouts.    Note that the 50\u00b5S, 15mSec and 500mSec limits are guidelines\nand not hard constraints -- that is if you break them (slightly) then your code\nmay (usually) work, but you can get very difficult to diagnose and intermittent\nfailures. Also running ISRs from Flash may work until there is a collision with\nSPIFFS I/O which will then a cause CPU exception.  Also note that the SDK API function  system_os_post() , and the  task_post_*() \nmacros which generate this can be safely called from an ISR.  The Lua runtime is NOT reentrant, and hence any code which calls any Lua API\nmust run within a task context. Any such task is what we call a  Lua-Land Task \n(or  LLT ).  ISRs must not access the Lua API or Lua resources.  LLTs can be\nexecuted as SDK API callbacks or OS tasks. They can also, of course, call the\nLua execution system to execute Lua code (e.g.  luaL_dofile()  and related\ncalls).  Also since the application has no control over the relative time ordering of\ntasks and SDK API callbacks, LLTs can't make any assumptions about whether a\ntask and any posted successors will run consecutively.  This API is designed to complement the Lua library model, so that a library can\ndeclare one or more task handlers and that both ISPs and LLTs can then post a\nmessage for delivery to a task handler. Each task handler has a unique message\nassociated with it, and may bind a single uint32 parameter. How this parameter\nis interpreted is left to the task poster and task handler to coordinate.  The interface is exposed through  #include \"task/task.h\"  and involves two API\ncalls. Any task handlers are declared, typically in the module_init function by\nassigning  task_get_id(some_task_callback)  to a (typically globally) accessible\nhandle variable, say  XXX_callback_handle . This can then be used in an ISR or\nnormal LLT to execute a  task_post_YYY(XXX_callback_handle,param)  where YYY is\none of  low ,  medium ,  high . The callback will then be executed when the SDK\ndelivers the task.  Note :  task_post_YYY  can fail with a false return if the task Q is full.", 
            "title": "How does the non-OS SDK structure execution"
        }, 
        {
            "location": "/en/hardware-faq/", 
            "text": "Hardware FAQ\n\n\nThis content is now maintained at \nhttp://www.esp8266.com/wiki/doku.php?id=nodemcu-unofficial-faq\n.", 
            "title": "Hardware FAQ"
        }, 
        {
            "location": "/en/hardware-faq/#hardware-faq", 
            "text": "This content is now maintained at  http://www.esp8266.com/wiki/doku.php?id=nodemcu-unofficial-faq .", 
            "title": "Hardware FAQ"
        }, 
        {
            "location": "/en/support/", 
            "text": "The \nissues list on GitHub\n is \nnot\n the right place to ask for help. Use it to report bugs and to place feature requests. Questions like \"how do I ...\" or \"I can't get this to work ...\" should be directed to StackOverflow or esp8266.com.\n\n\nWhich ever site you use you need to make sure the description of the problem is to the point. It should be accompanied by a stripped down version of your Lua source code i.e. create a Minimal, Complete, and Verifiable Example (MCVE). A good resource is \nhttp://stackoverflow.com/help/how-to-ask\n\n\nStack Overflow\n\n\nStack Overflow is the perfect place to ask coding questions. Use one or several of the following tags: \nesp8266\n, \nnodemcu\n or \nLua\n.\n\n\nesp8266.com Forums\n\n\nesp8266.com has a few \nNodeMCU specific forums\n where a number of our active community members tend to hang out.", 
            "title": "Support"
        }, 
        {
            "location": "/en/support/#stack-overflow", 
            "text": "Stack Overflow is the perfect place to ask coding questions. Use one or several of the following tags:  esp8266 ,  nodemcu  or  Lua .", 
            "title": "Stack Overflow"
        }, 
        {
            "location": "/en/support/#esp8266com-forums", 
            "text": "esp8266.com has a few  NodeMCU specific forums  where a number of our active community members tend to hang out.", 
            "title": "esp8266.com Forums"
        }, 
        {
            "location": "/en/modules/adc/", 
            "text": "ADC Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-24\n\n\nZeroday\n\n\njmattsson\n\n\nadc.c\n\n\n\n\n\n\n\n\nThe ADC module provides access to the in-built ADC.\n\n\nOn the ESP8266 there is only a single-channel, which is multiplexed with the battery voltage. Depending on the setting in the \"esp init data\" (byte 107) one can either use the ADC to read an external voltage, or to read the system voltage (vdd33), but not both.\n\n\nWhich mode to use the ADC in can be configured via the \nadc.force_init_mode()\n function. Note that after switching from one to the other a system restart (e.g. power cycle, reset button, \nnode.restart()\n) is required before the change takes effect.\n\n\nadc.force_init_mode()\n\n\nChecks and if necessary reconfigures the ADC mode setting in the ESP init data block.\n\n\nSyntax\n\n\nadc.force_init_mode(mode_value)\n\n\nParameters\n\n\nmode_value\n One of \nadc.INIT_ADC\n or \nadc.INIT_VDD33\n.\n\n\nReturns\n\n\nTrue if the function had to change the mode, false if the mode was already configured. On a true return the ESP needs to be restarted for the change to take effect.\n\n\nExample\n\n\n-- in you init.lua:\nif adc.force_init_mode(adc.INIT_VDD33)\nthen\n  node.restart()\n  return -- don't bother continuing, the restart is scheduled\nend\n\nprint(\nSystem voltage (mV):\n, adc.readvdd33(0))\n\n\n\n\nSee also\n\n\nnode.restart()\n\n\nadc.read()\n\n\nSamples the ADC.\n\n\nSyntax\n\n\nadc.read(channel)\n\n\nParameters\n\n\nchannel\n always 0 on the ESP8266\n\n\nReturns\n\n\nthe sampled value (number)\n\n\nIf the ESP8266 has been configured to use the ADC for reading the system voltage, this function will always return 65535. This is a hardware and/or SDK limitation.\n\n\nExample\n\n\nval = adc.read(0)\n\n\n\n\nadc.readvdd33()\n\n\nReads the system voltage.\n\n\nSyntax\n\n\nadc.readvdd33()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nsystem voltage in millivolts (number)\n\n\nIf the ESP8266 has been configured to use the ADC for sampling the external pin, this function will always return 65535. This is a hardware and/or SDK limitation.", 
            "title": "adc"
        }, 
        {
            "location": "/en/modules/adc/#adc-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-24  Zeroday  jmattsson  adc.c     The ADC module provides access to the in-built ADC.  On the ESP8266 there is only a single-channel, which is multiplexed with the battery voltage. Depending on the setting in the \"esp init data\" (byte 107) one can either use the ADC to read an external voltage, or to read the system voltage (vdd33), but not both.  Which mode to use the ADC in can be configured via the  adc.force_init_mode()  function. Note that after switching from one to the other a system restart (e.g. power cycle, reset button,  node.restart() ) is required before the change takes effect.", 
            "title": "ADC Module"
        }, 
        {
            "location": "/en/modules/adc/#adcforce_init_mode", 
            "text": "Checks and if necessary reconfigures the ADC mode setting in the ESP init data block.", 
            "title": "adc.force_init_mode()"
        }, 
        {
            "location": "/en/modules/adc/#syntax", 
            "text": "adc.force_init_mode(mode_value)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/adc/#parameters", 
            "text": "mode_value  One of  adc.INIT_ADC  or  adc.INIT_VDD33 .", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/adc/#returns", 
            "text": "True if the function had to change the mode, false if the mode was already configured. On a true return the ESP needs to be restarted for the change to take effect.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/adc/#example", 
            "text": "-- in you init.lua:\nif adc.force_init_mode(adc.INIT_VDD33)\nthen\n  node.restart()\n  return -- don't bother continuing, the restart is scheduled\nend\n\nprint( System voltage (mV): , adc.readvdd33(0))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/adc/#see-also", 
            "text": "node.restart()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/adc/#adcread", 
            "text": "Samples the ADC.", 
            "title": "adc.read()"
        }, 
        {
            "location": "/en/modules/adc/#syntax_1", 
            "text": "adc.read(channel)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/adc/#parameters_1", 
            "text": "channel  always 0 on the ESP8266", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/adc/#returns_1", 
            "text": "the sampled value (number)  If the ESP8266 has been configured to use the ADC for reading the system voltage, this function will always return 65535. This is a hardware and/or SDK limitation.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/adc/#example_1", 
            "text": "val = adc.read(0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/adc/#adcreadvdd33", 
            "text": "Reads the system voltage.", 
            "title": "adc.readvdd33()"
        }, 
        {
            "location": "/en/modules/adc/#syntax_2", 
            "text": "adc.readvdd33()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/adc/#parameters_2", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/adc/#returns_2", 
            "text": "system voltage in millivolts (number)  If the ESP8266 has been configured to use the ADC for sampling the external pin, this function will always return 65535. This is a hardware and/or SDK limitation.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ads1115/", 
            "text": "ADS1115 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2017-04-24\n\n\nfetchbot\n\n\nfetchbot\n\n\nads1115.c\n\n\n\n\n\n\n\n\nThis module provides access to the ADS1115 16-Bit analog-to-digital converter.\n\n\n\n\nCaution\n\n\nThe \nABSOLUTE MAXIMUM RATINGS\n for all analog inputs are \n\u20130.3V to VDD+0.3V\n referred to GND.\n\n\n\n\nads1115.read()\n\n\nGets the result stored in the register of a previously issued conversion, e.g. in continuous mode or with a conversion ready interrupt.\n\n\nSyntax\n\n\nvolt, volt_dec, adc = ads1115.read()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nvolt\n voltage in mV (see note below)\n\n\nvolt_dec\n voltage decimal (see note below)\n\n\nadc\n raw adc value\n\n\n\n\n\n\nNote\n\n\nIf using float firmware then \nvolt\n is a floating point number. On an integer firmware, the final value has to be concatenated from \nvolt\n and \nvolt_dec\n.\n\n\n\n\nExample\n\n\nlocal id, alert_pin, sda, scl = 0, 7, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW)\nads1115.setup(ads1115.ADDR_GND)\n\n-- continuous mode\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.CONTINUOUS)\n-- read adc result with read()\nvolt, volt_dec, adc = ads1115.read()\nprint(volt, volt_dec, adc)\n\n-- comparator\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.CONTINUOUS, ads1115.COMP_1CONV, 1000, 2000)\nlocal function comparator(level, when)\n    -- read adc result with read() when threshold reached\n    volt, volt_dec, adc = ads1115.read()\n    print(volt, volt_dec, adc)\nend\ngpio.mode(alert_pin, gpio.INT)\ngpio.trig(alert_pin, \nboth\n, comparator)\n-- read adc result with read()\nvolt, volt_dec, adc = ads1115.read()\nprint(volt, volt_dec, adc)\n\n\n\n\nads1115.setting()\n\n\nConfiguration settings for the ADC.\n\n\nSyntax\n\n\nads1115.setting(GAIN, SAMPLES, CHANNEL, MODE[, CONVERSION_RDY][, COMPARATOR, THRESHOLD_LOW, THRESHOLD_HI])\n\n\nParameters\n\n\n\n\nGAIN\n Programmable gain amplifier\n\n\nads1115.GAIN_6_144V\n 2/3x Gain\n\n\nads1115.GAIN_4_096V\n 1x Gain\n\n\nads1115.GAIN_2_048V\n 2x Gain\n\n\nads1115.GAIN_1_024V\n 4x Gain\n\n\nads1115.GAIN_0_512V\n 8x Gain\n\n\nads1115.GAIN_0_256V\n 16x Gain\n\n\n\n\n\n\nSAMPLES\n Data rate in samples per second\n\n\nads1115.DR_8SPS\n\n\nads1115.DR_16SPS\n\n\nads1115.DR_32SPS\n\n\nads1115.DR_64SPS\n\n\nads1115.DR_128SPS\n\n\nads1115.DR_250SPS\n\n\nads1115.DR_475SPS\n\n\nads1115.DR_860SPS\n\n\n\n\n\n\nCHANNEL\n Input multiplexer for single-ended or differential measurement\n\n\nads1115.SINGLE_0\n channel 0 to GND\n\n\nads1115.SINGLE_1\n channel 1 to GND\n\n\nads1115.SINGLE_2\n channel 2 to GND\n\n\nads1115.SINGLE_3\n channel 3 to GND\n\n\nads1115.DIFF_0_1\n channel 0 to 1\n\n\nads1115.DIFF_0_3\n channel 0 to 3\n\n\nads1115.DIFF_1_3\n channel 1 to 3\n\n\nads1115.DIFF_2_3\n channel 2 to 3\n\n\n\n\n\n\nMODE\n Device operating mode\n\n\nads1115.SINGLE_SHOT\n single-shot mode\n\n\nads1115.CONTINUOUS\n continuous mode\n\n\n\n\n\n\nCONVERSION_RDY\n Number of conversions after conversion ready asserts (optional)\n\n\nads1115.CONV_RDY_1\n\n\nads1115.CONV_RDY_2\n\n\nads1115.CONV_RDY_4\n\n\n\n\n\n\nCOMPARATOR\n Number of conversions after comparator asserts (optional)\n\n\nads1115.COMP_1CONV\n\n\nads1115.COMP_2CONV\n\n\nads1115.COMP_4CONV\n\n\n\n\n\n\nTHRESHOLD_LOW\n\n\n0\n - \n+ GAIN_MAX\n in mV for single-ended inputs\n\n\n- GAIN_MAX\n - \n+ GAIN_MAX\n in mV for differential inputs\n\n\n\n\n\n\nTHRESHOLD_HI\n\n\n0\n - \n+ GAIN_MAX\n in mV for single-ended inputs\n\n\n- GAIN_MAX\n - \n+ GAIN_MAX\n in mV for differential inputs\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nlocal id, sda, scl = 0, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW)\nads1115.setup(ads1115.ADDR_GND)\n\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.SINGLE_SHOT)\n\n\n\n\nads1115.setup()\n\n\nInitializes the device on the defined I\u00b2C device address.\n\n\nSyntax\n\n\nads1115.setup(ADDRESS)\n\n\nParameters\n\n\n\n\nADDRESS\n\n\nads1115.ADDR_GND\n\n\nads1115.ADDR_VDD\n\n\nads1115.ADDR_SDA\n\n\nads1115.ADDR_SCL\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nlocal id, sda, scl = 0, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW)\n\nads1115.setup(ads1115.ADDR_GND)\n\n\n\n\nads1115.startread()\n\n\nStarts the ADC reading for single-shot mode and after the conversion is done it will invoke an optional callback function in which the ADC conversion result can be obtained.\n\n\nSyntax\n\n\nads1115.startread([CALLBACK])\n\n\nParameters\n\n\n\n\nCALLBACK\n callback function which will be invoked after the adc conversion is done\n\n\nfunction(volt, volt_dec, adc) end\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnil\n\n\n\n\nExample\n\n\nlocal id, alert_pin, sda, scl = 0, 7, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW)\nads1115.setup(ads1115.ADDR_GND)\n\n-- single shot\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.SINGLE_SHOT)\n-- start adc conversion and get result in callback after conversion is ready\nads1115.startread(function(volt, volt_dec, adc) print(volt, volt_dec, adc) end)\n\n-- conversion ready\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.SINGLE_SHOT, ads1115.CONV_RDY_1)\nlocal function conversion_ready(level, when)\n    volt, volt_dec, adc = ads1115.read()\n    print(volt, volt_dec, adc)\nend\ngpio.mode(alert_pin, gpio.INT)\ngpio.trig(alert_pin, \ndown\n, conversion_ready)\n-- start conversion and get result with read() after conversion ready pin asserts\nads1115.startread()", 
            "title": "ads1115"
        }, 
        {
            "location": "/en/modules/ads1115/#ads1115-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2017-04-24  fetchbot  fetchbot  ads1115.c     This module provides access to the ADS1115 16-Bit analog-to-digital converter.   Caution  The  ABSOLUTE MAXIMUM RATINGS  for all analog inputs are  \u20130.3V to VDD+0.3V  referred to GND.", 
            "title": "ADS1115 Module"
        }, 
        {
            "location": "/en/modules/ads1115/#ads1115read", 
            "text": "Gets the result stored in the register of a previously issued conversion, e.g. in continuous mode or with a conversion ready interrupt.", 
            "title": "ads1115.read()"
        }, 
        {
            "location": "/en/modules/ads1115/#syntax", 
            "text": "volt, volt_dec, adc = ads1115.read()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ads1115/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ads1115/#returns", 
            "text": "volt  voltage in mV (see note below)  volt_dec  voltage decimal (see note below)  adc  raw adc value    Note  If using float firmware then  volt  is a floating point number. On an integer firmware, the final value has to be concatenated from  volt  and  volt_dec .", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ads1115/#example", 
            "text": "local id, alert_pin, sda, scl = 0, 7, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW)\nads1115.setup(ads1115.ADDR_GND)\n\n-- continuous mode\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.CONTINUOUS)\n-- read adc result with read()\nvolt, volt_dec, adc = ads1115.read()\nprint(volt, volt_dec, adc)\n\n-- comparator\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.CONTINUOUS, ads1115.COMP_1CONV, 1000, 2000)\nlocal function comparator(level, when)\n    -- read adc result with read() when threshold reached\n    volt, volt_dec, adc = ads1115.read()\n    print(volt, volt_dec, adc)\nend\ngpio.mode(alert_pin, gpio.INT)\ngpio.trig(alert_pin,  both , comparator)\n-- read adc result with read()\nvolt, volt_dec, adc = ads1115.read()\nprint(volt, volt_dec, adc)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ads1115/#ads1115setting", 
            "text": "Configuration settings for the ADC.", 
            "title": "ads1115.setting()"
        }, 
        {
            "location": "/en/modules/ads1115/#syntax_1", 
            "text": "ads1115.setting(GAIN, SAMPLES, CHANNEL, MODE[, CONVERSION_RDY][, COMPARATOR, THRESHOLD_LOW, THRESHOLD_HI])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ads1115/#parameters_1", 
            "text": "GAIN  Programmable gain amplifier  ads1115.GAIN_6_144V  2/3x Gain  ads1115.GAIN_4_096V  1x Gain  ads1115.GAIN_2_048V  2x Gain  ads1115.GAIN_1_024V  4x Gain  ads1115.GAIN_0_512V  8x Gain  ads1115.GAIN_0_256V  16x Gain    SAMPLES  Data rate in samples per second  ads1115.DR_8SPS  ads1115.DR_16SPS  ads1115.DR_32SPS  ads1115.DR_64SPS  ads1115.DR_128SPS  ads1115.DR_250SPS  ads1115.DR_475SPS  ads1115.DR_860SPS    CHANNEL  Input multiplexer for single-ended or differential measurement  ads1115.SINGLE_0  channel 0 to GND  ads1115.SINGLE_1  channel 1 to GND  ads1115.SINGLE_2  channel 2 to GND  ads1115.SINGLE_3  channel 3 to GND  ads1115.DIFF_0_1  channel 0 to 1  ads1115.DIFF_0_3  channel 0 to 3  ads1115.DIFF_1_3  channel 1 to 3  ads1115.DIFF_2_3  channel 2 to 3    MODE  Device operating mode  ads1115.SINGLE_SHOT  single-shot mode  ads1115.CONTINUOUS  continuous mode    CONVERSION_RDY  Number of conversions after conversion ready asserts (optional)  ads1115.CONV_RDY_1  ads1115.CONV_RDY_2  ads1115.CONV_RDY_4    COMPARATOR  Number of conversions after comparator asserts (optional)  ads1115.COMP_1CONV  ads1115.COMP_2CONV  ads1115.COMP_4CONV    THRESHOLD_LOW  0  -  + GAIN_MAX  in mV for single-ended inputs  - GAIN_MAX  -  + GAIN_MAX  in mV for differential inputs    THRESHOLD_HI  0  -  + GAIN_MAX  in mV for single-ended inputs  - GAIN_MAX  -  + GAIN_MAX  in mV for differential inputs", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ads1115/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ads1115/#example_1", 
            "text": "local id, sda, scl = 0, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW)\nads1115.setup(ads1115.ADDR_GND)\n\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.SINGLE_SHOT)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ads1115/#ads1115setup", 
            "text": "Initializes the device on the defined I\u00b2C device address.", 
            "title": "ads1115.setup()"
        }, 
        {
            "location": "/en/modules/ads1115/#syntax_2", 
            "text": "ads1115.setup(ADDRESS)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ads1115/#parameters_2", 
            "text": "ADDRESS  ads1115.ADDR_GND  ads1115.ADDR_VDD  ads1115.ADDR_SDA  ads1115.ADDR_SCL", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ads1115/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ads1115/#example_2", 
            "text": "local id, sda, scl = 0, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW)\n\nads1115.setup(ads1115.ADDR_GND)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ads1115/#ads1115startread", 
            "text": "Starts the ADC reading for single-shot mode and after the conversion is done it will invoke an optional callback function in which the ADC conversion result can be obtained.", 
            "title": "ads1115.startread()"
        }, 
        {
            "location": "/en/modules/ads1115/#syntax_3", 
            "text": "ads1115.startread([CALLBACK])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ads1115/#parameters_3", 
            "text": "CALLBACK  callback function which will be invoked after the adc conversion is done  function(volt, volt_dec, adc) end", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ads1115/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ads1115/#example_3", 
            "text": "local id, alert_pin, sda, scl = 0, 7, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW)\nads1115.setup(ads1115.ADDR_GND)\n\n-- single shot\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.SINGLE_SHOT)\n-- start adc conversion and get result in callback after conversion is ready\nads1115.startread(function(volt, volt_dec, adc) print(volt, volt_dec, adc) end)\n\n-- conversion ready\nads1115.setting(ads1115.GAIN_6_144V, ads1115.DR_128SPS, ads1115.SINGLE_0, ads1115.SINGLE_SHOT, ads1115.CONV_RDY_1)\nlocal function conversion_ready(level, when)\n    volt, volt_dec, adc = ads1115.read()\n    print(volt, volt_dec, adc)\nend\ngpio.mode(alert_pin, gpio.INT)\ngpio.trig(alert_pin,  down , conversion_ready)\n-- start conversion and get result with read() after conversion ready pin asserts\nads1115.startread()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/adxl345/", 
            "text": "ADXL345 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-04-08\n\n\nJason Schmidlapp\n\n\nJason Schmidlapp\n\n\nadxl345.c\n\n\n\n\n\n\n\n\nThis module provides access to the \nADXL345\n triple axis accelerometer.\n\n\nadxl345.read()\n\n\nSamples the sensor and returns X,Y and Z data from the accelerometer.\n\n\nSyntax\n\n\nadxl345.read()\n\n\nReturns\n\n\nX,Y,Z data (integers)\n\n\nExample\n\n\nlocal sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW)  -- call i2c.setup() only once\nadxl345.setup()\nlocal x,y,z = adxl345.read()\nprint(string.format(\nX = %d, Y = %d, Z = %d\n, x, y, z))\n\n\n\n\nadxl345.init()\n\n\nInitializes the module and sets the pin configuration.\n\n\n\n\nAttention\n\n\nThis function is deprecated and will be removed in upcoming releases. Use \nadxl345.setup()\n instead.\n\n\n\n\nSyntax\n\n\nadxl345.init(sda, scl)\n\n\nParameters\n\n\n\n\nsda\n data pin\n\n\nscl\n clock pin\n\n\n\n\nReturns\n\n\nnil\n\n\nadxl345.setup()\n\n\nInitializes the module.\n\n\nSyntax\n\n\nadxl345.setup()\n\n\nParameters\n\n\nNone\n\n\nReturns\n\n\nnil", 
            "title": "adxl345"
        }, 
        {
            "location": "/en/modules/adxl345/#adxl345-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-04-08  Jason Schmidlapp  Jason Schmidlapp  adxl345.c     This module provides access to the  ADXL345  triple axis accelerometer.", 
            "title": "ADXL345 Module"
        }, 
        {
            "location": "/en/modules/adxl345/#adxl345read", 
            "text": "Samples the sensor and returns X,Y and Z data from the accelerometer.", 
            "title": "adxl345.read()"
        }, 
        {
            "location": "/en/modules/adxl345/#syntax", 
            "text": "adxl345.read()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/adxl345/#returns", 
            "text": "X,Y,Z data (integers)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/adxl345/#example", 
            "text": "local sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW)  -- call i2c.setup() only once\nadxl345.setup()\nlocal x,y,z = adxl345.read()\nprint(string.format( X = %d, Y = %d, Z = %d , x, y, z))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/adxl345/#adxl345init", 
            "text": "Initializes the module and sets the pin configuration.   Attention  This function is deprecated and will be removed in upcoming releases. Use  adxl345.setup()  instead.", 
            "title": "adxl345.init()"
        }, 
        {
            "location": "/en/modules/adxl345/#syntax_1", 
            "text": "adxl345.init(sda, scl)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/adxl345/#parameters", 
            "text": "sda  data pin  scl  clock pin", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/adxl345/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/adxl345/#adxl345setup", 
            "text": "Initializes the module.", 
            "title": "adxl345.setup()"
        }, 
        {
            "location": "/en/modules/adxl345/#syntax_2", 
            "text": "adxl345.setup()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/adxl345/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/adxl345/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/am2320/", 
            "text": "AM2320 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-02-14\n\n\nHenk Vergonet\n\n\nHenk Vergonet\n\n\nam2320.c\n\n\n\n\n\n\n\n\nThis module provides access to the \nAM2320\n humidity and temperature sensor, using the i2c interface.\n\n\nam2320.init()\n\n\nInitializes the module and sets the pin configuration. Returns model, version, serial but is seams these where all zero on my model.\n\n\n\n\nAttention\n\n\nThis function is deprecated and will be removed in upcoming releases. Use \nam2320.setup()\n instead.\n\n\n\n\nSyntax\n\n\nmodel, version, serial = am2320.init(sda, scl)\n\n\nParameters\n\n\n\n\nsda\n data pin\n\n\nscl\n clock pin\n\n\n\n\nReturns\n\n\n\n\nmodel\n  16 bits number of model\n\n\nversion\n  8 bits version number\n\n\nserial\n  32 bits serial number\n\n\n\n\nNote: I have only observed values of 0 for all of these, maybe other sensors return more sensible readings.\n\n\nam2320.read()\n\n\nSamples the sensor and returns the relative humidity in % and temperature in celsius, as an integer multiplied with 10.\n\n\nSyntax\n\n\nam2320.read()\n\n\nReturns\n\n\n\n\nrelative humidity\n percentage multiplied with 10 (integer)\n\n\ntemperature\n in celcius multiplied with 10 (integer)\n\n\n\n\nExample\n\n\nsda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nam2320.setup()\nrh, t = am2320.read()\nprint(string.format(\nRH: %s%%\n, rh / 10))\nprint(string.format(\nTemperature: %s degrees C\n, t / 10))\n\n\n\n\nam2320.setup()\n\n\nInitializes the module. Returns model, version, serial but is seams these where all zero on my model.\n\n\nSyntax\n\n\nmodel, version, serial = am2320.setup()\n\n\nParameters\n\n\nNone\n\n\nReturns\n\n\n\n\nmodel\n  16 bits number of model\n\n\nversion\n  8 bits version number\n\n\nserial\n  32 bits serial number\n\n\n\n\nNote: I have only observed values of 0 for all of these, maybe other sensors return more sensible readings.", 
            "title": "am2320"
        }, 
        {
            "location": "/en/modules/am2320/#am2320-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-02-14  Henk Vergonet  Henk Vergonet  am2320.c     This module provides access to the  AM2320  humidity and temperature sensor, using the i2c interface.", 
            "title": "AM2320 Module"
        }, 
        {
            "location": "/en/modules/am2320/#am2320init", 
            "text": "Initializes the module and sets the pin configuration. Returns model, version, serial but is seams these where all zero on my model.   Attention  This function is deprecated and will be removed in upcoming releases. Use  am2320.setup()  instead.", 
            "title": "am2320.init()"
        }, 
        {
            "location": "/en/modules/am2320/#syntax", 
            "text": "model, version, serial = am2320.init(sda, scl)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/am2320/#parameters", 
            "text": "sda  data pin  scl  clock pin", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/am2320/#returns", 
            "text": "model   16 bits number of model  version   8 bits version number  serial   32 bits serial number   Note: I have only observed values of 0 for all of these, maybe other sensors return more sensible readings.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/am2320/#am2320read", 
            "text": "Samples the sensor and returns the relative humidity in % and temperature in celsius, as an integer multiplied with 10.", 
            "title": "am2320.read()"
        }, 
        {
            "location": "/en/modules/am2320/#syntax_1", 
            "text": "am2320.read()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/am2320/#returns_1", 
            "text": "relative humidity  percentage multiplied with 10 (integer)  temperature  in celcius multiplied with 10 (integer)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/am2320/#example", 
            "text": "sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nam2320.setup()\nrh, t = am2320.read()\nprint(string.format( RH: %s%% , rh / 10))\nprint(string.format( Temperature: %s degrees C , t / 10))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/am2320/#am2320setup", 
            "text": "Initializes the module. Returns model, version, serial but is seams these where all zero on my model.", 
            "title": "am2320.setup()"
        }, 
        {
            "location": "/en/modules/am2320/#syntax_2", 
            "text": "model, version, serial = am2320.setup()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/am2320/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/am2320/#returns_2", 
            "text": "model   16 bits number of model  version   8 bits version number  serial   32 bits serial number   Note: I have only observed values of 0 for all of these, maybe other sensors return more sensible readings.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/apa102/", 
            "text": "APA102 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-01-26\n\n\nRobert Foss\n\n\nRobert Foss\n\n\napa102.c\n\n\n\n\n\n\n\n\nThis module provides Lua access to \nAPA102 RGB LEDs\n which are similar in function to the common \nWS2812\n addressable LEDs.\n\n\n\n\nDotStar LEDs are 5050-sized LEDs with an embedded micro controller inside the LED. You can set the color/brightness of each LED to 24-bit color (8 bits each red green and blue). Each LED acts like a shift register, reading incoming color data on the input pins, and then shifting the previous color data out on the output pin. By sending a long string of data, you can control an infinite number of LEDs, just tack on more or cut off unwanted LEDs at the end.\n\n\n\n\nsource: \nAdafruit\n\n\napa102.write()\n\n\nSend ABGR data in 8 bits to a APA102 chain.\n\n\nSyntax\n\n\napa102.write(data_pin, clock_pin, string)\n\n\nParameters\n\n\n\n\ndata_pin\n any GPIO pin 0, 1, 2, ...\n\n\nclock_pin\n any GPIO pin 0, 1, 2, ...\n\n\nstring\n payload to be sent to one or more APA102 LEDs.\n  It should be composed from a ABGR quadruplet per element.\n\n\nA1\n the first pixel's Intensity channel (0-31)\n\n\nB1\n the first pixel's Blue channel (0-255)\n\n\nG1\n the first pixel's Green channel (0-255)\n\n\nR1\n the first pixel's Red channel (0-255)\n... You can connect a lot of APA102 ...\n\n\nA2\n, \nB2\n, \nG2\n, \nR2\n are the next APA102s Intensity, Blue, Green and Red channel parameters\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nExample 1\n\n\na = 31\nb = 0\ng = 0\nr = 255\nleds_abgr = string.char(a, b, g, r, a, b, g, r) \napa102.write(2, 3, leds_abgr) -- turn two APA102s to red, connected to data_pin 2 and clock_pin 3\n\n\n\n\nExample 2\n\n\n-- set the first 30 leds to red\napa102.write(2, 3, string.char(31, 255, 0, 0):rep(30))", 
            "title": "apa102"
        }, 
        {
            "location": "/en/modules/apa102/#apa102-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-01-26  Robert Foss  Robert Foss  apa102.c     This module provides Lua access to  APA102 RGB LEDs  which are similar in function to the common  WS2812  addressable LEDs.   DotStar LEDs are 5050-sized LEDs with an embedded micro controller inside the LED. You can set the color/brightness of each LED to 24-bit color (8 bits each red green and blue). Each LED acts like a shift register, reading incoming color data on the input pins, and then shifting the previous color data out on the output pin. By sending a long string of data, you can control an infinite number of LEDs, just tack on more or cut off unwanted LEDs at the end.   source:  Adafruit", 
            "title": "APA102 Module"
        }, 
        {
            "location": "/en/modules/apa102/#apa102write", 
            "text": "Send ABGR data in 8 bits to a APA102 chain.", 
            "title": "apa102.write()"
        }, 
        {
            "location": "/en/modules/apa102/#syntax", 
            "text": "apa102.write(data_pin, clock_pin, string)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/apa102/#parameters", 
            "text": "data_pin  any GPIO pin 0, 1, 2, ...  clock_pin  any GPIO pin 0, 1, 2, ...  string  payload to be sent to one or more APA102 LEDs.\n  It should be composed from a ABGR quadruplet per element.  A1  the first pixel's Intensity channel (0-31)  B1  the first pixel's Blue channel (0-255)  G1  the first pixel's Green channel (0-255)  R1  the first pixel's Red channel (0-255)\n... You can connect a lot of APA102 ...  A2 ,  B2 ,  G2 ,  R2  are the next APA102s Intensity, Blue, Green and Red channel parameters", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/apa102/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/apa102/#example-1", 
            "text": "a = 31\nb = 0\ng = 0\nr = 255\nleds_abgr = string.char(a, b, g, r, a, b, g, r) \napa102.write(2, 3, leds_abgr) -- turn two APA102s to red, connected to data_pin 2 and clock_pin 3", 
            "title": "Example 1"
        }, 
        {
            "location": "/en/modules/apa102/#example-2", 
            "text": "-- set the first 30 leds to red\napa102.write(2, 3, string.char(31, 255, 0, 0):rep(30))", 
            "title": "Example 2"
        }, 
        {
            "location": "/en/modules/bit/", 
            "text": "bit Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-24\n\n\nhttps://github.com/LuaDist/bitlib\n, \nZeroday\n\n\nZeroday\n\n\nbit.c\n\n\n\n\n\n\n\n\nBit manipulation support, on 32bit integers.\n\n\nbit.arshift()\n\n\nArithmetic right shift a number equivalent to \nvalue \n shift\n in C.\n\n\nSyntax\n\n\nbit.arshift(value, shift)\n\n\nParameters\n\n\n\n\nvalue\n the value to shift\n\n\nshift\n positions to shift\n\n\n\n\nReturns\n\n\nthe number shifted right (arithmetically)\n\n\nbit.band()\n\n\nBitwise AND, equivalent to \nval1 \n val2 \n ... \n valn\n in C.\n\n\nSyntax\n\n\nbit.band(val1, val2 [, ... valn])\n\n\nParameters\n\n\n\n\nval1\n first AND argument\n\n\nval2\n second AND argument\n\n\n...valn\n ...nth AND argument\n\n\n\n\nReturns\n\n\nthe bitwise AND of all the arguments (number)\n\n\nbit.bit()\n\n\nGenerate a number with a 1 bit (used for mask generation). Equivalent to \n1 \n position\n in C.\n\n\nSyntax\n\n\nbit.bit(position)\n\n\nParameters\n\n\nposition\n position of the bit that will be set to 1\n\n\nReturns\n\n\na number with only one 1 bit at position (the rest are set to 0)\n\n\nbit.bnot()\n\n\nBitwise negation, equivalent to `~value in C.\n\n\nSyntax\n\n\nbit.bnot(value)\n\n\nParameters\n\n\nvalue\n the number to negate\n\n\nReturns\n\n\nthe bitwise negated value of the number\n\n\nbit.bor()\n\n\nBitwise OR, equivalent to \nval1 | val2 | ... | valn\n in C.\n\n\nSyntax\n\n\nbit.bor(val1, val2 [, ... valn])\n\n\nParameters\n\n\n\n\nval1\n first OR argument.\n\n\nval2\n second OR argument.\n\n\n...valn\n ...nth OR argument\n\n\n\n\nReturns\n\n\nthe bitwise OR of all the arguments (number)\n\n\nbit.bxor()\n\n\nBitwise XOR, equivalent to \nval1 ^ val2 ^ ... ^ valn\n in C.\n\n\nSyntax\n\n\nbit.bxor(val1, val2 [, ... valn])\n\n\nParameters\n\n\n\n\nval1\n first XOR argument\n\n\nval2\n second XOR argument\n\n\n...valn\n ...nth XOR argument\n\n\n\n\nReturns\n\n\nthe bitwise XOR of all the arguments (number)\n\n\nbit.clear()\n\n\nClear bits in a number.\n\n\nSyntax\n\n\nbit.clear(value, pos1 [, ... posn])\n\n\nParameters\n\n\n\n\nvalue\n the base number\n\n\npos1\n position of the first bit to clear\n\n\n...posn\n position of thet nth bit to clear\n\n\n\n\nReturns\n\n\nthe number with the bit(s) cleared in the given position(s)\n\n\nbit.isclear()\n\n\nTest if a given bit is cleared.\n\n\nSyntax\n\n\nbit.isclear(value, position)\n\n\nParameters\n\n\n\n\nvalue\n the value to test\n\n\nposition\n bit position to test\n\n\n\n\nReturns\n\n\ntrue if the bit at the given position is 0, false othewise\n\n\nbit.isset()\n\n\nTest if a given bit is set.\n\n\nSyntax\n\n\nbit.isset(value, position)\n\n\nParameters\n\n\n\n\nvalue\n the value to test\n\n\nposition\n bit position to test\n\n\n\n\nReturns\n\n\ntrue if the bit at the given position is 1, false otherwise\n\n\nbit.lshift()\n\n\nLeft-shift a number, equivalent to \nvalue \n shift\n in C.\n\n\nSyntax\n\n\nbit.lshift(value, shift)\n\n\nParameters\n\n\n\n\nvalue\n the value to shift\n\n\nshift\n positions to shift\n\n\n\n\nReturns\n\n\nthe number shifted left\n\n\nbit.rshift()\n\n\nLogical right shift a number, equivalent to \n( unsigned )value \n shift\n in C.\n\n\nSyntax\n\n\nbit.rshift(value, shift)\n\n\nParameters\n\n\n\n\nvalue\n the value to shift.\n\n\nshift\n positions to shift.\n\n\n\n\nReturns\n\n\nthe number shifted right (logically)\n\n\nbit.set()\n\n\nSet bits in a number.\n\n\nSyntax\n\n\nbit.set(value, pos1 [, ... posn ])\n\n\nParameters\n\n\n\n\nvalue\n the base number.\n\n\npos1\n position of the first bit to set.\n\n\n...posn\n position of the nth bit to set.\n\n\n\n\nReturns\n\n\nthe number with the bit(s) set in the given position(s)", 
            "title": "bit"
        }, 
        {
            "location": "/en/modules/bit/#bit-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-24  https://github.com/LuaDist/bitlib ,  Zeroday  Zeroday  bit.c     Bit manipulation support, on 32bit integers.", 
            "title": "bit Module"
        }, 
        {
            "location": "/en/modules/bit/#bitarshift", 
            "text": "Arithmetic right shift a number equivalent to  value   shift  in C.", 
            "title": "bit.arshift()"
        }, 
        {
            "location": "/en/modules/bit/#syntax", 
            "text": "bit.arshift(value, shift)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters", 
            "text": "value  the value to shift  shift  positions to shift", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns", 
            "text": "the number shifted right (arithmetically)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitband", 
            "text": "Bitwise AND, equivalent to  val1   val2   ...   valn  in C.", 
            "title": "bit.band()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_1", 
            "text": "bit.band(val1, val2 [, ... valn])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_1", 
            "text": "val1  first AND argument  val2  second AND argument  ...valn  ...nth AND argument", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_1", 
            "text": "the bitwise AND of all the arguments (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitbit", 
            "text": "Generate a number with a 1 bit (used for mask generation). Equivalent to  1   position  in C.", 
            "title": "bit.bit()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_2", 
            "text": "bit.bit(position)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_2", 
            "text": "position  position of the bit that will be set to 1", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_2", 
            "text": "a number with only one 1 bit at position (the rest are set to 0)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitbnot", 
            "text": "Bitwise negation, equivalent to `~value in C.", 
            "title": "bit.bnot()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_3", 
            "text": "bit.bnot(value)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_3", 
            "text": "value  the number to negate", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_3", 
            "text": "the bitwise negated value of the number", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitbor", 
            "text": "Bitwise OR, equivalent to  val1 | val2 | ... | valn  in C.", 
            "title": "bit.bor()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_4", 
            "text": "bit.bor(val1, val2 [, ... valn])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_4", 
            "text": "val1  first OR argument.  val2  second OR argument.  ...valn  ...nth OR argument", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_4", 
            "text": "the bitwise OR of all the arguments (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitbxor", 
            "text": "Bitwise XOR, equivalent to  val1 ^ val2 ^ ... ^ valn  in C.", 
            "title": "bit.bxor()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_5", 
            "text": "bit.bxor(val1, val2 [, ... valn])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_5", 
            "text": "val1  first XOR argument  val2  second XOR argument  ...valn  ...nth XOR argument", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_5", 
            "text": "the bitwise XOR of all the arguments (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitclear", 
            "text": "Clear bits in a number.", 
            "title": "bit.clear()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_6", 
            "text": "bit.clear(value, pos1 [, ... posn])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_6", 
            "text": "value  the base number  pos1  position of the first bit to clear  ...posn  position of thet nth bit to clear", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_6", 
            "text": "the number with the bit(s) cleared in the given position(s)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitisclear", 
            "text": "Test if a given bit is cleared.", 
            "title": "bit.isclear()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_7", 
            "text": "bit.isclear(value, position)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_7", 
            "text": "value  the value to test  position  bit position to test", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_7", 
            "text": "true if the bit at the given position is 0, false othewise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitisset", 
            "text": "Test if a given bit is set.", 
            "title": "bit.isset()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_8", 
            "text": "bit.isset(value, position)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_8", 
            "text": "value  the value to test  position  bit position to test", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_8", 
            "text": "true if the bit at the given position is 1, false otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitlshift", 
            "text": "Left-shift a number, equivalent to  value   shift  in C.", 
            "title": "bit.lshift()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_9", 
            "text": "bit.lshift(value, shift)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_9", 
            "text": "value  the value to shift  shift  positions to shift", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_9", 
            "text": "the number shifted left", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitrshift", 
            "text": "Logical right shift a number, equivalent to  ( unsigned )value   shift  in C.", 
            "title": "bit.rshift()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_10", 
            "text": "bit.rshift(value, shift)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_10", 
            "text": "value  the value to shift.  shift  positions to shift.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_10", 
            "text": "the number shifted right (logically)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bit/#bitset", 
            "text": "Set bits in a number.", 
            "title": "bit.set()"
        }, 
        {
            "location": "/en/modules/bit/#syntax_11", 
            "text": "bit.set(value, pos1 [, ... posn ])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bit/#parameters_11", 
            "text": "value  the base number.  pos1  position of the first bit to set.  ...posn  position of the nth bit to set.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bit/#returns_11", 
            "text": "the number with the bit(s) set in the given position(s)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bme280/", 
            "text": "BME280 module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-02-21\n\n\nvsky279\n\n\nvsky279\n\n\nbme280.c\n\n\n\n\n\n\n\n\nThis module provides a simple interface to \nBME280/BMP280 temperature/air presssure/humidity sensors\n (Bosch Sensortec).\n\n\n\n\nCaution\n\n\nNote that you must call \nsetup()\n before you can start reading values! Furthermore, there has to be a variable delay between some tens to hundreds of milliseconds between \nsetup()\n and reading measurements. Instead of using a fixed delay you might also poll the sensor until data is delivered e.g. \nhumi()\n not returning \nnil\n anymore.\n\n\n\n\nbme280.altitude()\n\n\nFor given air pressure and sea level air pressure returns the altitude in meters as an integer multiplied with 100, i.e. altimeter function.\n\n\nSyntax\n\n\nbme280.altitude(P, QNH)\n\n\nParameters\n\n\n\n\nP\n measured pressure\n\n\nQNH\n current sea level pressure\n\n\n\n\nReturns\n\n\naltitude in meters of measurement point\n\n\nbme280.baro()\n\n\nReads the sensor and returns the air pressure in hectopascals as an integer multiplied with 1000 or \nnil\n when readout is not successful.\nCurrent temperature is needed to calculate the air pressure so temperature reading is performed prior reading pressure data. Second returned variable is therefore current air temperature.\n\n\nSyntax\n\n\nbme280.baro()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nP\n air pressure in hectopascals multiplied by 1000\n\n\nT\n temperature in celsius as an integer multiplied with 100\n\n\n\n\nbme280.dewpoint()\n\n\nFor given temperature and relative humidity returns the dew point in celsius as an integer multiplied with 100.\n\n\nSyntax\n\n\nbme280.dewpoint(H, T)\n\n\nParameters\n\n\n\n\nH\n relative humidity in percent multiplied by 1000.\n\n\nT\n temperate in celsius multiplied by 100.\n\n\n\n\nReturns\n\n\ndew point in celsisus\n\n\nbme280.humi()\n\n\nReads the sensor and returns the air relative humidity in percents as an integer multiplied with 100 or \nnil\n when readout is not successful.\nCurrent temperature is needed to calculate the relative humidity so temperature reading is performed prior reading pressure data. Second returned variable is therefore current temperature.\n\n\nSyntax\n\n\nbme280.humi()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nH\n last relative humidity reading in % times 1000\n\n\nT\n temperature in celsius as an integer multiplied with 100\n\n\n\n\nbme280.init()\n\n\nInitializes module. Initialization is mandatory before read values.\n\n\n\n\nAttention\n\n\nThis function is deprecated and will be removed in upcoming releases. Use \nbme280.setup()\n instead.\n\n\n\n\nSyntax\n\n\nbme280.init(sda, scl, [temp_oss, press_oss, humi_oss, power_mode, inactive_duration, IIR_filter])\n\n\nParameters\n\n\nSee \nsetup()\n.\n\n\nbme280.qfe2qnh()\n\n\nFor given altitude converts the air pressure to sea level air pressure.\n\n\nSyntax\n\n\nbme280.qfe2qnh(P, altitude)\n\n\nParameters\n\n\n\n\nP\n measured pressure\n\n\naltitude\n altitude in meters of measurement point\n\n\n\n\nReturns\n\n\nsea level pressure\n\n\nbme280.read()\n\n\nReads the sensor and returns the temperature, the air pressure, the air relative humidity and \n\n\nSyntax\n\n\nbme280.read([altitude])\n\n\nParameters\n\n\n\n\n(optional) \naltitude\n- altitude in meters of measurement point. If provided also the air pressure converted to sea level air pressure is returned.\n\n\n\n\nReturns\n\n\n\n\nT\n temperature in celsius as an integer multiplied with 100\n\n\nP\n air pressure in hectopascals multiplied by 1000\n\n\nH\n relative humidity in percent multiplied by 1000\n\n\nQNH\n air pressure in hectopascals multiplied by 1000 converted to sea level\n\n\n\n\nAny of these variables is \nnil\n if the readout of given measure was not successful.\n\n\nbme280.startreadout()\n\n\nStarts readout (turns the sensor into forced mode). After the readout the sensor turns to sleep mode.\n\n\nSyntax\n\n\nbme280.startreadout(delay, callback)\n\n\nParameters\n\n\n\n\ndelay\n sets sensor to forced mode and calls the \ncallback\n (if provided) after given number of milliseconds. For 0 the default delay is set to 113ms (sufficient time to perform reading for oversampling settings 16x). For different oversampling setting please refer to \nBME280 Final Datasheet - Appendix B: Measurement time and current calculation\n.\n\n\ncallback\n if provided it will be invoked after given \ndelay\n. The sensor reading should be finalized by then so.\n\n\n\n\nReturns\n\n\nnil\n\n\nbme280.setup()\n\n\nInitializes module. Initialization is mandatory before read values.\n\n\nSyntax\n\n\nbme280.setup([temp_oss, press_oss, humi_oss, power_mode, inactive_duration, IIR_filter])\n\n\nParameters\n\n\n\n\n(optional) \ntemp_oss\n - Controls oversampling of temperature data. Default oversampling is 16x.\n\n\n(optional) \npress_oss\n - Controls oversampling of pressure data. Default oversampling is 16x.\n\n\n(optional) \nhumi_oss\n - Controls oversampling of humidity data. Default oversampling is 16x\n\n\n(optional) \nsensor_mode\n - Controls the sensor mode of the device. Default sensor more is normal.\n\n\n(optional) \ninactive_duration\n - Controls inactive duration in normal mode. Default inactive duration is 20ms.\n\n\n(optional) \nIIR_filter\n - Controls the time constant of the IIR filter. Default fitler coefficient is 16.\n\n\n(optional) \ncold_start\n - If 0 then the BME280 chip is not initialised. Usefull in a battery operated setup when the ESP deep sleeps and on wakeup needs to initialise the driver (the module) but not the chip itself. The chip was kept powered (sleeping too) and is holding the latest reading that should be fetched quickly before another reading starts (\nbme280.startreadout()\n). By default the chip is initialised.\n\n\n\n\n\n\n\n\n\n\ntemp_oss\n, \npress_oss\n, \nhumi_oss\n\n\nData oversampling\n\n\n\n\n\n\n\n\n\n\n0\n\n\nSkipped (output set to 0x80000)\n\n\n\n\n\n\n1\n\n\noversampling \u00d71\n\n\n\n\n\n\n2\n\n\noversampling \u00d72\n\n\n\n\n\n\n3\n\n\noversampling \u00d74\n\n\n\n\n\n\n4\n\n\noversampling \u00d78\n\n\n\n\n\n\n5\n\n\noversampling \u00d716\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsensor_mode\n\n\nSensor mode\n\n\n\n\n\n\n\n\n\n\n0\n\n\nSleep mode\n\n\n\n\n\n\n1 and 2\n\n\nForced mode\n\n\n\n\n\n\n3\n\n\nNormal mode\n\n\n\n\n\n\n\n\nUsing forced mode is recommended for applications which require low sampling rate or hostbased synchronization. The sensor enters into sleep mode after a forced readout. Please refer to BME280 Final Datasheet for more details.\n\n\n\n\n\n\n\n\ninactive_duration\n\n\nt standby (ms)\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0.5\n\n\n\n\n\n\n1\n\n\n62.5\n\n\n\n\n\n\n2\n\n\n125\n\n\n\n\n\n\n3\n\n\n250\n\n\n\n\n\n\n4\n\n\n500\n\n\n\n\n\n\n5\n\n\n1000\n\n\n\n\n\n\n6\n\n\n10\n\n\n\n\n\n\n7\n\n\n20\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIIR_filter\n\n\nFilter coefficient\n\n\n\n\n\n\n\n\n\n\n0\n\n\nFilter off\n\n\n\n\n\n\n1\n\n\n2\n\n\n\n\n\n\n2\n\n\n4\n\n\n\n\n\n\n3\n\n\n8\n\n\n\n\n\n\n4\n\n\n16\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n if initialization has failed (no sensor connected?), \n2\n if sensor is BME280, \n1\n if sensor is BMP280\n\n\nExample\n\n\nalt=320 -- altitude of the measurement place\n\nsda, scl = 3, 4\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nbme280.setup()\n\nP, T = bme280.baro()\nprint(string.format(\nQFE=%d.%03d\n, P/1000, P%1000))\n\n-- convert measure air pressure to sea level pressure\nQNH = bme280.qfe2qnh(P, alt)\nprint(string.format(\nQNH=%d.%03d\n, QNH/1000, QNH%1000))\n\nH, T = bme280.humi()\n\nlocal Tsgn = (T \n 0 and -1 or 1); T = Tsgn*T\nprint(string.format(\nT=%s%d.%02d\n, Tsgn\n0 and \n-\n or \n, T/100, T%100))\nprint(string.format(\nhumidity=%d.%03d%%\n, H/1000, H%1000))\n\nD = bme280.dewpoint(H, T)\nlocal Dsgn = (D \n 0 and -1 or 1); D = Dsgn*D\nprint(string.format(\ndew_point=%s%d.%02d\n, Dsgn\n0 and \n-\n or \n, D/100, D%100))\n\n-- altimeter function - calculate altitude based on current sea level pressure (QNH) and measure pressure\nP = bme280.baro()\ncurAlt = bme280.altitude(P, QNH)\nlocal curAltsgn = (curAlt \n 0 and -1 or 1); curAlt = curAltsgn*curAlt\nprint(string.format(\naltitude=%s%d.%02d\n, curAltsgn\n0 and \n-\n or \n, curAlt/100, curAlt%100))\n\n\n\n\nOr simpler and more efficient\n\n\nalt=320 -- altitude of the measurement place\n\nsda, scl = 3, 4\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nbme280.setup()\n\nT, P, H, QNH = bme280.read(alt)\nlocal Tsgn = (T \n 0 and -1 or 1); T = Tsgn*T\nprint(string.format(\nT=%s%d.%02d\n, Tsgn\n0 and \n-\n or \n, T/100, T%100))\nprint(string.format(\nQFE=%d.%03d\n, P/1000, P%1000))\nprint(string.format(\nQNH=%d.%03d\n, QNH/1000, QNH%1000))\nprint(string.format(\nhumidity=%d.%03d%%\n, H/1000, H%1000))\nD = bme280.dewpoint(H, T)\nlocal Dsgn = (D \n 0 and -1 or 1); D = Dsgn*D\nprint(string.format(\ndew_point=%s%d.%02d\n, Dsgn\n0 and \n-\n or \n, D/100, D%100))\n\n-- altimeter function - calculate altitude based on current sea level pressure (QNH) and measure pressure\nP = bme280.baro()\ncurAlt = bme280.altitude(P, QNH)\nlocal curAltsgn = (curAlt \n 0 and -1 or 1); curAlt = curAltsgn*curAlt\nprint(string.format(\naltitude=%s%d.%02d\n, curAltsgn\n0 and \n-\n or \n, curAlt/100, curAlt%100))\n\n\n\n\nUse \nbme280.setup(1, 3, 0, 3, 0, 4)\n for \"game mode\" - Oversampling settings  pressure \u00d74, temperature \u00d71, humidity \u00d70, sensor mode: normal mode, inactive duration  = 0.5 ms, IIR filter settings  filter coefficient 16.\n\n\nExample of readout in forced mode (asynchronous)\n\n\nsda, scl = 3, 4\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nbme280.setup(nil, nil, nil, 0) -- initialize to sleep mode\nbme280.startreadout(0, function ()\n  T, P = bme280.read()\n  local Tsgn = (T \n 0 and -1 or 1); T = Tsgn*T\n  print(string.format(\nT=%s%d.%02d\n, Tsgn\n0 and \n-\n or \n, T/100, T%100))\nend)\n\n\n\n\nbme280.temp()\n\n\nReads the sensor and returns the temperature in celsius as an integer multiplied with 100.\n\n\nSyntax\n\n\nbme280.temp()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nT\n temperature in celsius as an integer multiplied with 100 or \nnil\n when readout is not successful\n\n\nt_fine\n temperature measure used in pressure and humidity compensation formulas (generally no need to use this value)", 
            "title": "bme280"
        }, 
        {
            "location": "/en/modules/bme280/#bme280-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-02-21  vsky279  vsky279  bme280.c     This module provides a simple interface to  BME280/BMP280 temperature/air presssure/humidity sensors  (Bosch Sensortec).   Caution  Note that you must call  setup()  before you can start reading values! Furthermore, there has to be a variable delay between some tens to hundreds of milliseconds between  setup()  and reading measurements. Instead of using a fixed delay you might also poll the sensor until data is delivered e.g.  humi()  not returning  nil  anymore.", 
            "title": "BME280 module"
        }, 
        {
            "location": "/en/modules/bme280/#bme280altitude", 
            "text": "For given air pressure and sea level air pressure returns the altitude in meters as an integer multiplied with 100, i.e. altimeter function.", 
            "title": "bme280.altitude()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax", 
            "text": "bme280.altitude(P, QNH)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters", 
            "text": "P  measured pressure  QNH  current sea level pressure", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#returns", 
            "text": "altitude in meters of measurement point", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bme280/#bme280baro", 
            "text": "Reads the sensor and returns the air pressure in hectopascals as an integer multiplied with 1000 or  nil  when readout is not successful.\nCurrent temperature is needed to calculate the air pressure so temperature reading is performed prior reading pressure data. Second returned variable is therefore current air temperature.", 
            "title": "bme280.baro()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax_1", 
            "text": "bme280.baro()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#returns_1", 
            "text": "P  air pressure in hectopascals multiplied by 1000  T  temperature in celsius as an integer multiplied with 100", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bme280/#bme280dewpoint", 
            "text": "For given temperature and relative humidity returns the dew point in celsius as an integer multiplied with 100.", 
            "title": "bme280.dewpoint()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax_2", 
            "text": "bme280.dewpoint(H, T)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters_2", 
            "text": "H  relative humidity in percent multiplied by 1000.  T  temperate in celsius multiplied by 100.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#returns_2", 
            "text": "dew point in celsisus", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bme280/#bme280humi", 
            "text": "Reads the sensor and returns the air relative humidity in percents as an integer multiplied with 100 or  nil  when readout is not successful.\nCurrent temperature is needed to calculate the relative humidity so temperature reading is performed prior reading pressure data. Second returned variable is therefore current temperature.", 
            "title": "bme280.humi()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax_3", 
            "text": "bme280.humi()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters_3", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#returns_3", 
            "text": "H  last relative humidity reading in % times 1000  T  temperature in celsius as an integer multiplied with 100", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bme280/#bme280init", 
            "text": "Initializes module. Initialization is mandatory before read values.   Attention  This function is deprecated and will be removed in upcoming releases. Use  bme280.setup()  instead.", 
            "title": "bme280.init()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax_4", 
            "text": "bme280.init(sda, scl, [temp_oss, press_oss, humi_oss, power_mode, inactive_duration, IIR_filter])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters_4", 
            "text": "See  setup() .", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#bme280qfe2qnh", 
            "text": "For given altitude converts the air pressure to sea level air pressure.", 
            "title": "bme280.qfe2qnh()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax_5", 
            "text": "bme280.qfe2qnh(P, altitude)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters_5", 
            "text": "P  measured pressure  altitude  altitude in meters of measurement point", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#returns_4", 
            "text": "sea level pressure", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bme280/#bme280read", 
            "text": "Reads the sensor and returns the temperature, the air pressure, the air relative humidity and", 
            "title": "bme280.read()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax_6", 
            "text": "bme280.read([altitude])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters_6", 
            "text": "(optional)  altitude - altitude in meters of measurement point. If provided also the air pressure converted to sea level air pressure is returned.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#returns_5", 
            "text": "T  temperature in celsius as an integer multiplied with 100  P  air pressure in hectopascals multiplied by 1000  H  relative humidity in percent multiplied by 1000  QNH  air pressure in hectopascals multiplied by 1000 converted to sea level   Any of these variables is  nil  if the readout of given measure was not successful.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bme280/#bme280startreadout", 
            "text": "Starts readout (turns the sensor into forced mode). After the readout the sensor turns to sleep mode.", 
            "title": "bme280.startreadout()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax_7", 
            "text": "bme280.startreadout(delay, callback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters_7", 
            "text": "delay  sets sensor to forced mode and calls the  callback  (if provided) after given number of milliseconds. For 0 the default delay is set to 113ms (sufficient time to perform reading for oversampling settings 16x). For different oversampling setting please refer to  BME280 Final Datasheet - Appendix B: Measurement time and current calculation .  callback  if provided it will be invoked after given  delay . The sensor reading should be finalized by then so.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#returns_6", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bme280/#bme280setup", 
            "text": "Initializes module. Initialization is mandatory before read values.", 
            "title": "bme280.setup()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax_8", 
            "text": "bme280.setup([temp_oss, press_oss, humi_oss, power_mode, inactive_duration, IIR_filter])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters_8", 
            "text": "(optional)  temp_oss  - Controls oversampling of temperature data. Default oversampling is 16x.  (optional)  press_oss  - Controls oversampling of pressure data. Default oversampling is 16x.  (optional)  humi_oss  - Controls oversampling of humidity data. Default oversampling is 16x  (optional)  sensor_mode  - Controls the sensor mode of the device. Default sensor more is normal.  (optional)  inactive_duration  - Controls inactive duration in normal mode. Default inactive duration is 20ms.  (optional)  IIR_filter  - Controls the time constant of the IIR filter. Default fitler coefficient is 16.  (optional)  cold_start  - If 0 then the BME280 chip is not initialised. Usefull in a battery operated setup when the ESP deep sleeps and on wakeup needs to initialise the driver (the module) but not the chip itself. The chip was kept powered (sleeping too) and is holding the latest reading that should be fetched quickly before another reading starts ( bme280.startreadout() ). By default the chip is initialised.      temp_oss ,  press_oss ,  humi_oss  Data oversampling      0  Skipped (output set to 0x80000)    1  oversampling \u00d71    2  oversampling \u00d72    3  oversampling \u00d74    4  oversampling \u00d78    5  oversampling \u00d716        sensor_mode  Sensor mode      0  Sleep mode    1 and 2  Forced mode    3  Normal mode     Using forced mode is recommended for applications which require low sampling rate or hostbased synchronization. The sensor enters into sleep mode after a forced readout. Please refer to BME280 Final Datasheet for more details.     inactive_duration  t standby (ms)      0  0.5    1  62.5    2  125    3  250    4  500    5  1000    6  10    7  20        IIR_filter  Filter coefficient      0  Filter off    1  2    2  4    3  8    4  16", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#returns_7", 
            "text": "nil  if initialization has failed (no sensor connected?),  2  if sensor is BME280,  1  if sensor is BMP280", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bme280/#example", 
            "text": "alt=320 -- altitude of the measurement place\n\nsda, scl = 3, 4\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nbme280.setup()\n\nP, T = bme280.baro()\nprint(string.format( QFE=%d.%03d , P/1000, P%1000))\n\n-- convert measure air pressure to sea level pressure\nQNH = bme280.qfe2qnh(P, alt)\nprint(string.format( QNH=%d.%03d , QNH/1000, QNH%1000))\n\nH, T = bme280.humi()\n\nlocal Tsgn = (T   0 and -1 or 1); T = Tsgn*T\nprint(string.format( T=%s%d.%02d , Tsgn 0 and  -  or  , T/100, T%100))\nprint(string.format( humidity=%d.%03d%% , H/1000, H%1000))\n\nD = bme280.dewpoint(H, T)\nlocal Dsgn = (D   0 and -1 or 1); D = Dsgn*D\nprint(string.format( dew_point=%s%d.%02d , Dsgn 0 and  -  or  , D/100, D%100))\n\n-- altimeter function - calculate altitude based on current sea level pressure (QNH) and measure pressure\nP = bme280.baro()\ncurAlt = bme280.altitude(P, QNH)\nlocal curAltsgn = (curAlt   0 and -1 or 1); curAlt = curAltsgn*curAlt\nprint(string.format( altitude=%s%d.%02d , curAltsgn 0 and  -  or  , curAlt/100, curAlt%100))  Or simpler and more efficient  alt=320 -- altitude of the measurement place\n\nsda, scl = 3, 4\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nbme280.setup()\n\nT, P, H, QNH = bme280.read(alt)\nlocal Tsgn = (T   0 and -1 or 1); T = Tsgn*T\nprint(string.format( T=%s%d.%02d , Tsgn 0 and  -  or  , T/100, T%100))\nprint(string.format( QFE=%d.%03d , P/1000, P%1000))\nprint(string.format( QNH=%d.%03d , QNH/1000, QNH%1000))\nprint(string.format( humidity=%d.%03d%% , H/1000, H%1000))\nD = bme280.dewpoint(H, T)\nlocal Dsgn = (D   0 and -1 or 1); D = Dsgn*D\nprint(string.format( dew_point=%s%d.%02d , Dsgn 0 and  -  or  , D/100, D%100))\n\n-- altimeter function - calculate altitude based on current sea level pressure (QNH) and measure pressure\nP = bme280.baro()\ncurAlt = bme280.altitude(P, QNH)\nlocal curAltsgn = (curAlt   0 and -1 or 1); curAlt = curAltsgn*curAlt\nprint(string.format( altitude=%s%d.%02d , curAltsgn 0 and  -  or  , curAlt/100, curAlt%100))  Use  bme280.setup(1, 3, 0, 3, 0, 4)  for \"game mode\" - Oversampling settings  pressure \u00d74, temperature \u00d71, humidity \u00d70, sensor mode: normal mode, inactive duration  = 0.5 ms, IIR filter settings  filter coefficient 16.  Example of readout in forced mode (asynchronous)  sda, scl = 3, 4\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nbme280.setup(nil, nil, nil, 0) -- initialize to sleep mode\nbme280.startreadout(0, function ()\n  T, P = bme280.read()\n  local Tsgn = (T   0 and -1 or 1); T = Tsgn*T\n  print(string.format( T=%s%d.%02d , Tsgn 0 and  -  or  , T/100, T%100))\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/bme280/#bme280temp", 
            "text": "Reads the sensor and returns the temperature in celsius as an integer multiplied with 100.", 
            "title": "bme280.temp()"
        }, 
        {
            "location": "/en/modules/bme280/#syntax_9", 
            "text": "bme280.temp()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bme280/#parameters_9", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bme280/#returns_8", 
            "text": "T  temperature in celsius as an integer multiplied with 100 or  nil  when readout is not successful  t_fine  temperature measure used in pressure and humidity compensation formulas (generally no need to use this value)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bmp085/", 
            "text": "BMP085 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-08-03\n\n\nKonrad Beckmann\n\n\nKonrad Beckmann\n\n\nbmp085.c\n\n\n\n\n\n\n\n\nThis module provides access to the \nBMP085\n temperature and pressure sensor. The module also works with BMP180.\n\n\nbmp085.init()\n\n\nInitializes the module and sets the pin configuration.\n\n\n\n\nAttention\n\n\nThis function is deprecated and will be removed in upcoming releases. Use \nbmp085.setup()\n instead.\n\n\n\n\nSyntax\n\n\nbmp085.init(sda, scl)\n\n\nParameters\n\n\n\n\nsda\n data pin\n\n\nscl\n clock pin\n\n\n\n\nReturns\n\n\nnil\n\n\nbmp085.setup()\n\n\nInitializes the module.\n\n\nSyntax\n\n\nbmp085.setup()\n\n\nParameters\n\n\nNone\n\n\nReturns\n\n\nnil\n\n\nbmp085.temperature()\n\n\nSamples the sensor and returns the temperature in celsius as an integer multiplied with 10.\n\n\nSyntax\n\n\nbmp085.temperature()\n\n\nReturns\n\n\ntemperature multiplied with 10 (integer)\n\n\nExample\n\n\nlocal sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW)\nbmp085.setup()\nlocal t = bmp085.temperature()\nprint(string.format(\nTemperature: %s.%s degrees C\n, t / 10, t % 10))\n\n\n\n\nbmp085.pressure()\n\n\nSamples the sensor and returns the pressure in pascal as an integer.\n\n\nThe optional \noversampling_setting\n parameter determines for how long time the sensor samples data.\nThe default is \n3\n which is the longest sampling setting. Possible values are 0, 1, 2, 3.\nSee the data sheet for more information.\n\n\nSyntax\n\n\nbmp085.pressure(oversampling_setting)\n\n\nParameters\n\n\noversampling_setting\n integer that can be 0, 1, 2 or 3\n\n\nReturns\n\n\npressure in pascals (integer)\n\n\nExample\n\n\nlocal sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nbmp085.setup()\nlocal p = bmp085.pressure()\nprint(string.format(\nPressure: %s.%s mbar\n, p / 100, p % 100))\n\n\n\n\nbmp085.pressure_raw()\n\n\nSamples the sensor and returns the raw pressure in internal units. Might be useful if you need higher precision.\n\n\nSyntax\n\n\nbmp085.pressure_raw(oversampling_setting)\n\n\nParameters\n\n\noversampling_setting\n integer that can be 0, 1, 2 or 3\n\n\nReturns\n\n\nraw pressure sampling value (integer)", 
            "title": "bmp085"
        }, 
        {
            "location": "/en/modules/bmp085/#bmp085-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-08-03  Konrad Beckmann  Konrad Beckmann  bmp085.c     This module provides access to the  BMP085  temperature and pressure sensor. The module also works with BMP180.", 
            "title": "BMP085 Module"
        }, 
        {
            "location": "/en/modules/bmp085/#bmp085init", 
            "text": "Initializes the module and sets the pin configuration.   Attention  This function is deprecated and will be removed in upcoming releases. Use  bmp085.setup()  instead.", 
            "title": "bmp085.init()"
        }, 
        {
            "location": "/en/modules/bmp085/#syntax", 
            "text": "bmp085.init(sda, scl)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bmp085/#parameters", 
            "text": "sda  data pin  scl  clock pin", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bmp085/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bmp085/#bmp085setup", 
            "text": "Initializes the module.", 
            "title": "bmp085.setup()"
        }, 
        {
            "location": "/en/modules/bmp085/#syntax_1", 
            "text": "bmp085.setup()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bmp085/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bmp085/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bmp085/#bmp085temperature", 
            "text": "Samples the sensor and returns the temperature in celsius as an integer multiplied with 10.", 
            "title": "bmp085.temperature()"
        }, 
        {
            "location": "/en/modules/bmp085/#syntax_2", 
            "text": "bmp085.temperature()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bmp085/#returns_2", 
            "text": "temperature multiplied with 10 (integer)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bmp085/#example", 
            "text": "local sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW)\nbmp085.setup()\nlocal t = bmp085.temperature()\nprint(string.format( Temperature: %s.%s degrees C , t / 10, t % 10))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/bmp085/#bmp085pressure", 
            "text": "Samples the sensor and returns the pressure in pascal as an integer.  The optional  oversampling_setting  parameter determines for how long time the sensor samples data.\nThe default is  3  which is the longest sampling setting. Possible values are 0, 1, 2, 3.\nSee the data sheet for more information.", 
            "title": "bmp085.pressure()"
        }, 
        {
            "location": "/en/modules/bmp085/#syntax_3", 
            "text": "bmp085.pressure(oversampling_setting)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bmp085/#parameters_2", 
            "text": "oversampling_setting  integer that can be 0, 1, 2 or 3", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bmp085/#returns_3", 
            "text": "pressure in pascals (integer)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/bmp085/#example_1", 
            "text": "local sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nbmp085.setup()\nlocal p = bmp085.pressure()\nprint(string.format( Pressure: %s.%s mbar , p / 100, p % 100))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/bmp085/#bmp085pressure_raw", 
            "text": "Samples the sensor and returns the raw pressure in internal units. Might be useful if you need higher precision.", 
            "title": "bmp085.pressure_raw()"
        }, 
        {
            "location": "/en/modules/bmp085/#syntax_4", 
            "text": "bmp085.pressure_raw(oversampling_setting)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/bmp085/#parameters_3", 
            "text": "oversampling_setting  integer that can be 0, 1, 2 or 3", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/bmp085/#returns_4", 
            "text": "raw pressure sampling value (integer)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/cjson/", 
            "text": "CJSON Module\n\n\nThis module has been replaced by \nsjson\n. It provides a superset of functionality. All references to \ncjson\n can be replaced by \nsjson\n.", 
            "title": "cjson"
        }, 
        {
            "location": "/en/modules/cjson/#cjson-module", 
            "text": "This module has been replaced by  sjson . It provides a superset of functionality. All references to  cjson  can be replaced by  sjson .", 
            "title": "CJSON Module"
        }, 
        {
            "location": "/en/modules/coap/", 
            "text": "CoAP Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-02-04\n\n\nToby Jaffey \n, \nZeroday\n\n\nZeroday\n\n\ncoap.c\n\n\n\n\n\n\n\n\nThe CoAP module provides a simple implementation according to \nCoAP\n protocol.\nThe basic endpoint server part is based on \nmicrocoap\n, and many other code reference \nlibcoap\n.\n\n\nThis module implements both the client and the server side. GET/PUT/POST/DELETE is partially supported by the client. Server can register Lua functions and variables. No observe or discover supported yet.\n\n\n\n\nCaution\n\n\nThis module is only in the very early stages and not complete yet.\n\n\n\n\nConstants\n\n\nConstants for various functions.\n\n\ncoap.CON\n, \ncoap.NON\n represent the request types.\n\n\ncoap.TEXT_PLAIN\n, \ncoap.LINKFORMAT\n, \ncoap.XML\n, \ncoap.OCTET_STREAM\n, \ncoap.EXI\n, \ncoap.JSON\n represent content types.\n\n\ncoap.Client()\n\n\nCreates a CoAP client.\n\n\nSyntax\n\n\ncoap.Client()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nCoAP client\n\n\nExample\n\n\ncc = coap.Client()\n-- assume there is a coap server at ip 192.168.100\ncc:get(coap.CON, \ncoap://192.168.18.100:5683/.well-known/core\n)\n-- GET is not complete, the result/payload only print out in console.\ncc:post(coap.NON, \ncoap://192.168.18.100:5683/\n, \nHello\n)\n\n\n\n\ncoap.Server()\n\n\nCreates a CoAP server.\n\n\nSyntax\n\n\ncoap.Server()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nCoAP server\n\n\nExample\n\n\n-- use copper addon for firefox\ncs=coap.Server()\ncs:listen(5683)\n\nmyvar=1\ncs:var(\nmyvar\n) -- get coap://192.168.18.103:5683/v1/v/myvar will return the value of myvar: 1\n\nall='[1,2,3]'\ncs:var(\nall\n, coap.JSON) -- sets content type to json\n\n-- function should tack one string, return one string.\nfunction myfun(payload)\n  print(\nmyfun called\n)\n  respond = \nhello\n\n  return respond\nend\ncs:func(\nmyfun\n) -- post coap://192.168.18.103:5683/v1/f/myfun will call myfun\n\n\n\n\n\nCoAP Client\n\n\ncoap.client:get()\n\n\nIssues a GET request to the server.\n\n\nSyntax\n\n\ncoap.client:get(type, uri[, payload])\n\n\nParameters\n\n\n\n\ntype\n \ncoap.CON\n, \ncoap.NON\n, defaults to CON. If the type is CON and request fails, the library retries four more times before giving up.\n\n\nuri\n the URI such as \"coap://192.168.18.103:5683/v1/v/myvar\", only IP addresses are supported i.e. no hostname resoltion.\n\n\npayload\n optional, the payload will be put in the payload section of the request.\n\n\n\n\nReturns\n\n\nnil\n\n\ncoap.client:put()\n\n\nIssues a PUT request to the server.\n\n\nSyntax\n\n\ncoap.client:put(type, uri[, payload])\n\n\nParameters\n\n\n\n\ntype\n \ncoap.CON\n, \ncoap.NON\n, defaults to CON. If the type is CON and request fails, the library retries four more times before giving up.\n\n\nuri\n the URI such as \"coap://192.168.18.103:5683/v1/v/myvar\", only IP addresses are supported i.e. no hostname resoltion.\n\n\npayload\n optional, the payload will be put in the payload section of the request.\n\n\n\n\nReturns\n\n\nnil\n\n\ncoap.client:post()\n\n\nIssues a POST request to the server.\n\n\nSyntax\n\n\ncoap.client:post(type, uri[, payload])\n\n\nParameters\n\n\n\n\ntype\n coap.CON, coap.NON, defaults to CON. when type is CON, and request failed, the request will retry another 4 times before giving up.\n\n\nuri\n the uri such as coap://192.168.18.103:5683/v1/v/myvar, only IP is supported.\n\n\npayload\n optional, the payload will be put in the payload section of the request.\n\n\n\n\nReturns\n\n\nnil\n\n\ncoap.client:delete()\n\n\nIssues a DELETE request to the server.\n\n\nSyntax\n\n\ncoap.client:delete(type, uri[, payload])\n\n\nParameters\n\n\n\n\ntype\n \ncoap.CON\n, \ncoap.NON\n, defaults to CON. If the type is CON and request fails, the library retries four more times before giving up.\n\n\nuri\n the URI such as \"coap://192.168.18.103:5683/v1/v/myvar\", only IP addresses are supported i.e. no hostname resoltion.\n\n\npayload\n optional, the payload will be put in the payload section of the request.\n\n\n\n\nReturns\n\n\nnil\n\n\nCoAP Server\n\n\ncoap.server:listen()\n\n\nStarts the CoAP server on the given port.\n\n\nSyntax\n\n\ncoap.server:listen(port[, ip])\n\n\nParameters\n\n\n\n\nport\n server port (number)\n\n\nip\n optional IP address\n\n\n\n\nReturns\n\n\nnil\n\n\ncoap.server:close()\n\n\nCloses the CoAP server.\n\n\nSyntax\n\n\ncoap.server:close()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\ncoap.server:var()\n\n\nRegisters a Lua variable as an endpoint in the server. the variable value then can be retrieved by a client via GET method, represented as an \nURI\n to the client. The endpoint path for varialble is '/v1/v/'.\n\n\nSyntax\n\n\ncoap.server:var(name[, content_type])\n\n\nParameters\n\n\n\n\nname\n the Lua variable's name\n\n\ncontent_type\n optional, defaults to \ncoap.TEXT_PLAIN\n, see \nContent Negotiation\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- use copper addon for firefox\ncs=coap.Server()\ncs:listen(5683)\n\nmyvar=1\ncs:var(\nmyvar\n) -- get coap://192.168.18.103:5683/v1/v/myvar will return the value of myvar: 1\n-- cs:var(myvar), WRONG, this api accept the name string of the varialbe. but not the variable itself.\nall='[1,2,3]'\ncs:var(\nall\n, coap.JSON) -- sets content type to json\n\n\n\n\ncoap.server:func()\n\n\nRegisters a Lua function as an endpoint in the server. The function then can be called by a client via POST method. represented as an \nURI\n to the client. The endpoint path for function is '/v1/f/'. \n\n\nWhen the client issues a POST request to this URI, the payload will be passed to the function as parameter. The function's return value will be the payload in the message to the client.\n\n\nThe function registered SHOULD accept ONLY ONE string type parameter, and return ONE string value or return nothing.\n\n\nSyntax\n\n\ncoap.server:func(name[, content_type])\n\n\nParameters\n\n\n\n\nname\n the Lua function's name\n\n\ncontent_type\n optional, defaults to \ncoap.TEXT_PLAIN\n, see \nContent Negotiation\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- use copper addon for firefox\ncs=coap.Server()\ncs:listen(5683)\n\n-- function should take only one string, return one string.\nfunction myfun(payload)\n  print(\nmyfun called\n)\n  respond = \nhello\n\n  return respond\nend\ncs:func(\nmyfun\n) -- post coap://192.168.18.103:5683/v1/f/myfun will call myfun\n-- cs:func(myfun), WRONG, this api accept the name string of the function. but not the function itself.", 
            "title": "coap"
        }, 
        {
            "location": "/en/modules/coap/#coap-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-02-04  Toby Jaffey  ,  Zeroday  Zeroday  coap.c     The CoAP module provides a simple implementation according to  CoAP  protocol.\nThe basic endpoint server part is based on  microcoap , and many other code reference  libcoap .  This module implements both the client and the server side. GET/PUT/POST/DELETE is partially supported by the client. Server can register Lua functions and variables. No observe or discover supported yet.   Caution  This module is only in the very early stages and not complete yet.", 
            "title": "CoAP Module"
        }, 
        {
            "location": "/en/modules/coap/#constants", 
            "text": "Constants for various functions.  coap.CON ,  coap.NON  represent the request types.  coap.TEXT_PLAIN ,  coap.LINKFORMAT ,  coap.XML ,  coap.OCTET_STREAM ,  coap.EXI ,  coap.JSON  represent content types.", 
            "title": "Constants"
        }, 
        {
            "location": "/en/modules/coap/#coapclient", 
            "text": "Creates a CoAP client.", 
            "title": "coap.Client()"
        }, 
        {
            "location": "/en/modules/coap/#syntax", 
            "text": "coap.Client()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns", 
            "text": "CoAP client", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#example", 
            "text": "cc = coap.Client()\n-- assume there is a coap server at ip 192.168.100\ncc:get(coap.CON,  coap://192.168.18.100:5683/.well-known/core )\n-- GET is not complete, the result/payload only print out in console.\ncc:post(coap.NON,  coap://192.168.18.100:5683/ ,  Hello )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/coap/#coapserver", 
            "text": "Creates a CoAP server.", 
            "title": "coap.Server()"
        }, 
        {
            "location": "/en/modules/coap/#syntax_1", 
            "text": "coap.Server()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns_1", 
            "text": "CoAP server", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#example_1", 
            "text": "-- use copper addon for firefox\ncs=coap.Server()\ncs:listen(5683)\n\nmyvar=1\ncs:var( myvar ) -- get coap://192.168.18.103:5683/v1/v/myvar will return the value of myvar: 1\n\nall='[1,2,3]'\ncs:var( all , coap.JSON) -- sets content type to json\n\n-- function should tack one string, return one string.\nfunction myfun(payload)\n  print( myfun called )\n  respond =  hello \n  return respond\nend\ncs:func( myfun ) -- post coap://192.168.18.103:5683/v1/f/myfun will call myfun", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/coap/#coap-client", 
            "text": "", 
            "title": "CoAP Client"
        }, 
        {
            "location": "/en/modules/coap/#coapclientget", 
            "text": "Issues a GET request to the server.", 
            "title": "coap.client:get()"
        }, 
        {
            "location": "/en/modules/coap/#syntax_2", 
            "text": "coap.client:get(type, uri[, payload])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters_2", 
            "text": "type   coap.CON ,  coap.NON , defaults to CON. If the type is CON and request fails, the library retries four more times before giving up.  uri  the URI such as \"coap://192.168.18.103:5683/v1/v/myvar\", only IP addresses are supported i.e. no hostname resoltion.  payload  optional, the payload will be put in the payload section of the request.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#coapclientput", 
            "text": "Issues a PUT request to the server.", 
            "title": "coap.client:put()"
        }, 
        {
            "location": "/en/modules/coap/#syntax_3", 
            "text": "coap.client:put(type, uri[, payload])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters_3", 
            "text": "type   coap.CON ,  coap.NON , defaults to CON. If the type is CON and request fails, the library retries four more times before giving up.  uri  the URI such as \"coap://192.168.18.103:5683/v1/v/myvar\", only IP addresses are supported i.e. no hostname resoltion.  payload  optional, the payload will be put in the payload section of the request.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#coapclientpost", 
            "text": "Issues a POST request to the server.", 
            "title": "coap.client:post()"
        }, 
        {
            "location": "/en/modules/coap/#syntax_4", 
            "text": "coap.client:post(type, uri[, payload])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters_4", 
            "text": "type  coap.CON, coap.NON, defaults to CON. when type is CON, and request failed, the request will retry another 4 times before giving up.  uri  the uri such as coap://192.168.18.103:5683/v1/v/myvar, only IP is supported.  payload  optional, the payload will be put in the payload section of the request.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#coapclientdelete", 
            "text": "Issues a DELETE request to the server.", 
            "title": "coap.client:delete()"
        }, 
        {
            "location": "/en/modules/coap/#syntax_5", 
            "text": "coap.client:delete(type, uri[, payload])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters_5", 
            "text": "type   coap.CON ,  coap.NON , defaults to CON. If the type is CON and request fails, the library retries four more times before giving up.  uri  the URI such as \"coap://192.168.18.103:5683/v1/v/myvar\", only IP addresses are supported i.e. no hostname resoltion.  payload  optional, the payload will be put in the payload section of the request.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns_5", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#coap-server", 
            "text": "", 
            "title": "CoAP Server"
        }, 
        {
            "location": "/en/modules/coap/#coapserverlisten", 
            "text": "Starts the CoAP server on the given port.", 
            "title": "coap.server:listen()"
        }, 
        {
            "location": "/en/modules/coap/#syntax_6", 
            "text": "coap.server:listen(port[, ip])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters_6", 
            "text": "port  server port (number)  ip  optional IP address", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns_6", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#coapserverclose", 
            "text": "Closes the CoAP server.", 
            "title": "coap.server:close()"
        }, 
        {
            "location": "/en/modules/coap/#syntax_7", 
            "text": "coap.server:close()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters_7", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns_7", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#coapservervar", 
            "text": "Registers a Lua variable as an endpoint in the server. the variable value then can be retrieved by a client via GET method, represented as an  URI  to the client. The endpoint path for varialble is '/v1/v/'.", 
            "title": "coap.server:var()"
        }, 
        {
            "location": "/en/modules/coap/#syntax_8", 
            "text": "coap.server:var(name[, content_type])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters_8", 
            "text": "name  the Lua variable's name  content_type  optional, defaults to  coap.TEXT_PLAIN , see  Content Negotiation", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns_8", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#example_2", 
            "text": "-- use copper addon for firefox\ncs=coap.Server()\ncs:listen(5683)\n\nmyvar=1\ncs:var( myvar ) -- get coap://192.168.18.103:5683/v1/v/myvar will return the value of myvar: 1\n-- cs:var(myvar), WRONG, this api accept the name string of the varialbe. but not the variable itself.\nall='[1,2,3]'\ncs:var( all , coap.JSON) -- sets content type to json", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/coap/#coapserverfunc", 
            "text": "Registers a Lua function as an endpoint in the server. The function then can be called by a client via POST method. represented as an  URI  to the client. The endpoint path for function is '/v1/f/'.   When the client issues a POST request to this URI, the payload will be passed to the function as parameter. The function's return value will be the payload in the message to the client.  The function registered SHOULD accept ONLY ONE string type parameter, and return ONE string value or return nothing.", 
            "title": "coap.server:func()"
        }, 
        {
            "location": "/en/modules/coap/#syntax_9", 
            "text": "coap.server:func(name[, content_type])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/coap/#parameters_9", 
            "text": "name  the Lua function's name  content_type  optional, defaults to  coap.TEXT_PLAIN , see  Content Negotiation", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/coap/#returns_9", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/coap/#example_3", 
            "text": "-- use copper addon for firefox\ncs=coap.Server()\ncs:listen(5683)\n\n-- function should take only one string, return one string.\nfunction myfun(payload)\n  print( myfun called )\n  respond =  hello \n  return respond\nend\ncs:func( myfun ) -- post coap://192.168.18.103:5683/v1/f/myfun will call myfun\n-- cs:func(myfun), WRONG, this api accept the name string of the function. but not the function itself.", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/cron/", 
            "text": "Cron Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-12-18\n\n\nPhoeniX\n\n\nPhoeniX\n\n\ncron.c\n\n\n\n\n\n\n\n\nCron\n-like scheduler module.\n\n\n\n\nImportant\n\n\nThis module needs RTC time to operate correctly. Do not forget to include the \nrtctime\n module.\n\n\n\n\ncron.schedule()\n\n\nCreates a new schedule entry.\n\n\nSyntax\n\n\ncron.schedule(mask, callback)\n\n\nParameters\n\n\n\n\nmask\n - \ncrontab\n-like string mask for schedule\n\n\ncallback\n - callback \nfunction(entry)\n that is executed at the scheduled time\n\n\n\n\nReturns\n\n\ncron.entry\n sub module\n\n\nExample\n\n\ncron.schedule(\n* * * * *\n, function(e)\n  print(\nEvery minute\n)\nend)\n\ncron.schedule(\n*/5 * * * *\n, function(e)\n  print(\nEvery 5 minutes\n)\nend)\n\ncron.schedule(\n0 */2 * * *\n, function(e)\n  print(\nEvery 2 hours\n)\nend)\n\n\n\n\ncron.reset()\n\n\nRemoves all scheduled entries.\n\n\nSyntax\n\n\ncron.reset()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\ncron.entry Module\n\n\ncron.entry:handler()\n\n\nSets a new handler for entry.\n\n\nSyntax\n\n\nhandler(callback)\n\n\nParameters\n\n\n\n\ncallback\n - callback \nfunction(entry)\n that is executed at the scheduled time\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nent = cron.schedule(\n* * * * *\n, function(e)\n  print(\nEvery minute\n)\nend)\n\nent:handler(function(e)\n  print(\nNew handler: Every minute\n)\nend)\n\n\n\n\ncron.entry:schedule()\n\n\nSets a new schedule mask.\n\n\nSyntax\n\n\nschedule(mask)\n\n\nParameters\n\n\n\n\nmask\n - \ncrontab\n-like string mask for schedule\n\n\n\n\nReturns\n\n\nnone\n\n\nExample\n\n\nent = cron.schedule(\n* * * * *\n, function(e)\n  print(\nTick\n)\nend)\n\n-- Every 5 minutes is really better!\nent:schedule(\n*/5 * * * *\n)\n\n\n\n\ncron.entry:unschedule()\n\n\nDisables schedule.\n\n\nDisabled schedules may be enabled again by calling \n:schedule(mask)\n.\n\n\nSyntax\n\n\nunschedule()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nent = cron.schedule(\n* * * * *\n, function(e)\n  print(\nTick\n)\nend)\n\n-- We don't need this anymore\nent:unschedule()", 
            "title": "cron"
        }, 
        {
            "location": "/en/modules/cron/#cron-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-12-18  PhoeniX  PhoeniX  cron.c     Cron -like scheduler module.   Important  This module needs RTC time to operate correctly. Do not forget to include the  rtctime  module.", 
            "title": "Cron Module"
        }, 
        {
            "location": "/en/modules/cron/#cronschedule", 
            "text": "Creates a new schedule entry.", 
            "title": "cron.schedule()"
        }, 
        {
            "location": "/en/modules/cron/#syntax", 
            "text": "cron.schedule(mask, callback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/cron/#parameters", 
            "text": "mask  -  crontab -like string mask for schedule  callback  - callback  function(entry)  that is executed at the scheduled time", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/cron/#returns", 
            "text": "cron.entry  sub module", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/cron/#example", 
            "text": "cron.schedule( * * * * * , function(e)\n  print( Every minute )\nend)\n\ncron.schedule( */5 * * * * , function(e)\n  print( Every 5 minutes )\nend)\n\ncron.schedule( 0 */2 * * * , function(e)\n  print( Every 2 hours )\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/cron/#cronreset", 
            "text": "Removes all scheduled entries.", 
            "title": "cron.reset()"
        }, 
        {
            "location": "/en/modules/cron/#syntax_1", 
            "text": "cron.reset()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/cron/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/cron/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/cron/#cronentry-module", 
            "text": "", 
            "title": "cron.entry Module"
        }, 
        {
            "location": "/en/modules/cron/#cronentryhandler", 
            "text": "Sets a new handler for entry.", 
            "title": "cron.entry:handler()"
        }, 
        {
            "location": "/en/modules/cron/#syntax_2", 
            "text": "handler(callback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/cron/#parameters_2", 
            "text": "callback  - callback  function(entry)  that is executed at the scheduled time", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/cron/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/cron/#example_1", 
            "text": "ent = cron.schedule( * * * * * , function(e)\n  print( Every minute )\nend)\n\nent:handler(function(e)\n  print( New handler: Every minute )\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/cron/#cronentryschedule", 
            "text": "Sets a new schedule mask.", 
            "title": "cron.entry:schedule()"
        }, 
        {
            "location": "/en/modules/cron/#syntax_3", 
            "text": "schedule(mask)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/cron/#parameters_3", 
            "text": "mask  -  crontab -like string mask for schedule", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/cron/#returns_3", 
            "text": "none", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/cron/#example_2", 
            "text": "ent = cron.schedule( * * * * * , function(e)\n  print( Tick )\nend)\n\n-- Every 5 minutes is really better!\nent:schedule( */5 * * * * )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/cron/#cronentryunschedule", 
            "text": "Disables schedule.  Disabled schedules may be enabled again by calling  :schedule(mask) .", 
            "title": "cron.entry:unschedule()"
        }, 
        {
            "location": "/en/modules/cron/#syntax_4", 
            "text": "unschedule()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/cron/#parameters_4", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/cron/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/cron/#example_3", 
            "text": "ent = cron.schedule( * * * * * , function(e)\n  print( Tick )\nend)\n\n-- We don't need this anymore\nent:unschedule()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/", 
            "text": "crypto Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-06-02\n\n\nDiUS\n, \nJohny Mattsson\n\n\nJohny Mattsson\n\n\ncrypto.c\n\n\n\n\n\n\n\n\nThe crypto modules provides various functions for working with cryptographic algorithms.\n\n\nThe following encryption/decryption algorithms/modes are supported:\n- \n\"AES-ECB\"\n for 128-bit AES in ECB mode (NOT recommended)\n- \n\"AES-CBC\"\n for 128-bit AES in CBC mode\n\n\nThe following hash algorithms are supported:\n- MD2 (not available by default, has to be explicitly enabled in \napp/include/user_config.h\n)\n- MD5\n- SHA1\n- SHA256, SHA384, SHA512 (unless disabled in \napp/include/user_config.h\n)\n\n\ncrypto.encrypt()\n\n\nEncrypts Lua strings.\n\n\nSyntax\n\n\ncrypto.encrypt(algo, key, plain [, iv])\n\n\nParameters\n\n\n\n\nalgo\n the name of a supported encryption algorithm to use\n\n\nkey\n the encryption key as a string; for AES encryption this \nMUST\n be 16 bytes long\n\n\nplain\n the string to encrypt; it will be automatically zero-padded to a 16-byte boundary if necessary\n\n\niv\n the initilization vector, if using AES-CBC; defaults to all-zero if not given\n\n\n\n\nReturns\n\n\nThe encrypted data as a binary string. For AES this is always a multiple of 16 bytes in length.\n\n\nExample\n\n\nprint(crypto.toHex(crypto.encrypt(\nAES-ECB\n, \n1234567890abcdef\n, \nHi, I'm secret!\n)))\n\n\n\n\nSee also\n\n\n\n\ncrypto.decrypt()\n\n\n\n\ncrypto.decrypt()\n\n\nDecrypts previously encrypted data.\n\n\nSyntax\n\n\ncrypto.decrypt(algo, key, cipher [, iv])\n\n\nParameters\n\n\n\n\nalgo\n the name of a supported encryption algorithm to use\n\n\nkey\n the encryption key as a string; for AES encryption this \nMUST\n be 16 bytes long\n\n\ncipher\n the cipher text to decrypt (as obtained from \ncrypto.encrypt()\n)\n\n\niv\n the initilization vector, if using AES-CBC; defaults to all-zero if not given\n\n\n\n\nReturns\n\n\nThe decrypted string.\n\n\nNote that the decrypted string may contain extra zero-bytes of padding at the end. One way of stripping such padding is to use \n:match(\"(.-)%z*$\")\n on the decrypted string. Additional care needs to be taken if working on binary data, in which case the real length likely needs to be encoded with the data, and at which point \n:sub(1, n)\n can be used to strip the padding.\n\n\nExample\n\n\nkey = \n1234567890abcdef\n\ncipher = crypto.encrypt(\nAES-ECB\n, key, \nHi, I'm secret!\n)\nprint(crypto.toHex(cipher))\nprint(crypto.decrypt(\nAES-ECB\n, key, cipher))\n\n\n\n\nSee also\n\n\n\n\ncrypto.encrypt()\n\n\n\n\ncrypto.fhash()\n\n\nCompute a cryptographic hash of a a file.\n\n\nSyntax\n\n\nhash = crypto.fhash(algo, filename)\n\n\nParameters\n\n\n\n\nalgo\n the hash algorithm to use, case insensitive string\n\n\nfilename\n the path to the file to hash\n\n\n\n\nReturns\n\n\nA binary string containing the message digest. To obtain the textual version (ASCII hex characters), please use \ncrypto.toHex()\n.\n\n\nExample\n\n\nprint(crypto.toHex(crypto.fhash(\nsha1\n,\nmyfile.lua\n)))\n\n\n\n\ncrypto.hash()\n\n\nCompute a cryptographic hash of a Lua string.\n\n\nSyntax\n\n\nhash = crypto.hash(algo, str)\n\n\nParameters\n\n\nalgo\n the hash algorithm to use, case insensitive string\n\nstr\n string to hash contents of\n\n\nReturns\n\n\nA binary string containing the message digest. To obtain the textual version (ASCII hex characters), please use \ncrypto.toHex()\n.\n\n\nExample\n\n\nprint(crypto.toHex(crypto.hash(\nsha1\n,\nabc\n)))\n\n\n\n\ncrypto.new_hash()\n\n\nCreate a digest/hash object that can have any number of strings added to it. Object has \nupdate\n and \nfinalize\n functions.\n\n\nSyntax\n\n\nhashobj = crypto.new_hash(algo)\n\n\nParameters\n\n\nalgo\n the hash algorithm to use, case insensitive string\n\n\nReturns\n\n\nUserdata object with \nupdate\n and \nfinalize\n functions available.\n\n\nExample\n\n\nhashobj = crypto.new_hash(\nSHA1\n)\nhashobj:update(\nFirstString\n))\nhashobj:update(\nSecondString\n))\ndigest = hashobj:finalize()\nprint(crypto.toHex(digest))\n\n\n\n\ncrypto.hmac()\n\n\nCompute a \nHMAC\n (Hashed Message Authentication Code) signature for a Lua string.\n\n\nSyntax\n\n\nsignature = crypto.hmac(algo, str, key)\n\n\nParameters\n\n\n\n\nalgo\n hash algorithm to use, case insensitive string\n\n\nstr\n data to calculate the hash for\n\n\nkey\n key to use for signing, may be a binary string\n\n\n\n\nReturns\n\n\nA binary string containing the HMAC signature. Use \ncrypto.toHex()\n to obtain the textual version.\n\n\nExample\n\n\nprint(crypto.toHex(crypto.hmac(\nsha1\n,\nabc\n,\nmysecret\n)))\n\n\n\n\ncrypto.new_hmac()\n\n\nCreate a hmac object that can have any number of strings added to it. Object has \nupdate\n and \nfinalize\n functions.\n\n\nSyntax\n\n\nhmacobj = crypto.new_hmac(algo, key)\n\n\nParameters\n\n\n\n\nalgo\n the hash algorithm to use, case insensitive string\n\n\nkey\n the key to use (may be a binary string)\n\n\n\n\nReturns\n\n\nUserdata object with \nupdate\n and \nfinalize\n functions available.\n\n\nExample\n\n\nhmacobj = crypto.new_hmac(\nSHA1\n, \ns3kr3t\n)\nhmacobj:update(\nFirstString\n))\nhmacobj:update(\nSecondString\n))\ndigest = hmacobj:finalize()\nprint(crypto.toHex(digest))\n\n\n\n\ncrypto.mask()\n\n\nApplies an XOR mask to a Lua string. Note that this is not a proper cryptographic mechanism, but some protocols may use it nevertheless.\n\n\nSyntax\n\n\ncrypto.mask(message, mask)\n\n\nParameters\n\n\n\n\nmessage\n message to mask\n\n\nmask\n the mask to apply, repeated if shorter than the message\n\n\n\n\nReturns\n\n\nThe masked message, as a binary string. Use \ncrypto.toHex()\n to get a textual representation of it.\n\n\nExample\n\n\nprint(crypto.toHex(crypto.mask(\nsome message to obscure\n,\nX0Y7\n)))\n\n\n\n\ncrypto.toBase64()\n\n\nProvides a Base64 representation of a (binary) Lua string.\n\n\nSyntax\n\n\nb64 = crypto.toBase64(binary)\n\n\nParameters\n\n\nbinary\n input string to Base64 encode\n\n\nReturn\n\n\nA Base64 encoded string.\n\n\nExample\n\n\nprint(crypto.toBase64(crypto.hash(\nsha1\n,\nabc\n)))\n\n\n\n\ncrypto.toHex()\n\n\nProvides an ASCII hex representation of a (binary) Lua string. Each byte in the input string is represented as two hex characters in the output.\n\n\nSyntax\n\n\nhexstr = crypto.toHex(binary)\n\n\nParameters\n\n\nbinary\n input string to get hex representation for\n\n\nReturns\n\n\nAn ASCII hex string.\n\n\nExample\n\n\nprint(crypto.toHex(crypto.hash(\nsha1\n,\nabc\n)))", 
            "title": "crypto"
        }, 
        {
            "location": "/en/modules/crypto/#crypto-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-06-02  DiUS ,  Johny Mattsson  Johny Mattsson  crypto.c     The crypto modules provides various functions for working with cryptographic algorithms.  The following encryption/decryption algorithms/modes are supported:\n-  \"AES-ECB\"  for 128-bit AES in ECB mode (NOT recommended)\n-  \"AES-CBC\"  for 128-bit AES in CBC mode  The following hash algorithms are supported:\n- MD2 (not available by default, has to be explicitly enabled in  app/include/user_config.h )\n- MD5\n- SHA1\n- SHA256, SHA384, SHA512 (unless disabled in  app/include/user_config.h )", 
            "title": "crypto Module"
        }, 
        {
            "location": "/en/modules/crypto/#cryptoencrypt", 
            "text": "Encrypts Lua strings.", 
            "title": "crypto.encrypt()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax", 
            "text": "crypto.encrypt(algo, key, plain [, iv])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters", 
            "text": "algo  the name of a supported encryption algorithm to use  key  the encryption key as a string; for AES encryption this  MUST  be 16 bytes long  plain  the string to encrypt; it will be automatically zero-padded to a 16-byte boundary if necessary  iv  the initilization vector, if using AES-CBC; defaults to all-zero if not given", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#returns", 
            "text": "The encrypted data as a binary string. For AES this is always a multiple of 16 bytes in length.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/crypto/#example", 
            "text": "print(crypto.toHex(crypto.encrypt( AES-ECB ,  1234567890abcdef ,  Hi, I'm secret! )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/#see-also", 
            "text": "crypto.decrypt()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/crypto/#cryptodecrypt", 
            "text": "Decrypts previously encrypted data.", 
            "title": "crypto.decrypt()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax_1", 
            "text": "crypto.decrypt(algo, key, cipher [, iv])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters_1", 
            "text": "algo  the name of a supported encryption algorithm to use  key  the encryption key as a string; for AES encryption this  MUST  be 16 bytes long  cipher  the cipher text to decrypt (as obtained from  crypto.encrypt() )  iv  the initilization vector, if using AES-CBC; defaults to all-zero if not given", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#returns_1", 
            "text": "The decrypted string.  Note that the decrypted string may contain extra zero-bytes of padding at the end. One way of stripping such padding is to use  :match(\"(.-)%z*$\")  on the decrypted string. Additional care needs to be taken if working on binary data, in which case the real length likely needs to be encoded with the data, and at which point  :sub(1, n)  can be used to strip the padding.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/crypto/#example_1", 
            "text": "key =  1234567890abcdef \ncipher = crypto.encrypt( AES-ECB , key,  Hi, I'm secret! )\nprint(crypto.toHex(cipher))\nprint(crypto.decrypt( AES-ECB , key, cipher))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/#see-also_1", 
            "text": "crypto.encrypt()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/crypto/#cryptofhash", 
            "text": "Compute a cryptographic hash of a a file.", 
            "title": "crypto.fhash()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax_2", 
            "text": "hash = crypto.fhash(algo, filename)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters_2", 
            "text": "algo  the hash algorithm to use, case insensitive string  filename  the path to the file to hash", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#returns_2", 
            "text": "A binary string containing the message digest. To obtain the textual version (ASCII hex characters), please use  crypto.toHex() .", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/crypto/#example_2", 
            "text": "print(crypto.toHex(crypto.fhash( sha1 , myfile.lua )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/#cryptohash", 
            "text": "Compute a cryptographic hash of a Lua string.", 
            "title": "crypto.hash()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax_3", 
            "text": "hash = crypto.hash(algo, str)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters_3", 
            "text": "algo  the hash algorithm to use, case insensitive string str  string to hash contents of", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#returns_3", 
            "text": "A binary string containing the message digest. To obtain the textual version (ASCII hex characters), please use  crypto.toHex() .", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/crypto/#example_3", 
            "text": "print(crypto.toHex(crypto.hash( sha1 , abc )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/#cryptonew_hash", 
            "text": "Create a digest/hash object that can have any number of strings added to it. Object has  update  and  finalize  functions.", 
            "title": "crypto.new_hash()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax_4", 
            "text": "hashobj = crypto.new_hash(algo)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters_4", 
            "text": "algo  the hash algorithm to use, case insensitive string", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#returns_4", 
            "text": "Userdata object with  update  and  finalize  functions available.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/crypto/#example_4", 
            "text": "hashobj = crypto.new_hash( SHA1 )\nhashobj:update( FirstString ))\nhashobj:update( SecondString ))\ndigest = hashobj:finalize()\nprint(crypto.toHex(digest))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/#cryptohmac", 
            "text": "Compute a  HMAC  (Hashed Message Authentication Code) signature for a Lua string.", 
            "title": "crypto.hmac()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax_5", 
            "text": "signature = crypto.hmac(algo, str, key)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters_5", 
            "text": "algo  hash algorithm to use, case insensitive string  str  data to calculate the hash for  key  key to use for signing, may be a binary string", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#returns_5", 
            "text": "A binary string containing the HMAC signature. Use  crypto.toHex()  to obtain the textual version.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/crypto/#example_5", 
            "text": "print(crypto.toHex(crypto.hmac( sha1 , abc , mysecret )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/#cryptonew_hmac", 
            "text": "Create a hmac object that can have any number of strings added to it. Object has  update  and  finalize  functions.", 
            "title": "crypto.new_hmac()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax_6", 
            "text": "hmacobj = crypto.new_hmac(algo, key)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters_6", 
            "text": "algo  the hash algorithm to use, case insensitive string  key  the key to use (may be a binary string)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#returns_6", 
            "text": "Userdata object with  update  and  finalize  functions available.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/crypto/#example_6", 
            "text": "hmacobj = crypto.new_hmac( SHA1 ,  s3kr3t )\nhmacobj:update( FirstString ))\nhmacobj:update( SecondString ))\ndigest = hmacobj:finalize()\nprint(crypto.toHex(digest))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/#cryptomask", 
            "text": "Applies an XOR mask to a Lua string. Note that this is not a proper cryptographic mechanism, but some protocols may use it nevertheless.", 
            "title": "crypto.mask()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax_7", 
            "text": "crypto.mask(message, mask)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters_7", 
            "text": "message  message to mask  mask  the mask to apply, repeated if shorter than the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#returns_7", 
            "text": "The masked message, as a binary string. Use  crypto.toHex()  to get a textual representation of it.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/crypto/#example_7", 
            "text": "print(crypto.toHex(crypto.mask( some message to obscure , X0Y7 )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/#cryptotobase64", 
            "text": "Provides a Base64 representation of a (binary) Lua string.", 
            "title": "crypto.toBase64()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax_8", 
            "text": "b64 = crypto.toBase64(binary)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters_8", 
            "text": "binary  input string to Base64 encode", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#return", 
            "text": "A Base64 encoded string.", 
            "title": "Return"
        }, 
        {
            "location": "/en/modules/crypto/#example_8", 
            "text": "print(crypto.toBase64(crypto.hash( sha1 , abc )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/crypto/#cryptotohex", 
            "text": "Provides an ASCII hex representation of a (binary) Lua string. Each byte in the input string is represented as two hex characters in the output.", 
            "title": "crypto.toHex()"
        }, 
        {
            "location": "/en/modules/crypto/#syntax_9", 
            "text": "hexstr = crypto.toHex(binary)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/crypto/#parameters_9", 
            "text": "binary  input string to get hex representation for", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/crypto/#returns_8", 
            "text": "An ASCII hex string.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/crypto/#example_9", 
            "text": "print(crypto.toHex(crypto.hash( sha1 , abc )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/dht/", 
            "text": "DHT Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-06-17\n\n\nRobTillaart\n\n\nVowstar\n\n\ndhtlib\n\n\n\n\n\n\n\n\nConstants\n\n\nConstants for various functions.\n\n\ndht.OK\n, \ndht.ERROR_CHECKSUM\n, \ndht.ERROR_TIMEOUT\n represent the potential values for the DHT read status\n\n\ndht.read()\n\n\nRead all kinds of DHT sensors, including DHT11, 21, 22, 33, 44 humidity temperature combo sensor.\n\n\nSyntax\n\n\ndht.read(pin)\n\n\nParameters\n\n\npin\n pin number of DHT sensor (can't be 0), type is number\n\n\nReturns\n\n\n\n\nstatus\n as defined in Constants\n\n\ntemp\n temperature (see note below)\n\n\nhumi\n humidity (see note below)\n\n\ntemp_dec\n temperature decimal\n\n\nhumi_dec\n humidity decimal\n\n\n\n\n\n\nNote\n\n\nIf using float firmware then \ntemp\n and \nhumi\n are floating point numbers. On an integer firmware, the final values have to be concatenated from \ntemp\n and \ntemp_dec\n / \nhumi\n and \nhum_dec\n.\n\n\n\n\nExample\n\n\npin = 5\nstatus, temp, humi, temp_dec, humi_dec = dht.read(pin)\nif status == dht.OK then\n    -- Integer firmware using this example\n    print(string.format(\nDHT Temperature:%d.%03d;Humidity:%d.%03d\\r\\n\n,\n          math.floor(temp),\n          temp_dec,\n          math.floor(humi),\n          humi_dec\n    ))\n\n    -- Float firmware using this example\n    print(\nDHT Temperature:\n..temp..\n;\n..\nHumidity:\n..humi)\n\nelseif status == dht.ERROR_CHECKSUM then\n    print( \nDHT Checksum error.\n )\nelseif status == dht.ERROR_TIMEOUT then\n    print( \nDHT timed out.\n )\nend\n\n\n\n\ndht.read11()\n\n\nRead DHT11 humidity temperature combo sensor.\n\n\nSyntax\n\n\ndht.read11(pin)\n\n\nParameters\n\n\npin\n pin number of DHT11 sensor (can't be 0), type is number\n\n\nReturns\n\n\n\n\nstatus\n as defined in Constants\n\n\ntemp\n temperature (see note below)\n\n\nhumi\n humidity (see note below)\n\n\ntemp_dec\n temperature decimal\n\n\nhumi_dec\n humidity decimal\n\n\n\n\n\n\nNote\n\n\nIf using float firmware then \ntemp\n and \nhumi\n are floating point numbers. On an integer firmware, the final values have to be concatenated from \ntemp\n and \ntemp_dec\n / \nhumi\n and \nhum_dec\n.\n\n\n\n\nSee also\n\n\ndht.read()\n\n\ndht.readxx()\n\n\nRead all kinds of DHT sensors, except DHT11.\n\n\nSyntax\n\n\ndht.readxx(pin)\n\n\nParameters\n\n\npin\n pin number of DHT sensor (can't be 0), type is number\n\n\nReturns\n\n\n\n\nstatus\n as defined in Constants\n\n\ntemp\n temperature (see note below)\n\n\nhumi\n humidity (see note below)\n\n\ntemp_dec\n temperature decimal\n\n\nhumi_dec\n humidity decimal\n\n\n\n\n\n\nNote\n\n\nIf using float firmware then \ntemp\n and \nhumi\n are floating point numbers. On an integer firmware, the final values have to be concatenated from \ntemp\n and \ntemp_dec\n / \nhumi\n and \nhum_dec\n.\n\n\n\n\nSee also\n\n\ndht.read()", 
            "title": "dht"
        }, 
        {
            "location": "/en/modules/dht/#dht-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-06-17  RobTillaart  Vowstar  dhtlib", 
            "title": "DHT Module"
        }, 
        {
            "location": "/en/modules/dht/#constants", 
            "text": "Constants for various functions.  dht.OK ,  dht.ERROR_CHECKSUM ,  dht.ERROR_TIMEOUT  represent the potential values for the DHT read status", 
            "title": "Constants"
        }, 
        {
            "location": "/en/modules/dht/#dhtread", 
            "text": "Read all kinds of DHT sensors, including DHT11, 21, 22, 33, 44 humidity temperature combo sensor.", 
            "title": "dht.read()"
        }, 
        {
            "location": "/en/modules/dht/#syntax", 
            "text": "dht.read(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/dht/#parameters", 
            "text": "pin  pin number of DHT sensor (can't be 0), type is number", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/dht/#returns", 
            "text": "status  as defined in Constants  temp  temperature (see note below)  humi  humidity (see note below)  temp_dec  temperature decimal  humi_dec  humidity decimal    Note  If using float firmware then  temp  and  humi  are floating point numbers. On an integer firmware, the final values have to be concatenated from  temp  and  temp_dec  /  humi  and  hum_dec .", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/dht/#example", 
            "text": "pin = 5\nstatus, temp, humi, temp_dec, humi_dec = dht.read(pin)\nif status == dht.OK then\n    -- Integer firmware using this example\n    print(string.format( DHT Temperature:%d.%03d;Humidity:%d.%03d\\r\\n ,\n          math.floor(temp),\n          temp_dec,\n          math.floor(humi),\n          humi_dec\n    ))\n\n    -- Float firmware using this example\n    print( DHT Temperature: ..temp.. ; .. Humidity: ..humi)\n\nelseif status == dht.ERROR_CHECKSUM then\n    print(  DHT Checksum error.  )\nelseif status == dht.ERROR_TIMEOUT then\n    print(  DHT timed out.  )\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/dht/#dhtread11", 
            "text": "Read DHT11 humidity temperature combo sensor.", 
            "title": "dht.read11()"
        }, 
        {
            "location": "/en/modules/dht/#syntax_1", 
            "text": "dht.read11(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/dht/#parameters_1", 
            "text": "pin  pin number of DHT11 sensor (can't be 0), type is number", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/dht/#returns_1", 
            "text": "status  as defined in Constants  temp  temperature (see note below)  humi  humidity (see note below)  temp_dec  temperature decimal  humi_dec  humidity decimal    Note  If using float firmware then  temp  and  humi  are floating point numbers. On an integer firmware, the final values have to be concatenated from  temp  and  temp_dec  /  humi  and  hum_dec .", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/dht/#see-also", 
            "text": "dht.read()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/dht/#dhtreadxx", 
            "text": "Read all kinds of DHT sensors, except DHT11.", 
            "title": "dht.readxx()"
        }, 
        {
            "location": "/en/modules/dht/#syntax_2", 
            "text": "dht.readxx(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/dht/#parameters_2", 
            "text": "pin  pin number of DHT sensor (can't be 0), type is number", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/dht/#returns_2", 
            "text": "status  as defined in Constants  temp  temperature (see note below)  humi  humidity (see note below)  temp_dec  temperature decimal  humi_dec  humidity decimal    Note  If using float firmware then  temp  and  humi  are floating point numbers. On an integer firmware, the final values have to be concatenated from  temp  and  temp_dec  /  humi  and  hum_dec .", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/dht/#see-also_1", 
            "text": "dht.read()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/ds18b20/", 
            "text": "DS18B20 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2017-06-11\n\n\nfetchbot\n\n\nfetchbot\n\n\nds18b20.c\n\n\n\n\n\n\n\n\nThis module provides access to the DS18B20 1-Wire digital thermometer. Note that NodeMCU offers both a C module (this one) and \na Lua module for this sensor\n. See \n#2003\n for a discussion on the respective merits of them.\n\n\nds18b20.read()\n\n\nIssues a temperature conversion of all connected sensors on the onewire bus and returns the measurment results after a conversion delay in a callback function.\nThe returned measurements can be filtered through the ROM addresses passed as a table or by the family type.\nThe callback function gets invoked for every specified sensor.\n\n\nSyntax\n\n\nds18b20.read(CALLBACK, ROM[, FAMILY_ADDRESS])\n\n\nParameters\n\n\n\n\nCALLBACK\n callback function executed for each sensor\n\n\ne.g. \nfunction(INDEX, ROM, RES, TEMP, TEMP_DEC, PAR) print(INDEX, ROM, RES, TEMP, TEMP_DEC, PAR) end\n\n\n\n\n\n\nROM\n table which contains the addresses for the specified sensors, or left empty to perform a onewire bus search for all sensors\n\n\ne.g. \n{\"28:FF:FF:FF:FF:FF:FF:FF\",\"28:FF:FF:FF:FF:FF:FF:FF\"}\n, \n{}\n\n\n\n\n\n\nFAMILY_ADDRESS\n optional to limit the search for devices to a specific family type\n\n\ne.g \n0x28\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nCallback function parameters\n\n\n\n\nINDEX\n index of the sensor on the bus\n\n\nROM\n sensors 64-bit lasered rom code\n\n\n28:FF:FF:FF:FF:FF:FF:FF\n LSB, 8-bit family code, 48-bit serial number, MSB 8-bit crc\n\n\n\n\n\n\nRES\n temperature resolution\n\n\nTEMP\n temperature\n\n\nTEMP_DEC\n temperature decimals for integer firmware\n\n\nPAR\n sensor parasitic flag\n\n\n\n\n\n\nNote\n\n\nIf using float firmware then \ntemp\n is a floating point number. On an integer firmware, the final value has to be concatenated from \ntemp\n and \ntemp_dec\n.\n\n\n\n\nExample\n\n\nlocal ow_pin = 3\nds18b20.setup(ow_pin)\n\n-- read all sensors and print all measurement results\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        print(ind,string.format(\n%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\n,string.match(rom,\n(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+)\n)),res,temp,tdec,par)\n    end,{});\n\n-- read only sensors with family type 0x28 and print all measurement results\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        print(ind,string.format(\n%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\n,string.match(rom,\n(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+)\n)),res,temp,tdec,par)\n    end,{},0x28);\n\n-- save device roms in a variable\nlocal addr = {}\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        addr[ind] = {string.format(\n%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\n,string.match(rom,\n(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+)\n))}\n    end,{});\n\n-- read only sensors listed in the variable addr\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        print(ind,string.format(\n%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\n,string.match(rom,\n(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+)\n)),res,temp,tdec,par)\n    end,addr);\n\n-- print only parasitic sensors\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        if (par == 1) then\n            print(ind,string.format(\n%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\n,string.match(rom,\n(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+)\n)),res,temp,tdec,par)\n        end\n    end,{});\n\n-- print if temperature is greater or less than a defined value\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        if (t \n 25) then\n            print(ind,string.format(\n%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\n,string.match(rom,\n(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+)\n)),res,temp,tdec,par)\n        end\n        if (t \n 20) then\n            print(ind,string.format(\n%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\n,string.match(rom,\n(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+)\n)),res,temp,tdec,par)\n        end\n    end,{});\n\n\n\n\nds18b20.setting()\n\n\nConfiguration of the temperature resolution settings.\n\n\nSyntax\n\n\nds18b20.setting(ROM, RES)\n\n\nParameters\n\n\n\n\nROM\n table which contains the addresses for the specified sensors, or empty for all sensors\n\n\ne.g. \n{\"28:FF:FF:FF:FF:FF:FF:FF\",\"28:FF:FF:FF:FF:FF:FF:FF\"}\n, \n{}\n\n\n\n\n\n\nRES\n temperature bit resolution\n\n\n9\n - \n12\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nlocal ow_pin = 3\nds18b20.setup(ow_pin)\n\nds18b20.setting({\n28:FF:FF:FF:FF:FF:FF:FF\n,\n28:FF:FF:FF:FF:FF:FF:FF\n}, 9)\n\n\n\n\nds18b20.setup()\n\n\nInitializes the onewire bus on the selected pin.\n\n\nSyntax\n\n\nds18b20.setup(OW_BUS_PIN)\n\n\nParameters\n\n\n\n\nOW_BUS_PIN\n\n\n1\n - \n12\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nlocal ow_pin = 3\nds18b20.setup(ow_pin)", 
            "title": "ds18b20"
        }, 
        {
            "location": "/en/modules/ds18b20/#ds18b20-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2017-06-11  fetchbot  fetchbot  ds18b20.c     This module provides access to the DS18B20 1-Wire digital thermometer. Note that NodeMCU offers both a C module (this one) and  a Lua module for this sensor . See  #2003  for a discussion on the respective merits of them.", 
            "title": "DS18B20 Module"
        }, 
        {
            "location": "/en/modules/ds18b20/#ds18b20read", 
            "text": "Issues a temperature conversion of all connected sensors on the onewire bus and returns the measurment results after a conversion delay in a callback function.\nThe returned measurements can be filtered through the ROM addresses passed as a table or by the family type.\nThe callback function gets invoked for every specified sensor.", 
            "title": "ds18b20.read()"
        }, 
        {
            "location": "/en/modules/ds18b20/#syntax", 
            "text": "ds18b20.read(CALLBACK, ROM[, FAMILY_ADDRESS])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ds18b20/#parameters", 
            "text": "CALLBACK  callback function executed for each sensor  e.g.  function(INDEX, ROM, RES, TEMP, TEMP_DEC, PAR) print(INDEX, ROM, RES, TEMP, TEMP_DEC, PAR) end    ROM  table which contains the addresses for the specified sensors, or left empty to perform a onewire bus search for all sensors  e.g.  {\"28:FF:FF:FF:FF:FF:FF:FF\",\"28:FF:FF:FF:FF:FF:FF:FF\"} ,  {}    FAMILY_ADDRESS  optional to limit the search for devices to a specific family type  e.g  0x28", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ds18b20/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ds18b20/#callback-function-parameters", 
            "text": "INDEX  index of the sensor on the bus  ROM  sensors 64-bit lasered rom code  28:FF:FF:FF:FF:FF:FF:FF  LSB, 8-bit family code, 48-bit serial number, MSB 8-bit crc    RES  temperature resolution  TEMP  temperature  TEMP_DEC  temperature decimals for integer firmware  PAR  sensor parasitic flag    Note  If using float firmware then  temp  is a floating point number. On an integer firmware, the final value has to be concatenated from  temp  and  temp_dec .", 
            "title": "Callback function parameters"
        }, 
        {
            "location": "/en/modules/ds18b20/#example", 
            "text": "local ow_pin = 3\nds18b20.setup(ow_pin)\n\n-- read all sensors and print all measurement results\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        print(ind,string.format( %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X ,string.match(rom, (%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+) )),res,temp,tdec,par)\n    end,{});\n\n-- read only sensors with family type 0x28 and print all measurement results\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        print(ind,string.format( %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X ,string.match(rom, (%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+) )),res,temp,tdec,par)\n    end,{},0x28);\n\n-- save device roms in a variable\nlocal addr = {}\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        addr[ind] = {string.format( %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X ,string.match(rom, (%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+) ))}\n    end,{});\n\n-- read only sensors listed in the variable addr\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        print(ind,string.format( %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X ,string.match(rom, (%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+) )),res,temp,tdec,par)\n    end,addr);\n\n-- print only parasitic sensors\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        if (par == 1) then\n            print(ind,string.format( %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X ,string.match(rom, (%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+) )),res,temp,tdec,par)\n        end\n    end,{});\n\n-- print if temperature is greater or less than a defined value\nds18b20.read(\n    function(ind,rom,res,temp,tdec,par)\n        if (t   25) then\n            print(ind,string.format( %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X ,string.match(rom, (%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+) )),res,temp,tdec,par)\n        end\n        if (t   20) then\n            print(ind,string.format( %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X ,string.match(rom, (%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+):(%d+) )),res,temp,tdec,par)\n        end\n    end,{});", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ds18b20/#ds18b20setting", 
            "text": "Configuration of the temperature resolution settings.", 
            "title": "ds18b20.setting()"
        }, 
        {
            "location": "/en/modules/ds18b20/#syntax_1", 
            "text": "ds18b20.setting(ROM, RES)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ds18b20/#parameters_1", 
            "text": "ROM  table which contains the addresses for the specified sensors, or empty for all sensors  e.g.  {\"28:FF:FF:FF:FF:FF:FF:FF\",\"28:FF:FF:FF:FF:FF:FF:FF\"} ,  {}    RES  temperature bit resolution  9  -  12", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ds18b20/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ds18b20/#example_1", 
            "text": "local ow_pin = 3\nds18b20.setup(ow_pin)\n\nds18b20.setting({ 28:FF:FF:FF:FF:FF:FF:FF , 28:FF:FF:FF:FF:FF:FF:FF }, 9)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ds18b20/#ds18b20setup", 
            "text": "Initializes the onewire bus on the selected pin.", 
            "title": "ds18b20.setup()"
        }, 
        {
            "location": "/en/modules/ds18b20/#syntax_2", 
            "text": "ds18b20.setup(OW_BUS_PIN)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ds18b20/#parameters_2", 
            "text": "OW_BUS_PIN  1  -  12", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ds18b20/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ds18b20/#example_2", 
            "text": "local ow_pin = 3\nds18b20.setup(ow_pin)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/encoder/", 
            "text": "encoder Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-02-26\n\n\nTerry Ellison\n\n\nTerry Ellison\n\n\nencoder.c\n\n\n\n\n\n\n\n\nThe encoder modules provides various functions for encoding and decoding byte data.\n\n\nencoder.toBase64()\n\n\nProvides a Base64 representation of a (binary) Lua string.\n\n\nSyntax\n\n\nb64 = encoder.toBase64(binary)\n\n\nParameters\n\n\nbinary\n input string to Base64 encode\n\n\nReturn\n\n\nA Base64 encoded string.\n\n\nExample\n\n\nprint(encoder.toBase64(crypto.hash(\nsha1\n,\nabc\n)))\n\n\n\n\nencoder.fromBase64()\n\n\nDecodes a Base64 representation of a (binary) Lua string back into the original string.  An error is\nthrown if the string is not a valid base64 encoding.\n\n\nSyntax\n\n\nbinary_string = encoder.toBase64(b64)\n\n\nParameters\n\n\nb64\n Base64 encoded input string \n\n\nReturn\n\n\nThe decoded Lua (binary) string.\n\n\nExample\n\n\nprint(encoder.fromBase64(encoder.toBase64(\nhello world\n)))\n\n\n\n\nencoder.toHex()\n\n\nProvides an ASCII hex representation of a (binary) Lua string. Each byte in the input string is\nrepresented as two hex characters in the output.\n\n\nSyntax\n\n\nhexstr = encoder.toHex(binary)\n\n\nParameters\n\n\nbinary\n input string to get hex representation for\n\n\nReturns\n\n\nAn ASCII hex string.\n\n\nExample\n\n\nprint(encoder.toHex(crypto.hash(\nsha1\n,\nabc\n)))\n\n\n\n\nencoder.fromHex()\n\n\nReturns the Lua binary string decode of a ASCII hex string. Each byte in the output string is\nrepresented as two hex characters in the input.  An error is thrown if the string is not a \nvalid base64 encoding.\n\n\nSyntax\n\n\nbinary = encoder.fromHex(hexstr)\n\n\nParameters\n\n\nhexstr\n  An ASCII hex string.\n\n\nReturns\n\n\nDecoded string of hex representation.\n\n\nExample\n\n\nprint(encoder.fromHex(\n6a6a6a\n)))", 
            "title": "encoder"
        }, 
        {
            "location": "/en/modules/encoder/#encoder-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-02-26  Terry Ellison  Terry Ellison  encoder.c     The encoder modules provides various functions for encoding and decoding byte data.", 
            "title": "encoder Module"
        }, 
        {
            "location": "/en/modules/encoder/#encodertobase64", 
            "text": "Provides a Base64 representation of a (binary) Lua string.", 
            "title": "encoder.toBase64()"
        }, 
        {
            "location": "/en/modules/encoder/#syntax", 
            "text": "b64 = encoder.toBase64(binary)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/encoder/#parameters", 
            "text": "binary  input string to Base64 encode", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/encoder/#return", 
            "text": "A Base64 encoded string.", 
            "title": "Return"
        }, 
        {
            "location": "/en/modules/encoder/#example", 
            "text": "print(encoder.toBase64(crypto.hash( sha1 , abc )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/encoder/#encoderfrombase64", 
            "text": "Decodes a Base64 representation of a (binary) Lua string back into the original string.  An error is\nthrown if the string is not a valid base64 encoding.", 
            "title": "encoder.fromBase64()"
        }, 
        {
            "location": "/en/modules/encoder/#syntax_1", 
            "text": "binary_string = encoder.toBase64(b64)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/encoder/#parameters_1", 
            "text": "b64  Base64 encoded input string", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/encoder/#return_1", 
            "text": "The decoded Lua (binary) string.", 
            "title": "Return"
        }, 
        {
            "location": "/en/modules/encoder/#example_1", 
            "text": "print(encoder.fromBase64(encoder.toBase64( hello world )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/encoder/#encodertohex", 
            "text": "Provides an ASCII hex representation of a (binary) Lua string. Each byte in the input string is\nrepresented as two hex characters in the output.", 
            "title": "encoder.toHex()"
        }, 
        {
            "location": "/en/modules/encoder/#syntax_2", 
            "text": "hexstr = encoder.toHex(binary)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/encoder/#parameters_2", 
            "text": "binary  input string to get hex representation for", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/encoder/#returns", 
            "text": "An ASCII hex string.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/encoder/#example_2", 
            "text": "print(encoder.toHex(crypto.hash( sha1 , abc )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/encoder/#encoderfromhex", 
            "text": "Returns the Lua binary string decode of a ASCII hex string. Each byte in the output string is\nrepresented as two hex characters in the input.  An error is thrown if the string is not a \nvalid base64 encoding.", 
            "title": "encoder.fromHex()"
        }, 
        {
            "location": "/en/modules/encoder/#syntax_3", 
            "text": "binary = encoder.fromHex(hexstr)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/encoder/#parameters_3", 
            "text": "hexstr   An ASCII hex string.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/encoder/#returns_1", 
            "text": "Decoded string of hex representation.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/encoder/#example_3", 
            "text": "print(encoder.fromHex( 6a6a6a )))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/enduser-setup/", 
            "text": "enduser setup Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-09-02\n\n\nRobert Foss\n\n\nRobert Foss\n\n\nenduser_setup.c\n\n\n\n\n\n\n\n\nThis module provides a simple way of configuring ESP8266 chips without using a serial interface or pre-programming WiFi credentials onto the chip.\n\n\n\n\nAfter running \nenduser_setup.start()\n, a wireless network named \"SetupGadget_XXXXXX\" will start (this prefix can be overridden in \nuser_config.h\n by defining \n\nENDUSER_SETUP_AP_SSID\n). Connect to that SSID and then navigate to the root\nof any website (e.g., \nhttp://example.com/\n will work, but do not use \n.local\n domains because it will fail on iOS). A web page similar to the picture above will load, allowing the \nend user to provide their Wi-Fi information.\n\n\nAfter an IP address has been successfully obtained, then this module will stop as if \nenduser_setup.stop()\n had been called. There is a 10-second delay before\nteardown to allow connected clients to obtain a last status message while the SoftAP is still active.\n\n\nAlternative HTML can be served by placing a file called \nenduser_setup.html\n on the filesystem. Everything needed by the web page must be included in this one file. This file will be kept \nin RAM, so keep it as small as possible. The file can be gzip'd ahead of time to reduce the size (i.e., using \ngzip -n\n or \nzopfli\n), and when served, the End User Setup module will add \nthe appropriate \nContent-Encoding\n header to the response. \n\n\nNote: If gzipped, the file can also be named \nenduser_setup.html.gz\n for semantic purposes. Gzip encoding is determined by the file's contents, not the filename.\n\n\nThe following HTTP endpoints exist:\n\n\n\n\n\n\n\n\nEndpoint\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n/\n\n\nReturns HTML for the web page. Will return the contents of \nenduser_setup.html\n if it exists on the filesystem, otherwise will return a page embedded into the firmware image.\n\n\n\n\n\n\n/aplist\n\n\nForces the ESP8266 to perform a site survey across all channels, reporting access points that it can find. Return payload is a JSON array: \n[{\"ssid\":\"foobar\",\"rssi\":-36,\"chan\":3}]\n\n\n\n\n\n\n/generate_204\n\n\nReturns a HTTP 204 status (expected by certain Android clients during Wi-Fi connectivity checks)\n\n\n\n\n\n\n/status\n\n\nReturns plaintext status description, used by the web page\n\n\n\n\n\n\n/status.json\n\n\nReturns a JSON payload containing the ESP8266's chip id in hexadecimal format and the status code: 0=Idle, 1=Connecting, 2=Wrong Password, 3=Network not Found, 4=Failed, 5=Success\n\n\n\n\n\n\n/setwifi\n\n\nEndpoint intended for services to use for setting the wifi credentials. Identical to \n/update\n except returns the same payload as \n/status.json\n instead of redirecting to \n/\n.\n\n\n\n\n\n\n/update\n\n\nForm submission target. Example: \nhttp://example.com/update?wifi_ssid=foobar\nwifi_password=CorrectHorseBatteryStaple\n. Must be a GET request. Will redirect to \n/\n when complete.\n\n\n\n\n\n\n\n\nenduser_setup.manual()\n\n\nControls whether manual AP configuration is used.\n\n\nBy default the \nenduser_setup\n module automatically configures an open access point when starting, and stops it when the device has been successfully joined to a WiFi network. If manual mode has been enabled, neither of this is done. The device must be manually configured for \nwifi.SOFTAP\n mode prior to calling \nenduser_setup.start()\n. Additionally, the portal is not stopped after the device has successfully joined to a WiFi network.\n\n\nSyntax\n\n\nenduser_setup.manual([on_off])\n\n\nParameters\n\n\n\n\non_off\n a boolean value indicating whether to use manual mode; if not given, the function only returns the current setting.\n\n\n\n\nReturns\n\n\nThe current setting, true if manual mode is enabled, false if it is not.\n\n\nExample\n\n\nwifi.setmode(wifi.STATIONAP)\nwifi.ap.config({ssid=\nMyPersonalSSID\n, auth=wifi.OPEN})\nenduser_setup.manual(true)\nenduser_setup.start(\n  function()\n    print(\nConnected to wifi as:\n .. wifi.sta.getip())\n  end,\n  function(err, str)\n    print(\nenduser_setup: Err #\n .. err .. \n: \n .. str)\n  end\n);\n\n\n\n\nenduser_setup.start()\n\n\nStarts the captive portal. \n\n\nNote: Calling start() while EUS is already running is an error, and will result in stop() to be invoked to shut down EUS.\n\n\nSyntax\n\n\nenduser_setup.start([onConnected()], [onError(err_num, string)], [onDebug(string)])\n\n\nParameters\n\n\n\n\nonConnected()\n callback will be fired when an IP-address has been obtained, just before the enduser_setup module will terminate itself\n\n\nonError()\n callback will be fired if an error is encountered. \nerr_num\n is a number describing the error, and \nstring\n contains a description of the error.\n\n\nonDebug()\n callback is disabled by default (controlled by \n#define ENDUSER_SETUP_DEBUG_ENABLE\n in \nenduser_setup.c\n). It is intended to be used to find internal issues in the module. \nstring\n contains a description of what is going on.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nenduser_setup.start(\n  function()\n    print(\nConnected to wifi as:\n .. wifi.sta.getip())\n  end,\n  function(err, str)\n    print(\nenduser_setup: Err #\n .. err .. \n: \n .. str)\n  end,\n  print -- Lua print function can serve as the debug callback\n);\n\n\n\n\nenduser_setup.stop()\n\n\nStops the captive portal.\n\n\nSyntax\n\n\nenduser_setup.stop()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil", 
            "title": "enduser setup"
        }, 
        {
            "location": "/en/modules/enduser-setup/#enduser-setup-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-09-02  Robert Foss  Robert Foss  enduser_setup.c     This module provides a simple way of configuring ESP8266 chips without using a serial interface or pre-programming WiFi credentials onto the chip.   After running  enduser_setup.start() , a wireless network named \"SetupGadget_XXXXXX\" will start (this prefix can be overridden in  user_config.h  by defining  ENDUSER_SETUP_AP_SSID ). Connect to that SSID and then navigate to the root\nof any website (e.g.,  http://example.com/  will work, but do not use  .local  domains because it will fail on iOS). A web page similar to the picture above will load, allowing the \nend user to provide their Wi-Fi information.  After an IP address has been successfully obtained, then this module will stop as if  enduser_setup.stop()  had been called. There is a 10-second delay before\nteardown to allow connected clients to obtain a last status message while the SoftAP is still active.  Alternative HTML can be served by placing a file called  enduser_setup.html  on the filesystem. Everything needed by the web page must be included in this one file. This file will be kept \nin RAM, so keep it as small as possible. The file can be gzip'd ahead of time to reduce the size (i.e., using  gzip -n  or  zopfli ), and when served, the End User Setup module will add \nthe appropriate  Content-Encoding  header to the response.   Note: If gzipped, the file can also be named  enduser_setup.html.gz  for semantic purposes. Gzip encoding is determined by the file's contents, not the filename.  The following HTTP endpoints exist:     Endpoint  Description      /  Returns HTML for the web page. Will return the contents of  enduser_setup.html  if it exists on the filesystem, otherwise will return a page embedded into the firmware image.    /aplist  Forces the ESP8266 to perform a site survey across all channels, reporting access points that it can find. Return payload is a JSON array:  [{\"ssid\":\"foobar\",\"rssi\":-36,\"chan\":3}]    /generate_204  Returns a HTTP 204 status (expected by certain Android clients during Wi-Fi connectivity checks)    /status  Returns plaintext status description, used by the web page    /status.json  Returns a JSON payload containing the ESP8266's chip id in hexadecimal format and the status code: 0=Idle, 1=Connecting, 2=Wrong Password, 3=Network not Found, 4=Failed, 5=Success    /setwifi  Endpoint intended for services to use for setting the wifi credentials. Identical to  /update  except returns the same payload as  /status.json  instead of redirecting to  / .    /update  Form submission target. Example:  http://example.com/update?wifi_ssid=foobar wifi_password=CorrectHorseBatteryStaple . Must be a GET request. Will redirect to  /  when complete.", 
            "title": "enduser setup Module"
        }, 
        {
            "location": "/en/modules/enduser-setup/#enduser_setupmanual", 
            "text": "Controls whether manual AP configuration is used.  By default the  enduser_setup  module automatically configures an open access point when starting, and stops it when the device has been successfully joined to a WiFi network. If manual mode has been enabled, neither of this is done. The device must be manually configured for  wifi.SOFTAP  mode prior to calling  enduser_setup.start() . Additionally, the portal is not stopped after the device has successfully joined to a WiFi network.", 
            "title": "enduser_setup.manual()"
        }, 
        {
            "location": "/en/modules/enduser-setup/#syntax", 
            "text": "enduser_setup.manual([on_off])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/enduser-setup/#parameters", 
            "text": "on_off  a boolean value indicating whether to use manual mode; if not given, the function only returns the current setting.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/enduser-setup/#returns", 
            "text": "The current setting, true if manual mode is enabled, false if it is not.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/enduser-setup/#example", 
            "text": "wifi.setmode(wifi.STATIONAP)\nwifi.ap.config({ssid= MyPersonalSSID , auth=wifi.OPEN})\nenduser_setup.manual(true)\nenduser_setup.start(\n  function()\n    print( Connected to wifi as:  .. wifi.sta.getip())\n  end,\n  function(err, str)\n    print( enduser_setup: Err #  .. err ..  :   .. str)\n  end\n);", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/enduser-setup/#enduser_setupstart", 
            "text": "Starts the captive portal.   Note: Calling start() while EUS is already running is an error, and will result in stop() to be invoked to shut down EUS.", 
            "title": "enduser_setup.start()"
        }, 
        {
            "location": "/en/modules/enduser-setup/#syntax_1", 
            "text": "enduser_setup.start([onConnected()], [onError(err_num, string)], [onDebug(string)])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/enduser-setup/#parameters_1", 
            "text": "onConnected()  callback will be fired when an IP-address has been obtained, just before the enduser_setup module will terminate itself  onError()  callback will be fired if an error is encountered.  err_num  is a number describing the error, and  string  contains a description of the error.  onDebug()  callback is disabled by default (controlled by  #define ENDUSER_SETUP_DEBUG_ENABLE  in  enduser_setup.c ). It is intended to be used to find internal issues in the module.  string  contains a description of what is going on.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/enduser-setup/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/enduser-setup/#example_1", 
            "text": "enduser_setup.start(\n  function()\n    print( Connected to wifi as:  .. wifi.sta.getip())\n  end,\n  function(err, str)\n    print( enduser_setup: Err #  .. err ..  :   .. str)\n  end,\n  print -- Lua print function can serve as the debug callback\n);", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/enduser-setup/#enduser_setupstop", 
            "text": "Stops the captive portal.", 
            "title": "enduser_setup.stop()"
        }, 
        {
            "location": "/en/modules/enduser-setup/#syntax_2", 
            "text": "enduser_setup.stop()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/enduser-setup/#parameters_2", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/enduser-setup/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/", 
            "text": "file Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-22\n\n\nZeroday\n\n\nZeroday\n\n\nfile.c\n\n\n\n\n\n\n\n\nThe file module provides access to the file system and its individual files.\n\n\nThe file system is a flat file system, with no notion of subdirectories/folders.\n\n\nBesides the SPIFFS file system on internal flash, this module can also access FAT partitions on an external SD card if \nFatFS is enabled\n.\n\n\n-- open file in flash:\nif file.open(\ninit.lua\n) then\n  print(file.read())\n  file.close()\nend\n\n-- or with full pathspec\nfile.open(\n/FLASH/init.lua\n)\n\n-- open file on SD card\nif file.open(\n/SD0/somefile.txt\n) then\n  print(file.read())\n  file.close()\nend\n\n\n\n\nfile.chdir()\n\n\nChange current directory (and drive). This will be used when no drive/directory is prepended to filenames.\n\n\nCurrent directory defaults to the root of internal SPIFFS (\n/FLASH\n) after system start.\n\n\n\n\nNote\n\n\nFunction is only available when \nFatFS support\n is compiled into the firmware.\n\n\n\n\nSyntax\n\n\nfile.chdir(dir)\n\n\nParameters\n\n\ndir\n directory name - \n/FLASH\n, \n/SD0\n, \n/SD1\n, etc.\n\n\nReturns\n\n\ntrue\n on success, \nfalse\n otherwise\n\n\nfile.exists()\n\n\nDetermines whether the specified file exists.\n\n\nSyntax\n\n\nfile.exists(filename)\n\n\nParameters\n\n\n\n\nfilename\n file to check\n\n\n\n\nReturns\n\n\ntrue of the file exists (even if 0 bytes in size), and false if it does not exist\n\n\nExample\n\n\nfiles = file.list()\nif files[\ndevice.config\n] then\n    print(\nConfig file exists\n)\nend\n\nif file.exists(\ndevice.config\n) then\n    print(\nConfig file exists\n)\nend\n\n\n\n\nSee also\n\n\nfile.list()\n\n\nfile.format()\n\n\nFormat the file system. Completely erases any existing file system and writes a new one. Depending on the size of the flash chip in the ESP, this may take several seconds.\n\n\n\n\nNote\n\n\nFunction is not supported for SD cards.\n\n\n\n\nSyntax\n\n\nfile.format()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nfile.remove()\n\n\nfile.fscfg ()\n\n\nReturns the flash address and physical size of the file system area, in bytes.\n\n\n\n\nNote\n\n\nFunction is not supported for SD cards.\n\n\n\n\nSyntax\n\n\nfile.fscfg()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nflash address\n (number)\n\n\nsize\n (number)\n\n\n\n\nExample\n\n\nprint(string.format(\n0x%x\n, file.fscfg()))\n\n\n\n\nfile.fsinfo()\n\n\nReturn size information for the file system. The unit is Byte for SPIFFS and kByte for FatFS.\n\n\nSyntax\n\n\nfile.fsinfo()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nremaining\n (number)\n\n\nused\n      (number)\n\n\ntotal\n     (number)\n\n\n\n\nExample\n\n\n-- get file system info\nremaining, used, total=file.fsinfo()\nprint(\n\\nFile system info:\\nTotal : \n..total..\n (k)Bytes\\nUsed : \n..used..\n (k)Bytes\\nRemain: \n..remaining..\n (k)Bytes\\n\n)\n\n\n\n\nfile.list()\n\n\nLists all files in the file system.\n\n\nSyntax\n\n\nfile.list()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\na lua table which contains the {file name: file size} pairs\n\n\nExample\n\n\nl = file.list();\nfor k,v in pairs(l) do\n  print(\nname:\n..k..\n, size:\n..v)\nend\n\n\n\n\nfile.mount()\n\n\nMounts a FatFs volume on SD card.\n\n\n\n\nNote\n\n\nFunction is only available when \nFatFS support\n is compiled into the firmware and it is not supported for internal flash.\n\n\n\n\nSyntax\n\n\nfile.mount(ldrv[, pin])\n\n\nParameters\n\n\n\n\nldrv\n name of the logical drive, \n/SD0\n, \n/SD1\n, etc.\n\n\npin\n 1~12, IO index for SS/CS, defaults to 8 if omitted.\n\n\n\n\nReturns\n\n\nVolume object\n\n\nExample\n\n\nvol = file.mount(\n/SD0\n)\nvol:umount()\n\n\n\n\nfile.on()\n\n\nRegisters callback functions.\n\n\nTrigger events are:\n\n\n\n\nrtc\n deliver current date \n time to the file system. Function is expected to return a table containing the fields \nyear\n, \nmon\n, \nday\n, \nhour\n, \nmin\n, \nsec\n of current date and time. Not supported for internal flash.\n\n\n\n\nSyntax\n\n\nfile.on(event[, function()])\n\n\nParameters\n\n\n\n\nevent\n string\n\n\nfunction()\n callback function. Unregisters the callback if \nfunction()\n is omitted.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nsntp.sync(server_ip,\n  function()\n    print(\nsntp time sync ok\n)\n    file.on(\nrtc\n,\n      function()\n        return rtctime.epoch2cal(rtctime.get())\n      end)\n  end)\n\n\n\n\nSee also\n\n\nrtctime.epoch2cal()\n\n\nfile.open()\n\n\nOpens a file for access, potentially creating it (for write modes).\n\n\nWhen done with the file, it must be closed using \nfile.close()\n.\n\n\nSyntax\n\n\nfile.open(filename, mode)\n\n\nParameters\n\n\n\n\nfilename\n file to be opened\n\n\nmode\n:\n\n\n\"r\": read mode (the default)\n\n\n\"w\": write mode\n\n\n\"a\": append mode\n\n\n\"r+\": update mode, all previous data is preserved\n\n\n\"w+\": update mode, all previous data is erased\n\n\n\"a+\": append update mode, previous data is preserved, writing is only allowed at the end of file\n\n\n\n\n\n\n\n\nReturns\n\n\nfile object if file opened ok. \nnil\n if file not opened, or not exists (read modes).\n\n\nExample (basic model)\n\n\n-- open 'init.lua', print the first line.\nif file.open(\ninit.lua\n, \nr\n) then\n  print(file.readline())\n  file.close()\nend\n\n\n\n\nExample (object model)\n\n\n-- open 'init.lua', print the first line.\nfd = file.open(\ninit.lua\n, \nr\n)\nif fd then\n  print(fd:readline())\n  fd:close(); fd = nil\nend\n\n\n\n\nSee also\n\n\n\n\nfile.close()\n\n\nfile.readline()\n\n\n\n\nfile.remove()\n\n\nRemove a file from the file system. The file must not be currently open.\n\n\nSyntax\n\n\nfile.remove(filename)\n\n\nParameters\n\n\nfilename\n file to remove\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- remove \nfoo.lua\n from file system.\nfile.remove(\nfoo.lua\n)\n\n\n\n\nSee also\n\n\nfile.open()\n\n\nfile.rename()\n\n\nRenames a file. If a file is currently open, it will be closed first.\n\n\nSyntax\n\n\nfile.rename(oldname, newname)\n\n\nParameters\n\n\n\n\noldname\n old file name\n\n\nnewname\n new file name\n\n\n\n\nReturns\n\n\ntrue\n on success, \nfalse\n on error.\n\n\nExample\n\n\n-- rename file 'temp.lua' to 'init.lua'.\nfile.rename(\ntemp.lua\n,\ninit.lua\n)\n\n\n\n\nfile.stat()\n\n\nGet attribtues of a file or directory in a table. Elements of the table are:\n\n\n\n\nsize\n file size in bytes\n\n\nname\n file name\n\n\n\n\ntime\n table with time stamp information. Default is 1970-01-01 00:00:00 in case time stamps are not supported (on SPIFFS).\n\n\n\n\nyear\n\n\nmon\n\n\nday\n\n\nhour\n\n\nmin\n\n\nsec\n\n\n\n\n\n\n\n\nis_dir\n flag \ntrue\n if item is a directory, otherwise \nfalse\n\n\n\n\nis_rdonly\n flag \ntrue\n if item is read-only, otherwise \nfalse\n\n\nis_hidden\n flag \ntrue\n if item is hidden, otherwise \nfalse\n\n\nis_sys\n flag \ntrue\n if item is system, otherwise \nfalse\n\n\nis_arch\n flag \ntrue\n if item is archive, otherwise \nfalse\n\n\n\n\nSyntax\n\n\nfile.stat(filename)\n\n\nParameters\n\n\nfilename\n file name\n\n\nReturns\n\n\ntable containing file attributes\n\n\nExample\n\n\ns = file.stat(\n/SD0/myfile\n)\nprint(\nname: \n .. s.name)\nprint(\nsize: \n .. s.size)\n\nt = s.time\nprint(string.format(\n%02d:%02d:%02d\n, t.hour, t.min, t.sec))\nprint(string.format(\n%04d-%02d-%02d\n, t.year, t.mon, t.day))\n\nif s.is_dir then print(\nis directory\n) else print(\nis file\n) end\nif s.is_rdonly then print(\nis read-only\n) else print(\nis writable\n) end\nif s.is_hidden then print(\nis hidden\n) else print(\nis not hidden\n) end\nif s.is_sys then print(\nis system\n) else print(\nis not system\n) end\nif s.is_arch then print(\nis archive\n) else print(\nis not archive\n) end\n\ns = nil\nt = nil\n\n\n\n\nFile access functions\n\n\nThe \nfile\n module provides several functions to access the content of a file after it has been opened with \nfile.open()\n. They can be used as part of a basic model or an object model:\n\n\nBasic model\n\n\nIn the basic model there is max one file opened at a time. The file access functions operate on this file per default. If another file is opened, the previous default file needs to be closed beforehand.\n\n\n-- open 'init.lua', print the first line.\nif file.open(\ninit.lua\n, \nr\n) then\n  print(file.readline())\n  file.close()\nend\n\n\n\n\nObject model\n\n\nFiles are represented by file objects which are created by \nfile.open()\n. File access functions are available as methods of this object, and multiple file objects can coexist.\n\n\nsrc = file.open(\ninit.lua\n, \nr\n)\nif src then\n  dest = file.open(\ncopy.lua\n, \nw\n)\n  if dest then\n    local line\n    repeat\n      line = src:read()\n      if line then\n        dest:write(line)\n      end\n    until line == nil\n    dest:close(); dest = nil\n  end\n  src:close(); dest = nil\nend\n\n\n\n\n\n\nAttention\n\n\nIt is recommended to use only one single model within the application. Concurrent use of both models can yield unpredictable behavior: Closing the default file from basic model will also close the correspoding file object. Closing a file from object model will also close the default file if they are the same file.\n\n\n\n\n\n\nNote\n\n\nThe maximum number of open files on SPIFFS is determined at compile time by \nSPIFFS_MAX_OPEN_FILES\n in \nuser_config.h\n.\n\n\n\n\nfile.close(), file.obj:close()\n\n\nCloses the open file, if any.\n\n\nSyntax\n\n\nfile.close()\n\n\nfd:close()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nfile.open()\n\n\nfile.flush(), file.obj:flush()\n\n\nFlushes any pending writes to the file system, ensuring no data is lost on a restart. Closing the open file using \nfile.close()\n / \nfd:close()\n performs an implicit flush as well.\n\n\nSyntax\n\n\nfile.flush()\n\n\nfd:flush()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nExample (basic model)\n\n\n-- open 'init.lua' in 'a+' mode\nif file.open(\ninit.lua\n, \na+\n) then\n  -- write 'foo bar' to the end of the file\n  file.write('foo bar')\n  file.flush()\n  -- write 'baz' too\n  file.write('baz')\n  file.close()\nend\n\n\n\n\nSee also\n\n\nfile.close()\n / \nfile.obj:close()\n\n\nfile.read(), file.obj:read()\n\n\nRead content from the open file.\n\n\n\n\nNote\n\n\nThe function temporarily allocates 2 * (number of requested bytes) on the heap for buffering and processing the read data. Default chunk size (\nFILE_READ_CHUNK\n) is 1024 bytes and is regarded to be safe. Pushing this by 4x or more can cause heap overflows depending on the application. Consider this when selecting a value for parameter \nn_or_char\n.\n\n\n\n\nSyntax\n\n\nfile.read([n_or_char])\n\n\nfd:read([n_or_char])\n\n\nParameters\n\n\n\n\nn_or_char\n:\n\n\nif nothing passed in, then read up to \nFILE_READ_CHUNK\n bytes or the entire file (whichever is smaller).\n\n\nif passed a number \nn\n, then read up to \nn\n bytes or the entire file (whichever is smaller).\n\n\nif passed a string containing the single character \nchar\n, then read until \nchar\n appears next in the file, \nFILE_READ_CHUNK\n bytes have been read, or EOF is reached.\n\n\n\n\n\n\n\n\nReturns\n\n\nFile content as a string, or nil when EOF\n\n\nExample (basic model)\n\n\n-- print the first line of 'init.lua'\nif file.open(\ninit.lua\n, \nr\n) then\n  print(file.read('\\n'))\n  file.close()\nend\n\n\n\n\nExample (object model)\n\n\n-- print the first 5 bytes of 'init.lua'\nfd = file.open(\ninit.lua\n, \nr\n)\nif fd then\n  print(fd:read(5))\n  fd:close(); fd = nil\nend\n\n\n\n\nSee also\n\n\n\n\nfile.open()\n\n\nfile.readline()\n / \nfile.obj:readline()\n\n\n\n\nfile.readline(), file.obj:readline()\n\n\nRead the next line from the open file. Lines are defined as zero or more bytes ending with a EOL ('\\n') byte. If the next line is longer than 1024, this function only returns the first 1024 bytes.\n\n\nSyntax\n\n\nfile.readline()\n\n\nfd:readline()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nFile content in string, line by line, including EOL('\\n'). Return \nnil\n when EOF.\n\n\nExample (basic model)\n\n\n-- print the first line of 'init.lua'\nif file.open(\ninit.lua\n, \nr\n) then\n  print(file.readline())\n  file.close()\nend\n\n\n\n\nSee also\n\n\n\n\nfile.open()\n\n\nfile.close()\n / \nfile.obj:close()\n\n\nfile.read()\n / \nfile.obj:read()\n\n\n\n\nfile.seek(), file.obj:seek()\n\n\nSets and gets the file position, measured from the beginning of the file, to the position given by offset plus a base specified by the string whence.\n\n\nSyntax\n\n\nfile.seek([whence [, offset]])\n\n\nfd:seek([whence [, offset]])\n\n\nParameters\n\n\n\n\nwhence\n\n\n\"set\": base is position 0 (beginning of the file)\n\n\n\"cur\": base is current position (default value)\n\n\n\"end\": base is end of file\n\n\n\n\n\n\noffset\n default 0\n\n\n\n\nIf no parameters are given, the function simply returns the current file offset.\n\n\nReturns\n\n\nthe resulting file position, or \nnil\n on error\n\n\nExample (basic model)\n\n\nif file.open(\ninit.lua\n, \nr\n) then\n  -- skip the first 5 bytes of the file\n  file.seek(\nset\n, 5)\n  print(file.readline())\n  file.close()\nend\n\n\n\n\nSee also\n\n\nfile.open()\n\n\nfile.write(), file.obj:write()\n\n\nWrite a string to the open file.\n\n\nSyntax\n\n\nfile.write(string)\n\n\nfd:write(string)\n\n\nParameters\n\n\nstring\n content to be write to file\n\n\nReturns\n\n\ntrue\n if the write is ok, \nnil\n on error\n\n\nExample (basic model)\n\n\n-- open 'init.lua' in 'a+' mode\nif file.open(\ninit.lua\n, \na+\n) then\n  -- write 'foo bar' to the end of the file\n  file.write('foo bar')\n  file.close()\nend\n\n\n\n\nExample (object model)\n\n\n-- open 'init.lua' in 'a+' mode\nfd = file.open(\ninit.lua\n, \na+\n)\nif fd then\n  -- write 'foo bar' to the end of the file\n  fd:write('foo bar')\n  fd:close()\nend\n\n\n\n\nSee also\n\n\n\n\nfile.open()\n\n\nfile.writeline()\n / \nfile.obj:writeline()\n\n\n\n\nfile.writeline(), file.obj:writeline()\n\n\nWrite a string to the open file and append '\\n' at the end.\n\n\nSyntax\n\n\nfile.writeline(string)\n\n\nfd:writeline(string)\n\n\nParameters\n\n\nstring\n content to be write to file\n\n\nReturns\n\n\ntrue\n if write ok, \nnil\n on error\n\n\nExample (basic model)\n\n\n-- open 'init.lua' in 'a+' mode\nif file.open(\ninit.lua\n, \na+\n) then\n  -- write 'foo bar' to the end of the file\n  file.writeline('foo bar')\n  file.close()\nend\n\n\n\n\nSee also\n\n\n\n\nfile.open()\n\n\nfile.readline()\n / \nfile.obj:readline()", 
            "title": "file"
        }, 
        {
            "location": "/en/modules/file/#file-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-22  Zeroday  Zeroday  file.c     The file module provides access to the file system and its individual files.  The file system is a flat file system, with no notion of subdirectories/folders.  Besides the SPIFFS file system on internal flash, this module can also access FAT partitions on an external SD card if  FatFS is enabled .  -- open file in flash:\nif file.open( init.lua ) then\n  print(file.read())\n  file.close()\nend\n\n-- or with full pathspec\nfile.open( /FLASH/init.lua )\n\n-- open file on SD card\nif file.open( /SD0/somefile.txt ) then\n  print(file.read())\n  file.close()\nend", 
            "title": "file Module"
        }, 
        {
            "location": "/en/modules/file/#filechdir", 
            "text": "Change current directory (and drive). This will be used when no drive/directory is prepended to filenames.  Current directory defaults to the root of internal SPIFFS ( /FLASH ) after system start.   Note  Function is only available when  FatFS support  is compiled into the firmware.", 
            "title": "file.chdir()"
        }, 
        {
            "location": "/en/modules/file/#syntax", 
            "text": "file.chdir(dir)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters", 
            "text": "dir  directory name -  /FLASH ,  /SD0 ,  /SD1 , etc.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns", 
            "text": "true  on success,  false  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#fileexists", 
            "text": "Determines whether the specified file exists.", 
            "title": "file.exists()"
        }, 
        {
            "location": "/en/modules/file/#syntax_1", 
            "text": "file.exists(filename)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_1", 
            "text": "filename  file to check", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_1", 
            "text": "true of the file exists (even if 0 bytes in size), and false if it does not exist", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example", 
            "text": "files = file.list()\nif files[ device.config ] then\n    print( Config file exists )\nend\n\nif file.exists( device.config ) then\n    print( Config file exists )\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/file/#see-also", 
            "text": "file.list()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#fileformat", 
            "text": "Format the file system. Completely erases any existing file system and writes a new one. Depending on the size of the flash chip in the ESP, this may take several seconds.   Note  Function is not supported for SD cards.", 
            "title": "file.format()"
        }, 
        {
            "location": "/en/modules/file/#syntax_2", 
            "text": "file.format()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_2", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#see-also_1", 
            "text": "file.remove()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#filefscfg", 
            "text": "Returns the flash address and physical size of the file system area, in bytes.   Note  Function is not supported for SD cards.", 
            "title": "file.fscfg ()"
        }, 
        {
            "location": "/en/modules/file/#syntax_3", 
            "text": "file.fscfg()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_3", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_3", 
            "text": "flash address  (number)  size  (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example_1", 
            "text": "print(string.format( 0x%x , file.fscfg()))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/file/#filefsinfo", 
            "text": "Return size information for the file system. The unit is Byte for SPIFFS and kByte for FatFS.", 
            "title": "file.fsinfo()"
        }, 
        {
            "location": "/en/modules/file/#syntax_4", 
            "text": "file.fsinfo()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_4", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_4", 
            "text": "remaining  (number)  used       (number)  total      (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example_2", 
            "text": "-- get file system info\nremaining, used, total=file.fsinfo()\nprint( \\nFile system info:\\nTotal :  ..total..  (k)Bytes\\nUsed :  ..used..  (k)Bytes\\nRemain:  ..remaining..  (k)Bytes\\n )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/file/#filelist", 
            "text": "Lists all files in the file system.", 
            "title": "file.list()"
        }, 
        {
            "location": "/en/modules/file/#syntax_5", 
            "text": "file.list()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_5", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_5", 
            "text": "a lua table which contains the {file name: file size} pairs", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example_3", 
            "text": "l = file.list();\nfor k,v in pairs(l) do\n  print( name: ..k.. , size: ..v)\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/file/#filemount", 
            "text": "Mounts a FatFs volume on SD card.   Note  Function is only available when  FatFS support  is compiled into the firmware and it is not supported for internal flash.", 
            "title": "file.mount()"
        }, 
        {
            "location": "/en/modules/file/#syntax_6", 
            "text": "file.mount(ldrv[, pin])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_6", 
            "text": "ldrv  name of the logical drive,  /SD0 ,  /SD1 , etc.  pin  1~12, IO index for SS/CS, defaults to 8 if omitted.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_6", 
            "text": "Volume object", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example_4", 
            "text": "vol = file.mount( /SD0 )\nvol:umount()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/file/#fileon", 
            "text": "Registers callback functions.  Trigger events are:   rtc  deliver current date   time to the file system. Function is expected to return a table containing the fields  year ,  mon ,  day ,  hour ,  min ,  sec  of current date and time. Not supported for internal flash.", 
            "title": "file.on()"
        }, 
        {
            "location": "/en/modules/file/#syntax_7", 
            "text": "file.on(event[, function()])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_7", 
            "text": "event  string  function()  callback function. Unregisters the callback if  function()  is omitted.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_7", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example_5", 
            "text": "sntp.sync(server_ip,\n  function()\n    print( sntp time sync ok )\n    file.on( rtc ,\n      function()\n        return rtctime.epoch2cal(rtctime.get())\n      end)\n  end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/file/#see-also_2", 
            "text": "rtctime.epoch2cal()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#fileopen", 
            "text": "Opens a file for access, potentially creating it (for write modes).  When done with the file, it must be closed using  file.close() .", 
            "title": "file.open()"
        }, 
        {
            "location": "/en/modules/file/#syntax_8", 
            "text": "file.open(filename, mode)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_8", 
            "text": "filename  file to be opened  mode :  \"r\": read mode (the default)  \"w\": write mode  \"a\": append mode  \"r+\": update mode, all previous data is preserved  \"w+\": update mode, all previous data is erased  \"a+\": append update mode, previous data is preserved, writing is only allowed at the end of file", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_8", 
            "text": "file object if file opened ok.  nil  if file not opened, or not exists (read modes).", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example-basic-model", 
            "text": "-- open 'init.lua', print the first line.\nif file.open( init.lua ,  r ) then\n  print(file.readline())\n  file.close()\nend", 
            "title": "Example (basic model)"
        }, 
        {
            "location": "/en/modules/file/#example-object-model", 
            "text": "-- open 'init.lua', print the first line.\nfd = file.open( init.lua ,  r )\nif fd then\n  print(fd:readline())\n  fd:close(); fd = nil\nend", 
            "title": "Example (object model)"
        }, 
        {
            "location": "/en/modules/file/#see-also_3", 
            "text": "file.close()  file.readline()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#fileremove", 
            "text": "Remove a file from the file system. The file must not be currently open.", 
            "title": "file.remove()"
        }, 
        {
            "location": "/en/modules/file/#syntax_9", 
            "text": "file.remove(filename)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_9", 
            "text": "filename  file to remove", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_9", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example_6", 
            "text": "-- remove  foo.lua  from file system.\nfile.remove( foo.lua )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/file/#see-also_4", 
            "text": "file.open()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#filerename", 
            "text": "Renames a file. If a file is currently open, it will be closed first.", 
            "title": "file.rename()"
        }, 
        {
            "location": "/en/modules/file/#syntax_10", 
            "text": "file.rename(oldname, newname)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_10", 
            "text": "oldname  old file name  newname  new file name", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_10", 
            "text": "true  on success,  false  on error.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example_7", 
            "text": "-- rename file 'temp.lua' to 'init.lua'.\nfile.rename( temp.lua , init.lua )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/file/#filestat", 
            "text": "Get attribtues of a file or directory in a table. Elements of the table are:   size  file size in bytes  name  file name   time  table with time stamp information. Default is 1970-01-01 00:00:00 in case time stamps are not supported (on SPIFFS).   year  mon  day  hour  min  sec     is_dir  flag  true  if item is a directory, otherwise  false   is_rdonly  flag  true  if item is read-only, otherwise  false  is_hidden  flag  true  if item is hidden, otherwise  false  is_sys  flag  true  if item is system, otherwise  false  is_arch  flag  true  if item is archive, otherwise  false", 
            "title": "file.stat()"
        }, 
        {
            "location": "/en/modules/file/#syntax_11", 
            "text": "file.stat(filename)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_11", 
            "text": "filename  file name", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_11", 
            "text": "table containing file attributes", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example_8", 
            "text": "s = file.stat( /SD0/myfile )\nprint( name:   .. s.name)\nprint( size:   .. s.size)\n\nt = s.time\nprint(string.format( %02d:%02d:%02d , t.hour, t.min, t.sec))\nprint(string.format( %04d-%02d-%02d , t.year, t.mon, t.day))\n\nif s.is_dir then print( is directory ) else print( is file ) end\nif s.is_rdonly then print( is read-only ) else print( is writable ) end\nif s.is_hidden then print( is hidden ) else print( is not hidden ) end\nif s.is_sys then print( is system ) else print( is not system ) end\nif s.is_arch then print( is archive ) else print( is not archive ) end\n\ns = nil\nt = nil", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/file/#file-access-functions", 
            "text": "The  file  module provides several functions to access the content of a file after it has been opened with  file.open() . They can be used as part of a basic model or an object model:", 
            "title": "File access functions"
        }, 
        {
            "location": "/en/modules/file/#basic-model", 
            "text": "In the basic model there is max one file opened at a time. The file access functions operate on this file per default. If another file is opened, the previous default file needs to be closed beforehand.  -- open 'init.lua', print the first line.\nif file.open( init.lua ,  r ) then\n  print(file.readline())\n  file.close()\nend", 
            "title": "Basic model"
        }, 
        {
            "location": "/en/modules/file/#object-model", 
            "text": "Files are represented by file objects which are created by  file.open() . File access functions are available as methods of this object, and multiple file objects can coexist.  src = file.open( init.lua ,  r )\nif src then\n  dest = file.open( copy.lua ,  w )\n  if dest then\n    local line\n    repeat\n      line = src:read()\n      if line then\n        dest:write(line)\n      end\n    until line == nil\n    dest:close(); dest = nil\n  end\n  src:close(); dest = nil\nend   Attention  It is recommended to use only one single model within the application. Concurrent use of both models can yield unpredictable behavior: Closing the default file from basic model will also close the correspoding file object. Closing a file from object model will also close the default file if they are the same file.    Note  The maximum number of open files on SPIFFS is determined at compile time by  SPIFFS_MAX_OPEN_FILES  in  user_config.h .", 
            "title": "Object model"
        }, 
        {
            "location": "/en/modules/file/#fileclose-fileobjclose", 
            "text": "Closes the open file, if any.", 
            "title": "file.close(), file.obj:close()"
        }, 
        {
            "location": "/en/modules/file/#syntax_12", 
            "text": "file.close()  fd:close()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_12", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_12", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#see-also_5", 
            "text": "file.open()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#fileflush-fileobjflush", 
            "text": "Flushes any pending writes to the file system, ensuring no data is lost on a restart. Closing the open file using  file.close()  /  fd:close()  performs an implicit flush as well.", 
            "title": "file.flush(), file.obj:flush()"
        }, 
        {
            "location": "/en/modules/file/#syntax_13", 
            "text": "file.flush()  fd:flush()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_13", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_13", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example-basic-model_1", 
            "text": "-- open 'init.lua' in 'a+' mode\nif file.open( init.lua ,  a+ ) then\n  -- write 'foo bar' to the end of the file\n  file.write('foo bar')\n  file.flush()\n  -- write 'baz' too\n  file.write('baz')\n  file.close()\nend", 
            "title": "Example (basic model)"
        }, 
        {
            "location": "/en/modules/file/#see-also_6", 
            "text": "file.close()  /  file.obj:close()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#fileread-fileobjread", 
            "text": "Read content from the open file.   Note  The function temporarily allocates 2 * (number of requested bytes) on the heap for buffering and processing the read data. Default chunk size ( FILE_READ_CHUNK ) is 1024 bytes and is regarded to be safe. Pushing this by 4x or more can cause heap overflows depending on the application. Consider this when selecting a value for parameter  n_or_char .", 
            "title": "file.read(), file.obj:read()"
        }, 
        {
            "location": "/en/modules/file/#syntax_14", 
            "text": "file.read([n_or_char])  fd:read([n_or_char])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_14", 
            "text": "n_or_char :  if nothing passed in, then read up to  FILE_READ_CHUNK  bytes or the entire file (whichever is smaller).  if passed a number  n , then read up to  n  bytes or the entire file (whichever is smaller).  if passed a string containing the single character  char , then read until  char  appears next in the file,  FILE_READ_CHUNK  bytes have been read, or EOF is reached.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_14", 
            "text": "File content as a string, or nil when EOF", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example-basic-model_2", 
            "text": "-- print the first line of 'init.lua'\nif file.open( init.lua ,  r ) then\n  print(file.read('\\n'))\n  file.close()\nend", 
            "title": "Example (basic model)"
        }, 
        {
            "location": "/en/modules/file/#example-object-model_1", 
            "text": "-- print the first 5 bytes of 'init.lua'\nfd = file.open( init.lua ,  r )\nif fd then\n  print(fd:read(5))\n  fd:close(); fd = nil\nend", 
            "title": "Example (object model)"
        }, 
        {
            "location": "/en/modules/file/#see-also_7", 
            "text": "file.open()  file.readline()  /  file.obj:readline()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#filereadline-fileobjreadline", 
            "text": "Read the next line from the open file. Lines are defined as zero or more bytes ending with a EOL ('\\n') byte. If the next line is longer than 1024, this function only returns the first 1024 bytes.", 
            "title": "file.readline(), file.obj:readline()"
        }, 
        {
            "location": "/en/modules/file/#syntax_15", 
            "text": "file.readline()  fd:readline()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_15", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_15", 
            "text": "File content in string, line by line, including EOL('\\n'). Return  nil  when EOF.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example-basic-model_3", 
            "text": "-- print the first line of 'init.lua'\nif file.open( init.lua ,  r ) then\n  print(file.readline())\n  file.close()\nend", 
            "title": "Example (basic model)"
        }, 
        {
            "location": "/en/modules/file/#see-also_8", 
            "text": "file.open()  file.close()  /  file.obj:close()  file.read()  /  file.obj:read()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#fileseek-fileobjseek", 
            "text": "Sets and gets the file position, measured from the beginning of the file, to the position given by offset plus a base specified by the string whence.", 
            "title": "file.seek(), file.obj:seek()"
        }, 
        {
            "location": "/en/modules/file/#syntax_16", 
            "text": "file.seek([whence [, offset]])  fd:seek([whence [, offset]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_16", 
            "text": "whence  \"set\": base is position 0 (beginning of the file)  \"cur\": base is current position (default value)  \"end\": base is end of file    offset  default 0   If no parameters are given, the function simply returns the current file offset.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_16", 
            "text": "the resulting file position, or  nil  on error", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example-basic-model_4", 
            "text": "if file.open( init.lua ,  r ) then\n  -- skip the first 5 bytes of the file\n  file.seek( set , 5)\n  print(file.readline())\n  file.close()\nend", 
            "title": "Example (basic model)"
        }, 
        {
            "location": "/en/modules/file/#see-also_9", 
            "text": "file.open()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#filewrite-fileobjwrite", 
            "text": "Write a string to the open file.", 
            "title": "file.write(), file.obj:write()"
        }, 
        {
            "location": "/en/modules/file/#syntax_17", 
            "text": "file.write(string)  fd:write(string)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_17", 
            "text": "string  content to be write to file", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_17", 
            "text": "true  if the write is ok,  nil  on error", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example-basic-model_5", 
            "text": "-- open 'init.lua' in 'a+' mode\nif file.open( init.lua ,  a+ ) then\n  -- write 'foo bar' to the end of the file\n  file.write('foo bar')\n  file.close()\nend", 
            "title": "Example (basic model)"
        }, 
        {
            "location": "/en/modules/file/#example-object-model_2", 
            "text": "-- open 'init.lua' in 'a+' mode\nfd = file.open( init.lua ,  a+ )\nif fd then\n  -- write 'foo bar' to the end of the file\n  fd:write('foo bar')\n  fd:close()\nend", 
            "title": "Example (object model)"
        }, 
        {
            "location": "/en/modules/file/#see-also_10", 
            "text": "file.open()  file.writeline()  /  file.obj:writeline()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/file/#filewriteline-fileobjwriteline", 
            "text": "Write a string to the open file and append '\\n' at the end.", 
            "title": "file.writeline(), file.obj:writeline()"
        }, 
        {
            "location": "/en/modules/file/#syntax_18", 
            "text": "file.writeline(string)  fd:writeline(string)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/file/#parameters_18", 
            "text": "string  content to be write to file", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/file/#returns_18", 
            "text": "true  if write ok,  nil  on error", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/file/#example-basic-model_6", 
            "text": "-- open 'init.lua' in 'a+' mode\nif file.open( init.lua ,  a+ ) then\n  -- write 'foo bar' to the end of the file\n  file.writeline('foo bar')\n  file.close()\nend", 
            "title": "Example (basic model)"
        }, 
        {
            "location": "/en/modules/file/#see-also_11", 
            "text": "file.open()  file.readline()  /  file.obj:readline()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/gdbstub/", 
            "text": "gdbstub Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-09-18\n\n\nPhilip Gladstone\n\n\nPhilip Gladstone\n\n\ngdbstub.c\n\n\n\n\n\n\n\n\nThis module provides basic source code debugging of the firmware when used in conjunction with a version of gdb built for the lx106. If you enable this module, then fatal errors (like invalid memory reads) will trap into the gdbstub. This uses UART0 to talk to GDB. If this happens while the UART0 is connected to a terminal (or some IDE like esplorer) then you will see a string starting with \n$T\n and a few more characters after that. This is the signal that a trap has happened, and control should be passed to gdb.\n\n\nGDB\n can then be started at connected to the NodeMCU platform. If this is connected to the host system via a serial port, then the following (or close variant) ought to work:\n\n\ngdb bin/firmwarefile.bin\ntarget remote /dev/ttyUSB0\n\n\n\n\nAt this point, you can just poke around and see what happened, but you cannot continue execution.\n\n\nIn order to do interactive debugging, add a call to \ngdbstub.brk()\n in your Lua code. This will trigger a break instruction and will trap into gdb as above. However, continuation is supported from a break instruction and so you can single step, set breakpoints, etc. Note that the lx106 processor as configured by Espressif only supports a single hardware breakpoint. This means that you can only put a single breakpoint in flash code. You can single step as much as you like. \n\n\ngdbstub.brk()\n\n\nEnters gdb by executing a \nbreak 0,0\n instruction.\n\n\nSyntax\n\n\ngdbstub.brk()\n\n\ngdbstub.gdboutput()\n\n\nControls whether system output is encapsulated in gdb remote debugging protocol. This turns out not to be as useful as you would hope - mostly because you can't send input to the NodeMCU board. Also because you really only should make this call \nafter\n you get gdb running and connected to the NodeMCU. The example below first does the break and then switches to redirect the output. This works (but you are unable to send any more console input). \n\n\nSyntax\n\n\ngdbstub.gdboutput(enable)\n\n\nParameters\n\n\nenable\n If true, then output is wrapped in gdb remote debugging protocol. If false, then it is sent straight to the UART.\n\n\nExample\n\n\nfunction entergdb()\n  gdbstub.brk()\n  gdbstub.gdboutput(1)\n  print(\nActive\n)\nend\n\nentergdb()\n\n\n\n\nNotes\n\n\nOnce you attach gdb to the NodeMCU, then any further output from the NodeMCU will be discarded (as it does not match the gdb remote debugging protocol). This may (or may not) be a problem. If you want to run under gdb and see the output from the NodeMCU, then call \ngdbstub.gdboutput(1)\n and then output will be wrapped in the gdb protocol and display on the gdb console. You don't want to do this until gdb is attached as each packet requires an explicit ack in order to continue.", 
            "title": "gdbstub"
        }, 
        {
            "location": "/en/modules/gdbstub/#gdbstub-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-09-18  Philip Gladstone  Philip Gladstone  gdbstub.c     This module provides basic source code debugging of the firmware when used in conjunction with a version of gdb built for the lx106. If you enable this module, then fatal errors (like invalid memory reads) will trap into the gdbstub. This uses UART0 to talk to GDB. If this happens while the UART0 is connected to a terminal (or some IDE like esplorer) then you will see a string starting with  $T  and a few more characters after that. This is the signal that a trap has happened, and control should be passed to gdb.  GDB  can then be started at connected to the NodeMCU platform. If this is connected to the host system via a serial port, then the following (or close variant) ought to work:  gdb bin/firmwarefile.bin\ntarget remote /dev/ttyUSB0  At this point, you can just poke around and see what happened, but you cannot continue execution.  In order to do interactive debugging, add a call to  gdbstub.brk()  in your Lua code. This will trigger a break instruction and will trap into gdb as above. However, continuation is supported from a break instruction and so you can single step, set breakpoints, etc. Note that the lx106 processor as configured by Espressif only supports a single hardware breakpoint. This means that you can only put a single breakpoint in flash code. You can single step as much as you like.", 
            "title": "gdbstub Module"
        }, 
        {
            "location": "/en/modules/gdbstub/#gdbstubbrk", 
            "text": "Enters gdb by executing a  break 0,0  instruction.", 
            "title": "gdbstub.brk()"
        }, 
        {
            "location": "/en/modules/gdbstub/#syntax", 
            "text": "gdbstub.brk()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/gdbstub/#gdbstubgdboutput", 
            "text": "Controls whether system output is encapsulated in gdb remote debugging protocol. This turns out not to be as useful as you would hope - mostly because you can't send input to the NodeMCU board. Also because you really only should make this call  after  you get gdb running and connected to the NodeMCU. The example below first does the break and then switches to redirect the output. This works (but you are unable to send any more console input).", 
            "title": "gdbstub.gdboutput()"
        }, 
        {
            "location": "/en/modules/gdbstub/#syntax_1", 
            "text": "gdbstub.gdboutput(enable)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/gdbstub/#parameters", 
            "text": "enable  If true, then output is wrapped in gdb remote debugging protocol. If false, then it is sent straight to the UART.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/gdbstub/#example", 
            "text": "function entergdb()\n  gdbstub.brk()\n  gdbstub.gdboutput(1)\n  print( Active )\nend\n\nentergdb()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/gdbstub/#notes", 
            "text": "Once you attach gdb to the NodeMCU, then any further output from the NodeMCU will be discarded (as it does not match the gdb remote debugging protocol). This may (or may not) be a problem. If you want to run under gdb and see the output from the NodeMCU, then call  gdbstub.gdboutput(1)  and then output will be wrapped in the gdb protocol and display on the gdb console. You don't want to do this until gdb is attached as each packet requires an explicit ack in order to continue.", 
            "title": "Notes"
        }, 
        {
            "location": "/en/modules/gpio/", 
            "text": "GPIO Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-22\n\n\nZeroday\n\n\nZeroday\n\n\ngpio.c\n\n\n\n\n\n\n\n\nThis module provides access to the \nGPIO\n (General Purpose Input/Output) subsystem.\n\n\nAll access is based on the I/O index number on the NodeMCU dev kits, not the internal GPIO pin. For example, the D0 pin on the dev kit is mapped to the internal GPIO pin 16.\n\n\nIf not using a NodeMCU dev kit, please refer to the below GPIO pin maps for the index\u2194gpio mapping.\n\n\n\n\n\n\n\n\nIO index\n\n\nESP8266 pin\n\n\nIO index\n\n\nESP8266 pin\n\n\n\n\n\n\n\n\n\n\n0 [*]\n\n\nGPIO16\n\n\n7\n\n\nGPIO13\n\n\n\n\n\n\n1\n\n\nGPIO5\n\n\n8\n\n\nGPIO15\n\n\n\n\n\n\n2\n\n\nGPIO4\n\n\n9\n\n\nGPIO3\n\n\n\n\n\n\n3\n\n\nGPIO0\n\n\n10\n\n\nGPIO1\n\n\n\n\n\n\n4\n\n\nGPIO2\n\n\n11\n\n\nGPIO9\n\n\n\n\n\n\n5\n\n\nGPIO14\n\n\n12\n\n\nGPIO10\n\n\n\n\n\n\n6\n\n\nGPIO12\n\n\n\n\n\n\n\n\n\n\n\n\n [*] D0(GPIO16) can only be used as gpio read/write. No support for open-drain/interrupt/pwm/i2c/ow. \n\n\ngpio.mode()\n\n\nInitialize pin to GPIO mode, set the pin in/out direction, and optional internal weak pull-up.\n\n\nSyntax\n\n\ngpio.mode(pin, mode [, pullup])\n\n\nParameters\n\n\n\n\npin\n pin to configure, IO index\n\n\nmode\n one of gpio.OUTPUT, gpio.OPENDRAIN, gpio.INPUT, or gpio.INT (interrupt mode)\n\n\npullup\n gpio.PULLUP enables the weak pull-up resistor; default is gpio.FLOAT\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\ngpio.mode(0, gpio.OUTPUT)\n\n\n\n\nSee also\n\n\n\n\ngpio.read()\n\n\ngpio.write()\n\n\n\n\ngpio.read()\n\n\nRead digital GPIO pin value.\n\n\nSyntax\n\n\ngpio.read(pin)\n\n\nParameters\n\n\npin\n pin to read, IO index\n\n\nReturns\n\n\na number, 0 = low, 1 = high\n\n\nExample\n\n\n-- read value of gpio 0.\ngpio.read(0)\n\n\n\n\nSee also\n\n\ngpio.mode()\n\n\ngpio.serout()\n\n\nSerialize output based on a sequence of delay-times in \u00b5s. After each delay, the pin is toggled. After the last cycle and last delay the pin is not toggled.\n\n\nThe function works in two modes: \n\n synchronous - for sub-50 \u00b5s resolution, restricted to max. overall duration,\n\n asynchrounous - synchronous operation with less granularity but virtually unrestricted duration.\n\n\nWhether the asynchronous mode is chosen is defined by presence of the \ncallback\n parameter. If present and is of function type the function goes asynchronous and the callback function is invoked when sequence finishes. If the parameter is numeric the function still goes asynchronous but no callback is invoked when done.\n\n\nFor the asynchronous version, the minimum delay time should not be shorter than 50 \u03bcs and maximum delay time is 0x7fffff \u03bcs (~8.3 seconds).\nIn this mode the function does not block the stack and returns immediately before the output sequence is finalized. HW timer \nFRC1_SOURCE\n mode is used to change the states. As there is only a single hardware timer, there\nare restrictions on which modules can be used at the same time. An error will be raised if the timer is already in use.\n\n\nNote that the synchronous variant (no or nil \ncallback\n parameter) function blocks the stack and as such any use of it must adhere to the SDK guidelines (also explained \nhere\n). Failure to do so may lead to WiFi issues or outright to crashes/reboots. In short it means that the sum of all delay times multiplied by the number of cycles should not exceed 15 ms.\n\n\nSyntax\n\n\ngpio.serout(pin, start_level, delay_times [, cycle_num[, callback]])\n\n\nParameters\n\n\n\n\npin\n  pin to use, IO index\n\n\nstart_level\n level to start on, either \ngpio.HIGH\n or \ngpio.LOW\n\n\ndelay_times\n an array of delay times in \u00b5s between each toggle of the gpio pin. \n\n\ncycle_num\n an optional number of times to run through the sequence. (default is 1)\n\n\ncallback\n an optional callback function or number, if present the function returns immediately and goes asynchronous.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\ngpio.mode(1,gpio.OUTPUT,gpio.PULLUP)\ngpio.serout(1,gpio.HIGH,{30,30,60,60,30,30})  -- serial one byte, b10110010\ngpio.serout(1,gpio.HIGH,{30,70},8)  -- serial 30% pwm 10k, lasts 8 cycles\ngpio.serout(1,gpio.HIGH,{3,7},8)  -- serial 30% pwm 100k, lasts 8 cycles\ngpio.serout(1,gpio.HIGH,{0,0},8)  -- serial 50% pwm as fast as possible, lasts 8 cycles\ngpio.serout(1,gpio.LOW,{20,10,10,20,10,10,10,100}) -- sim uart one byte 0x5A at about 100kbps\ngpio.serout(1,gpio.HIGH,{8,18},8) -- serial 30% pwm 38k, lasts 8 cycles\n\ngpio.serout(1,gpio.HIGH,{5000,995000},100, function() print(\ndone\n) end) -- asynchronous 100 flashes 5 ms long every second with a callback function when done\ngpio.serout(1,gpio.HIGH,{5000,995000},100, 1) -- asynchronous 100 flashes 5 ms long, no callback\n\n\n\n\ngpio.trig()\n\n\nEstablish or clear a callback function to run on interrupt for a pin.\n\n\nThis function is not available if GPIO_INTERRUPT_ENABLE was undefined at compile time.\n\n\nSyntax\n\n\ngpio.trig(pin, [type [, callback_function]])\n\n\nParameters\n\n\n\n\npin\n \n1-12\n, pin to trigger on, IO index. Note that pin 0 does not support interrupts.\n\n\ntype\n \"up\", \"down\", \"both\", \"low\", \"high\", which represent \nrising edge\n, \nfalling edge\n, \nboth \nedges\n, \nlow level\n, and \nhigh level\n trigger modes respectivey. If the type is \"none\" or omitted \nthen the callback function is removed and the interrupt is disabled.\n\n\ncallback_function(level, when)\n callback function when trigger occurs. The level of the specified pin \nat the interrupt passed as the first parameter to the callback. The timestamp of the event is passed\nas the second parameter. This is in microseconds and has the same base as for \ntmr.now()\n. This timestamp\nis grabbed at interrupt level and is more consistent than getting the time in the callback function.\nThe previous callback function will be used if the function is omitted.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\ndo\n  -- use pin 1 as the input pulse width counter\n  local pin, pulse1, du, now, trig = 1, 0, 0, tmr.now, gpio.trig\n  gpio.mode(pin,gpio.INT)\n  local function pin1cb(level, pulse2)\n    print( level, pulse2 - pulse1 )\n    pulse1 = pulse2\n    trig(pin, level == gpio.HIGH  and \ndown\n or \nup\n)\n  end\n  trig(pin, \ndown\n, pin1cb)\nend\n\n\n\n\nSee also\n\n\ngpio.mode()\n\n\ngpio.write()\n\n\nSet digital GPIO pin value.\n\n\nSyntax\n\n\ngpio.write(pin, level)\n\n\nParameters\n\n\n\n\npin\n pin to write, IO index\n\n\nlevel\n \ngpio.HIGH\n or \ngpio.LOW\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- set pin index 1 to GPIO mode, and set the pin to high.\npin=1\ngpio.mode(pin, gpio.OUTPUT)\ngpio.write(pin, gpio.HIGH)\n\n\n\n\nSee also\n\n\n\n\ngpio.mode()\n\n\ngpio.read()", 
            "title": "gpio"
        }, 
        {
            "location": "/en/modules/gpio/#gpio-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-22  Zeroday  Zeroday  gpio.c     This module provides access to the  GPIO  (General Purpose Input/Output) subsystem.  All access is based on the I/O index number on the NodeMCU dev kits, not the internal GPIO pin. For example, the D0 pin on the dev kit is mapped to the internal GPIO pin 16.  If not using a NodeMCU dev kit, please refer to the below GPIO pin maps for the index\u2194gpio mapping.     IO index  ESP8266 pin  IO index  ESP8266 pin      0 [*]  GPIO16  7  GPIO13    1  GPIO5  8  GPIO15    2  GPIO4  9  GPIO3    3  GPIO0  10  GPIO1    4  GPIO2  11  GPIO9    5  GPIO14  12  GPIO10    6  GPIO12        [*] D0(GPIO16) can only be used as gpio read/write. No support for open-drain/interrupt/pwm/i2c/ow.", 
            "title": "GPIO Module"
        }, 
        {
            "location": "/en/modules/gpio/#gpiomode", 
            "text": "Initialize pin to GPIO mode, set the pin in/out direction, and optional internal weak pull-up.", 
            "title": "gpio.mode()"
        }, 
        {
            "location": "/en/modules/gpio/#syntax", 
            "text": "gpio.mode(pin, mode [, pullup])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/gpio/#parameters", 
            "text": "pin  pin to configure, IO index  mode  one of gpio.OUTPUT, gpio.OPENDRAIN, gpio.INPUT, or gpio.INT (interrupt mode)  pullup  gpio.PULLUP enables the weak pull-up resistor; default is gpio.FLOAT", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/gpio/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/gpio/#example", 
            "text": "gpio.mode(0, gpio.OUTPUT)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/gpio/#see-also", 
            "text": "gpio.read()  gpio.write()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/gpio/#gpioread", 
            "text": "Read digital GPIO pin value.", 
            "title": "gpio.read()"
        }, 
        {
            "location": "/en/modules/gpio/#syntax_1", 
            "text": "gpio.read(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/gpio/#parameters_1", 
            "text": "pin  pin to read, IO index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/gpio/#returns_1", 
            "text": "a number, 0 = low, 1 = high", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/gpio/#example_1", 
            "text": "-- read value of gpio 0.\ngpio.read(0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/gpio/#see-also_1", 
            "text": "gpio.mode()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/gpio/#gpioserout", 
            "text": "Serialize output based on a sequence of delay-times in \u00b5s. After each delay, the pin is toggled. After the last cycle and last delay the pin is not toggled.  The function works in two modes:   synchronous - for sub-50 \u00b5s resolution, restricted to max. overall duration,  asynchrounous - synchronous operation with less granularity but virtually unrestricted duration.  Whether the asynchronous mode is chosen is defined by presence of the  callback  parameter. If present and is of function type the function goes asynchronous and the callback function is invoked when sequence finishes. If the parameter is numeric the function still goes asynchronous but no callback is invoked when done.  For the asynchronous version, the minimum delay time should not be shorter than 50 \u03bcs and maximum delay time is 0x7fffff \u03bcs (~8.3 seconds).\nIn this mode the function does not block the stack and returns immediately before the output sequence is finalized. HW timer  FRC1_SOURCE  mode is used to change the states. As there is only a single hardware timer, there\nare restrictions on which modules can be used at the same time. An error will be raised if the timer is already in use.  Note that the synchronous variant (no or nil  callback  parameter) function blocks the stack and as such any use of it must adhere to the SDK guidelines (also explained  here ). Failure to do so may lead to WiFi issues or outright to crashes/reboots. In short it means that the sum of all delay times multiplied by the number of cycles should not exceed 15 ms.", 
            "title": "gpio.serout()"
        }, 
        {
            "location": "/en/modules/gpio/#syntax_2", 
            "text": "gpio.serout(pin, start_level, delay_times [, cycle_num[, callback]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/gpio/#parameters_2", 
            "text": "pin   pin to use, IO index  start_level  level to start on, either  gpio.HIGH  or  gpio.LOW  delay_times  an array of delay times in \u00b5s between each toggle of the gpio pin.   cycle_num  an optional number of times to run through the sequence. (default is 1)  callback  an optional callback function or number, if present the function returns immediately and goes asynchronous.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/gpio/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/gpio/#example_2", 
            "text": "gpio.mode(1,gpio.OUTPUT,gpio.PULLUP)\ngpio.serout(1,gpio.HIGH,{30,30,60,60,30,30})  -- serial one byte, b10110010\ngpio.serout(1,gpio.HIGH,{30,70},8)  -- serial 30% pwm 10k, lasts 8 cycles\ngpio.serout(1,gpio.HIGH,{3,7},8)  -- serial 30% pwm 100k, lasts 8 cycles\ngpio.serout(1,gpio.HIGH,{0,0},8)  -- serial 50% pwm as fast as possible, lasts 8 cycles\ngpio.serout(1,gpio.LOW,{20,10,10,20,10,10,10,100}) -- sim uart one byte 0x5A at about 100kbps\ngpio.serout(1,gpio.HIGH,{8,18},8) -- serial 30% pwm 38k, lasts 8 cycles\n\ngpio.serout(1,gpio.HIGH,{5000,995000},100, function() print( done ) end) -- asynchronous 100 flashes 5 ms long every second with a callback function when done\ngpio.serout(1,gpio.HIGH,{5000,995000},100, 1) -- asynchronous 100 flashes 5 ms long, no callback", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/gpio/#gpiotrig", 
            "text": "Establish or clear a callback function to run on interrupt for a pin.  This function is not available if GPIO_INTERRUPT_ENABLE was undefined at compile time.", 
            "title": "gpio.trig()"
        }, 
        {
            "location": "/en/modules/gpio/#syntax_3", 
            "text": "gpio.trig(pin, [type [, callback_function]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/gpio/#parameters_3", 
            "text": "pin   1-12 , pin to trigger on, IO index. Note that pin 0 does not support interrupts.  type  \"up\", \"down\", \"both\", \"low\", \"high\", which represent  rising edge ,  falling edge ,  both \nedges ,  low level , and  high level  trigger modes respectivey. If the type is \"none\" or omitted \nthen the callback function is removed and the interrupt is disabled.  callback_function(level, when)  callback function when trigger occurs. The level of the specified pin \nat the interrupt passed as the first parameter to the callback. The timestamp of the event is passed\nas the second parameter. This is in microseconds and has the same base as for  tmr.now() . This timestamp\nis grabbed at interrupt level and is more consistent than getting the time in the callback function.\nThe previous callback function will be used if the function is omitted.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/gpio/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/gpio/#example_3", 
            "text": "do\n  -- use pin 1 as the input pulse width counter\n  local pin, pulse1, du, now, trig = 1, 0, 0, tmr.now, gpio.trig\n  gpio.mode(pin,gpio.INT)\n  local function pin1cb(level, pulse2)\n    print( level, pulse2 - pulse1 )\n    pulse1 = pulse2\n    trig(pin, level == gpio.HIGH  and  down  or  up )\n  end\n  trig(pin,  down , pin1cb)\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/gpio/#see-also_2", 
            "text": "gpio.mode()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/gpio/#gpiowrite", 
            "text": "Set digital GPIO pin value.", 
            "title": "gpio.write()"
        }, 
        {
            "location": "/en/modules/gpio/#syntax_4", 
            "text": "gpio.write(pin, level)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/gpio/#parameters_4", 
            "text": "pin  pin to write, IO index  level   gpio.HIGH  or  gpio.LOW", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/gpio/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/gpio/#example_4", 
            "text": "-- set pin index 1 to GPIO mode, and set the pin to high.\npin=1\ngpio.mode(pin, gpio.OUTPUT)\ngpio.write(pin, gpio.HIGH)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/gpio/#see-also_3", 
            "text": "gpio.mode()  gpio.read()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/hdc1080/", 
            "text": "HDC1080 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2017-04-01\n\n\nMetin KOC\n\n\nMetin KOC\n\n\nhdc1080.c\n\n\n\n\n\n\n\n\nThis module provides access to the \nHDC1080\n low power, high accuracy digital humidity sensor with temperature sensor.\n\n\nhdc1080.read()\n\n\nSamples the sensor then returns temperature and humidity value.\n\n\nSyntax\n\n\nhdc1080.read()\n\n\nReturns\n\n\nTemperature data in centigrade and humidity data in percentage (0-100) (integer/float)\n\n\nExample\n\n\nlocal sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW)  -- call i2c.setup() only once\nhdc1080.setup()\nlocal temperature,humidity = hdc1080.read()\nprint(temperature)\nprint(humidity)\n\n\n\n\nhdc1080.setup()\n\n\nInitializes the module.\n\n\nSyntax\n\n\nhdc1080.setup()\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\nnil\n\n\nhdc1080.init(sda,scl)\n\n\nInitializes the module and sets the pin configuration.\n\n\n\n\nAttention\n\n\nThis function is deprecated and will be removed in upcoming releases. Use \nhdc1080.setup()\n instead.\n\n\n\n\nSyntax\n\n\nhdc1080.init(sda, scl)\n\n\nParameters\n\n\n\n\nsda\n data pin\n\n\nscl\n clock pin\n\n\n\n\nReturns\n\n\nnil", 
            "title": "hdc1080"
        }, 
        {
            "location": "/en/modules/hdc1080/#hdc1080-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2017-04-01  Metin KOC  Metin KOC  hdc1080.c     This module provides access to the  HDC1080  low power, high accuracy digital humidity sensor with temperature sensor.", 
            "title": "HDC1080 Module"
        }, 
        {
            "location": "/en/modules/hdc1080/#hdc1080read", 
            "text": "Samples the sensor then returns temperature and humidity value.", 
            "title": "hdc1080.read()"
        }, 
        {
            "location": "/en/modules/hdc1080/#syntax", 
            "text": "hdc1080.read()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/hdc1080/#returns", 
            "text": "Temperature data in centigrade and humidity data in percentage (0-100) (integer/float)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/hdc1080/#example", 
            "text": "local sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW)  -- call i2c.setup() only once\nhdc1080.setup()\nlocal temperature,humidity = hdc1080.read()\nprint(temperature)\nprint(humidity)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/hdc1080/#hdc1080setup", 
            "text": "Initializes the module.", 
            "title": "hdc1080.setup()"
        }, 
        {
            "location": "/en/modules/hdc1080/#syntax_1", 
            "text": "hdc1080.setup()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/hdc1080/#parameters", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/hdc1080/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/hdc1080/#hdc1080initsdascl", 
            "text": "Initializes the module and sets the pin configuration.   Attention  This function is deprecated and will be removed in upcoming releases. Use  hdc1080.setup()  instead.", 
            "title": "hdc1080.init(sda,scl)"
        }, 
        {
            "location": "/en/modules/hdc1080/#syntax_2", 
            "text": "hdc1080.init(sda, scl)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/hdc1080/#parameters_1", 
            "text": "sda  data pin  scl  clock pin", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/hdc1080/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/hmc5883l/", 
            "text": "HMC5883L Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-04-09\n\n\nJason Schmidlapp\n\n\nJason Schmidlapp\n\n\nhmc5883l.c\n\n\n\n\n\n\n\n\nThis module provides access to the \nHMC5883L\n three axis digital compass.\n\n\nhmc5883l.read()\n\n\nSamples the sensor and returns X,Y and Z data.\n\n\nSyntax\n\n\nhmc5883l.read()\n\n\nReturns\n\n\nx,y,z measurements (integers)\ntemperature multiplied with 10 (integer)\n\n\nExample\n\n\nlocal sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nhmc5883l.setup()\nlocal x,y,z = hmc5883l.read()\nprint(string.format(\nx = %d, y = %d, z = %d\n, x, y, z))\n\n\n\n\nhmc5883l.init()\n\n\nInitializes the module and sets the pin configuration.\n\n\n\n\nAttention\n\n\nThis function is deprecated and will be removed in upcoming releases. Use \nhmc5883l.setup()\n instead.\n\n\n\n\nSyntax\n\n\nhmc5883l.init(sda, scl)\n\n\nParameters\n\n\n\n\nsda\n data pin\n\n\nscl\n clock pin\n\n\n\n\nReturns\n\n\nnil\n\n\nhmc5883l.setup()\n\n\nInitializes the module.\n\n\nSyntax\n\n\nhmc5883l.setup()\n\n\nParameters\n\n\nNone\n\n\nReturns\n\n\nnil", 
            "title": "hmc5883l"
        }, 
        {
            "location": "/en/modules/hmc5883l/#hmc5883l-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-04-09  Jason Schmidlapp  Jason Schmidlapp  hmc5883l.c     This module provides access to the  HMC5883L  three axis digital compass.", 
            "title": "HMC5883L Module"
        }, 
        {
            "location": "/en/modules/hmc5883l/#hmc5883lread", 
            "text": "Samples the sensor and returns X,Y and Z data.", 
            "title": "hmc5883l.read()"
        }, 
        {
            "location": "/en/modules/hmc5883l/#syntax", 
            "text": "hmc5883l.read()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/hmc5883l/#returns", 
            "text": "x,y,z measurements (integers)\ntemperature multiplied with 10 (integer)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/hmc5883l/#example", 
            "text": "local sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nhmc5883l.setup()\nlocal x,y,z = hmc5883l.read()\nprint(string.format( x = %d, y = %d, z = %d , x, y, z))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/hmc5883l/#hmc5883linit", 
            "text": "Initializes the module and sets the pin configuration.   Attention  This function is deprecated and will be removed in upcoming releases. Use  hmc5883l.setup()  instead.", 
            "title": "hmc5883l.init()"
        }, 
        {
            "location": "/en/modules/hmc5883l/#syntax_1", 
            "text": "hmc5883l.init(sda, scl)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/hmc5883l/#parameters", 
            "text": "sda  data pin  scl  clock pin", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/hmc5883l/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/hmc5883l/#hmc5883lsetup", 
            "text": "Initializes the module.", 
            "title": "hmc5883l.setup()"
        }, 
        {
            "location": "/en/modules/hmc5883l/#syntax_2", 
            "text": "hmc5883l.setup()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/hmc5883l/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/hmc5883l/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/http/", 
            "text": "HTTP Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-01-15\n\n\nesphttpclient\n / \nVowstar\n\n\nVowstar\n\n\nhttp.c\n\n\n\n\n\n\n\n\nBasic HTTP \nclient\n module that provides an interface to do GET/POST/PUT/DELETE over HTTP(S), as well as customized requests. Due to the memory constraints on ESP8266, the supported page/body size is limited by available memory. Attempting to receive pages larger than this will fail. If larger page/body sizes are necessary, consider using \nnet.createConnection()\n and stream in the data.\n\n\n\n\nAttention\n\n\nIt is \nnot\n possible to execute concurrent HTTP requests using this module. \n\n\n\n\nEach request method takes a callback which is invoked when the response has been received from the server. The first argument is the status code, which is either a regular HTTP status code, or -1 to denote a DNS, connection or out-of-memory failure, or a timeout (currently at 10 seconds).\n\n\nFor each operation it is possible to provide custom HTTP headers or override standard headers. By default the \nHost\n header is deduced from the URL and \nUser-Agent\n is \nESP8266\n. Note, however, that the \nConnection\n header \ncan not\n be overridden! It is always set to \nclose\n.\n\n\nHTTP redirects (HTTP status 300-308) are followed automatically up to a limit of 20 to avoid the dreaded redirect loops.\n\n\nWhen the callback is invoked, it is passed the HTTP status code, the body as it was received, and a table of the response headers. All the header names have been lower cased\nto make it easy to access. If there are multiple headers of the same name, then only the last one is returned.\n\n\nSSL/TLS support\n\n\nTake note of constraints documented in the \nnet module\n. \n\n\nhttp.delete()\n\n\nExecutes a HTTP DELETE request. Note that concurrent requests are not supported.\n\n\nSyntax\n\n\nhttp.delete(url, headers, body, callback)\n\n\nParameters\n\n\n\n\nurl\n The URL to fetch, including the \nhttp://\n or \nhttps://\n prefix\n\n\nheaders\n Optional additional headers to append, \nincluding \\r\\n\n; may be \nnil\n\n\nbody\n The body to post; must already be encoded in the appropriate format, but may be empty\n\n\ncallback\n The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments \nstatus_code\n, \nbody\n and \nheaders\n. In case of an error \nstatus_code\n is set to -1.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nhttp.delete('http://httpbin.org/delete',\n  \n,\n  \n,\n  function(code, data)\n    if (code \n 0) then\n      print(\nHTTP request failed\n)\n    else\n      print(code, data)\n    end\n  end)\n\n\n\n\nhttp.get()\n\n\nExecutes a HTTP GET request. Note that concurrent requests are not supported.\n\n\nSyntax\n\n\nhttp.get(url, headers, callback)\n\n\nParameters\n\n\n\n\nurl\n The URL to fetch, including the \nhttp://\n or \nhttps://\n prefix\n\n\nheaders\n Optional additional headers to append, \nincluding \\r\\n\n; may be \nnil\n\n\ncallback\n The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments \nstatus_code\n, \nbody\n and \nheaders\n. In case of an error \nstatus_code\n is set to -1.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nhttp.get(\nhttp://httpbin.org/ip\n, nil, function(code, data)\n    if (code \n 0) then\n      print(\nHTTP request failed\n)\n    else\n      print(code, data)\n    end\n  end)\n\n\n\n\nhttp.post()\n\n\nExecutes a HTTP POST request. Note that concurrent requests are not supported.\n\n\nSyntax\n\n\nhttp.post(url, headers, body, callback)\n\n\nParameters\n\n\n\n\nurl\n The URL to fetch, including the \nhttp://\n or \nhttps://\n prefix\n\n\nheaders\n Optional additional headers to append, \nincluding \\r\\n\n; may be \nnil\n\n\nbody\n The body to post; must already be encoded in the appropriate format, but may be empty\n\n\ncallback\n The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments \nstatus_code\n, \nbody\n and \nheaders\n. In case of an error \nstatus_code\n is set to -1.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nhttp.post('http://httpbin.org/post',\n  'Content-Type: application/json\\r\\n',\n  '{\nhello\n:\nworld\n}',\n  function(code, data)\n    if (code \n 0) then\n      print(\nHTTP request failed\n)\n    else\n      print(code, data)\n    end\n  end)\n\n\n\n\nhttp.put()\n\n\nExecutes a HTTP PUT request. Note that concurrent requests are not supported.\n\n\nSyntax\n\n\nhttp.put(url, headers, body, callback)\n\n\nParameters\n\n\n\n\nurl\n The URL to fetch, including the \nhttp://\n or \nhttps://\n prefix\n\n\nheaders\n Optional additional headers to append, \nincluding \\r\\n\n; may be \nnil\n\n\nbody\n The body to post; must already be encoded in the appropriate format, but may be empty\n\n\ncallback\n The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments \nstatus_code\n, \nbody\n and \nheaders\n. In case of an error \nstatus_code\n is set to -1.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nhttp.put('http://httpbin.org/put',\n  'Content-Type: text/plain\\r\\n',\n  'Hello!\\nStay a while, and listen...\\n',\n  function(code, data)\n    if (code \n 0) then\n      print(\nHTTP request failed\n)\n    else\n      print(code, data)\n    end\n  end)\n\n\n\n\nhttp.request()\n\n\nExecute a custom HTTP request for any HTTP method. Note that concurrent requests are not supported.\n\n\nSyntax\n\n\nhttp.request(url, method, headers, body, callback)\n\n\nParameters\n\n\n\n\nurl\n The URL to fetch, including the \nhttp://\n or \nhttps://\n prefix\n\n\nmethod\n The HTTP method to use, e.g. \"GET\", \"HEAD\", \"OPTIONS\" etc\n\n\nheaders\n Optional additional headers to append, \nincluding \\r\\n\n; may be \nnil\n\n\nbody\n The body to post; must already be encoded in the appropriate format, but may be empty\n\n\ncallback\n The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments \nstatus_code\n, \nbody\n and \nheaders\n. In case of an error \nstatus_code\n is set to -1.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nhttp.request(\nhttp://httpbin.org\n, \nHEAD\n, \n, \n, \n  function(code, data)\n    if (code \n 0) then\n      print(\nHTTP request failed\n)\n    else\n      print(code, data)\n    end\n  end)", 
            "title": "http"
        }, 
        {
            "location": "/en/modules/http/#http-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-01-15  esphttpclient  /  Vowstar  Vowstar  http.c     Basic HTTP  client  module that provides an interface to do GET/POST/PUT/DELETE over HTTP(S), as well as customized requests. Due to the memory constraints on ESP8266, the supported page/body size is limited by available memory. Attempting to receive pages larger than this will fail. If larger page/body sizes are necessary, consider using  net.createConnection()  and stream in the data.   Attention  It is  not  possible to execute concurrent HTTP requests using this module.    Each request method takes a callback which is invoked when the response has been received from the server. The first argument is the status code, which is either a regular HTTP status code, or -1 to denote a DNS, connection or out-of-memory failure, or a timeout (currently at 10 seconds).  For each operation it is possible to provide custom HTTP headers or override standard headers. By default the  Host  header is deduced from the URL and  User-Agent  is  ESP8266 . Note, however, that the  Connection  header  can not  be overridden! It is always set to  close .  HTTP redirects (HTTP status 300-308) are followed automatically up to a limit of 20 to avoid the dreaded redirect loops.  When the callback is invoked, it is passed the HTTP status code, the body as it was received, and a table of the response headers. All the header names have been lower cased\nto make it easy to access. If there are multiple headers of the same name, then only the last one is returned.  SSL/TLS support  Take note of constraints documented in the  net module .", 
            "title": "HTTP Module"
        }, 
        {
            "location": "/en/modules/http/#httpdelete", 
            "text": "Executes a HTTP DELETE request. Note that concurrent requests are not supported.", 
            "title": "http.delete()"
        }, 
        {
            "location": "/en/modules/http/#syntax", 
            "text": "http.delete(url, headers, body, callback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/http/#parameters", 
            "text": "url  The URL to fetch, including the  http://  or  https://  prefix  headers  Optional additional headers to append,  including \\r\\n ; may be  nil  body  The body to post; must already be encoded in the appropriate format, but may be empty  callback  The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments  status_code ,  body  and  headers . In case of an error  status_code  is set to -1.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/http/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/http/#example", 
            "text": "http.delete('http://httpbin.org/delete',\n   ,\n   ,\n  function(code, data)\n    if (code   0) then\n      print( HTTP request failed )\n    else\n      print(code, data)\n    end\n  end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/http/#httpget", 
            "text": "Executes a HTTP GET request. Note that concurrent requests are not supported.", 
            "title": "http.get()"
        }, 
        {
            "location": "/en/modules/http/#syntax_1", 
            "text": "http.get(url, headers, callback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/http/#parameters_1", 
            "text": "url  The URL to fetch, including the  http://  or  https://  prefix  headers  Optional additional headers to append,  including \\r\\n ; may be  nil  callback  The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments  status_code ,  body  and  headers . In case of an error  status_code  is set to -1.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/http/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/http/#example_1", 
            "text": "http.get( http://httpbin.org/ip , nil, function(code, data)\n    if (code   0) then\n      print( HTTP request failed )\n    else\n      print(code, data)\n    end\n  end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/http/#httppost", 
            "text": "Executes a HTTP POST request. Note that concurrent requests are not supported.", 
            "title": "http.post()"
        }, 
        {
            "location": "/en/modules/http/#syntax_2", 
            "text": "http.post(url, headers, body, callback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/http/#parameters_2", 
            "text": "url  The URL to fetch, including the  http://  or  https://  prefix  headers  Optional additional headers to append,  including \\r\\n ; may be  nil  body  The body to post; must already be encoded in the appropriate format, but may be empty  callback  The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments  status_code ,  body  and  headers . In case of an error  status_code  is set to -1.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/http/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/http/#example_2", 
            "text": "http.post('http://httpbin.org/post',\n  'Content-Type: application/json\\r\\n',\n  '{ hello : world }',\n  function(code, data)\n    if (code   0) then\n      print( HTTP request failed )\n    else\n      print(code, data)\n    end\n  end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/http/#httpput", 
            "text": "Executes a HTTP PUT request. Note that concurrent requests are not supported.", 
            "title": "http.put()"
        }, 
        {
            "location": "/en/modules/http/#syntax_3", 
            "text": "http.put(url, headers, body, callback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/http/#parameters_3", 
            "text": "url  The URL to fetch, including the  http://  or  https://  prefix  headers  Optional additional headers to append,  including \\r\\n ; may be  nil  body  The body to post; must already be encoded in the appropriate format, but may be empty  callback  The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments  status_code ,  body  and  headers . In case of an error  status_code  is set to -1.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/http/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/http/#example_3", 
            "text": "http.put('http://httpbin.org/put',\n  'Content-Type: text/plain\\r\\n',\n  'Hello!\\nStay a while, and listen...\\n',\n  function(code, data)\n    if (code   0) then\n      print( HTTP request failed )\n    else\n      print(code, data)\n    end\n  end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/http/#httprequest", 
            "text": "Execute a custom HTTP request for any HTTP method. Note that concurrent requests are not supported.", 
            "title": "http.request()"
        }, 
        {
            "location": "/en/modules/http/#syntax_4", 
            "text": "http.request(url, method, headers, body, callback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/http/#parameters_4", 
            "text": "url  The URL to fetch, including the  http://  or  https://  prefix  method  The HTTP method to use, e.g. \"GET\", \"HEAD\", \"OPTIONS\" etc  headers  Optional additional headers to append,  including \\r\\n ; may be  nil  body  The body to post; must already be encoded in the appropriate format, but may be empty  callback  The callback function to be invoked when the response has been received or an error occurred; it is invoked with the arguments  status_code ,  body  and  headers . In case of an error  status_code  is set to -1.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/http/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/http/#example_4", 
            "text": "http.request( http://httpbin.org ,  HEAD ,  ,  , \n  function(code, data)\n    if (code   0) then\n      print( HTTP request failed )\n    else\n      print(code, data)\n    end\n  end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/hx711/", 
            "text": "HX711 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-10-09\n\n\nChris Takahashi\n\n\nChris Takahashi\n\n\nhx711.c\n\n\n\n\n\n\n\n\nThis module provides access to an \nHX711 load cell amplifier/ADC\n. The HX711 is an inexpensive 24bit ADC with programmable 128x, 64x, and 32x gain. Currently only channel A at 128x gain is supported.\n\n\nNote: To save ROM image space, this module is not compiled into the firmware by default.\n\n\nhx711.init()\n\n\nInitialize io pins for hx711 clock and data.\n\n\nSyntax\n\n\nhx711.init(clk, data)\n\n\nParameters\n\n\n\n\nclk\n pin the hx711 clock signal is connected to\n\n\ndata\n pin the hx711 data signal is connected to\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- Initialize the hx711 with clk on pin 5 and data on pin 6\nhx711.init(5,6)\n\n\n\n\nhx711.read()\n\n\nRead digital loadcell ADC value.\n\n\nSyntax\n\n\nhx711.read(mode)\n\n\nParameters\n\n\nmode\n ADC mode.  This parameter is currently ignored and reserved to ensure backward compatability if support for additional modes is added. Currently only channel A @ 128 gain is supported.\n\n\n\n\n\n\n\n\nmode\n\n\nchannel\n\n\ngain\n\n\n\n\n\n\n\n\n\n\n0\n\n\nA\n\n\n128\n\n\n\n\n\n\n\n\nReturns\n\n\na number (24 bit signed ADC value extended to the machine int size)\n\n\nExample\n\n\n-- Read ch A with 128 gain.\nraw_data = hx711.read(0)", 
            "title": "hx711"
        }, 
        {
            "location": "/en/modules/hx711/#hx711-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-10-09  Chris Takahashi  Chris Takahashi  hx711.c     This module provides access to an  HX711 load cell amplifier/ADC . The HX711 is an inexpensive 24bit ADC with programmable 128x, 64x, and 32x gain. Currently only channel A at 128x gain is supported.  Note: To save ROM image space, this module is not compiled into the firmware by default.", 
            "title": "HX711 Module"
        }, 
        {
            "location": "/en/modules/hx711/#hx711init", 
            "text": "Initialize io pins for hx711 clock and data.", 
            "title": "hx711.init()"
        }, 
        {
            "location": "/en/modules/hx711/#syntax", 
            "text": "hx711.init(clk, data)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/hx711/#parameters", 
            "text": "clk  pin the hx711 clock signal is connected to  data  pin the hx711 data signal is connected to", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/hx711/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/hx711/#example", 
            "text": "-- Initialize the hx711 with clk on pin 5 and data on pin 6\nhx711.init(5,6)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/hx711/#hx711read", 
            "text": "Read digital loadcell ADC value.", 
            "title": "hx711.read()"
        }, 
        {
            "location": "/en/modules/hx711/#syntax_1", 
            "text": "hx711.read(mode)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/hx711/#parameters_1", 
            "text": "mode  ADC mode.  This parameter is currently ignored and reserved to ensure backward compatability if support for additional modes is added. Currently only channel A @ 128 gain is supported.     mode  channel  gain      0  A  128", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/hx711/#returns_1", 
            "text": "a number (24 bit signed ADC value extended to the machine int size)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/hx711/#example_1", 
            "text": "-- Read ch A with 128 gain.\nraw_data = hx711.read(0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/i2c/", 
            "text": "I\u00b2C Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-22\n\n\nZeroday\n\n\nZeroday\n\n\ni2c.c\n\n\n\n\n\n\n\n\ni2c.address()\n\n\nSetup I\u00b2C address and read/write mode for the next transfer.\n\n\nSyntax\n\n\ni2c.address(id, device_addr, direction)\n\n\nParameters\n\n\n\n\nid\n always 0\n\n\ndevice_addr\n 7-bit device address, remember that \nin I\u00b2C \ndevice_addr\n represents the upper 7 bits\n followed by a single \ndirection\n bit\n\n\ndirection\n \ni2c.TRANSMITTER\n for writing mode , \ni2c. RECEIVER\n for reading mode\n\n\n\n\nReturns\n\n\ntrue\n if ack received, \nfalse\n if no ack received.\n\n\nSee also\n\n\ni2c.read()\n\n\ni2c.read()\n\n\nRead data for variable number of bytes.\n\n\nSyntax\n\n\ni2c.read(id, len)\n\n\nParameters\n\n\n\n\nid\n always 0\n\n\nlen\n number of data bytes\n\n\n\n\nReturns\n\n\nstring\n of received data\n\n\nExample\n\n\nid  = 0\nsda = 1\nscl = 2\n\n-- initialize i2c, set pin1 as sda, set pin2 as scl\ni2c.setup(id, sda, scl, i2c.SLOW)\n\n-- user defined function: read from reg_addr content of dev_addr\nfunction read_reg(dev_addr, reg_addr)\n    i2c.start(id)\n    i2c.address(id, dev_addr, i2c.TRANSMITTER)\n    i2c.write(id, reg_addr)\n    i2c.stop(id)\n    i2c.start(id)\n    i2c.address(id, dev_addr, i2c.RECEIVER)\n    c = i2c.read(id, 1)\n    i2c.stop(id)\n    return c\nend\n\n-- get content of register 0xAA of device 0x77\nreg = read_reg(0x77, 0xAA)\nprint(string.byte(reg))\n\n\n\n\nSee also\n\n\ni2c.write()\n\n\ni2c.setup()\n\n\nInitialize the I\u00b2C module.\n\n\nSyntax\n\n\ni2c.setup(id, pinSDA, pinSCL, speed)\n\n\nParameters\n\n\n\n\nid\n always 0\n\n\npinSDA\n 1~12, IO index\n\n\npinSCL\n 1~12, IO index\n\n\nspeed\n only \ni2c.SLOW\n supported\n\n\n\n\nReturns\n\n\nspeed\n the selected speed\n\n\nSee also\n\n\ni2c.read()\n\n\ni2c.start()\n\n\nSend an I\u00b2C start condition.\n\n\nSyntax\n\n\ni2c.start(id)\n\n\nParameters\n\n\nid\n always 0\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\ni2c.read()\n\n\ni2c.stop()\n\n\nSend an I\u00b2C stop condition.\n\n\nSyntax\n\n\ni2c.stop(id)\n\n\nParameters\n\n\nid\n always 0\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\ni2c.read()\n\n\ni2c.write()\n\n\nWrite data to I\u00b2C bus. Data items can be multiple numbers, strings or lua tables.\n\n\nSyntax\n\n\ni2c.write(id, data1[, data2[, ..., datan]])\n\n\nParameters\n\n\n\n\nid\n always 0\n\n\ndata\n data can be numbers, string or lua table.\n\n\n\n\nReturns\n\n\nnumber\n number of bytes written\n\n\nExample\n\n\ni2c.write(0, \nhello\n, \nworld\n)\n\n\n\n\nSee also\n\n\ni2c.read()", 
            "title": "i2c"
        }, 
        {
            "location": "/en/modules/i2c/#i2c-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-22  Zeroday  Zeroday  i2c.c", 
            "title": "I\u00b2C Module"
        }, 
        {
            "location": "/en/modules/i2c/#i2caddress", 
            "text": "Setup I\u00b2C address and read/write mode for the next transfer.", 
            "title": "i2c.address()"
        }, 
        {
            "location": "/en/modules/i2c/#syntax", 
            "text": "i2c.address(id, device_addr, direction)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/i2c/#parameters", 
            "text": "id  always 0  device_addr  7-bit device address, remember that  in I\u00b2C  device_addr  represents the upper 7 bits  followed by a single  direction  bit  direction   i2c.TRANSMITTER  for writing mode ,  i2c. RECEIVER  for reading mode", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/i2c/#returns", 
            "text": "true  if ack received,  false  if no ack received.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/i2c/#see-also", 
            "text": "i2c.read()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/i2c/#i2cread", 
            "text": "Read data for variable number of bytes.", 
            "title": "i2c.read()"
        }, 
        {
            "location": "/en/modules/i2c/#syntax_1", 
            "text": "i2c.read(id, len)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/i2c/#parameters_1", 
            "text": "id  always 0  len  number of data bytes", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/i2c/#returns_1", 
            "text": "string  of received data", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/i2c/#example", 
            "text": "id  = 0\nsda = 1\nscl = 2\n\n-- initialize i2c, set pin1 as sda, set pin2 as scl\ni2c.setup(id, sda, scl, i2c.SLOW)\n\n-- user defined function: read from reg_addr content of dev_addr\nfunction read_reg(dev_addr, reg_addr)\n    i2c.start(id)\n    i2c.address(id, dev_addr, i2c.TRANSMITTER)\n    i2c.write(id, reg_addr)\n    i2c.stop(id)\n    i2c.start(id)\n    i2c.address(id, dev_addr, i2c.RECEIVER)\n    c = i2c.read(id, 1)\n    i2c.stop(id)\n    return c\nend\n\n-- get content of register 0xAA of device 0x77\nreg = read_reg(0x77, 0xAA)\nprint(string.byte(reg))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/i2c/#see-also_1", 
            "text": "i2c.write()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/i2c/#i2csetup", 
            "text": "Initialize the I\u00b2C module.", 
            "title": "i2c.setup()"
        }, 
        {
            "location": "/en/modules/i2c/#syntax_2", 
            "text": "i2c.setup(id, pinSDA, pinSCL, speed)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/i2c/#parameters_2", 
            "text": "id  always 0  pinSDA  1~12, IO index  pinSCL  1~12, IO index  speed  only  i2c.SLOW  supported", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/i2c/#returns_2", 
            "text": "speed  the selected speed", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/i2c/#see-also_2", 
            "text": "i2c.read()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/i2c/#i2cstart", 
            "text": "Send an I\u00b2C start condition.", 
            "title": "i2c.start()"
        }, 
        {
            "location": "/en/modules/i2c/#syntax_3", 
            "text": "i2c.start(id)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/i2c/#parameters_3", 
            "text": "id  always 0", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/i2c/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/i2c/#see-also_3", 
            "text": "i2c.read()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/i2c/#i2cstop", 
            "text": "Send an I\u00b2C stop condition.", 
            "title": "i2c.stop()"
        }, 
        {
            "location": "/en/modules/i2c/#syntax_4", 
            "text": "i2c.stop(id)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/i2c/#parameters_4", 
            "text": "id  always 0", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/i2c/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/i2c/#see-also_4", 
            "text": "i2c.read()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/i2c/#i2cwrite", 
            "text": "Write data to I\u00b2C bus. Data items can be multiple numbers, strings or lua tables.", 
            "title": "i2c.write()"
        }, 
        {
            "location": "/en/modules/i2c/#syntax_5", 
            "text": "i2c.write(id, data1[, data2[, ..., datan]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/i2c/#parameters_5", 
            "text": "id  always 0  data  data can be numbers, string or lua table.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/i2c/#returns_5", 
            "text": "number  number of bytes written", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/i2c/#example_1", 
            "text": "i2c.write(0,  hello ,  world )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/i2c/#see-also_5", 
            "text": "i2c.read()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/l3g4200d/", 
            "text": "L3G4200D Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-04-09\n\n\nJason Schmidlapp\n\n\nJason Schmidlapp\n\n\nl3g4200d.c\n\n\n\n\n\n\n\n\nThis module provides access to the \nL3G4200D\n three axis digital gyroscope.\n\n\nl3g4200d.read()\n\n\nSamples the sensor and returns the gyroscope output.\n\n\nSyntax\n\n\nl3g4200d.read()\n\n\nReturns\n\n\nX,Y,Z gyroscope output\n\n\nExample\n\n\nlocal sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nl3g4200d.setup()\nlocal x,y,z = l3g4200d.read()\nprint(string.format(\nX = %d, Y = %d, Z = %d\n, x, y, z)\n\n\n\n\nl3g4200d.init()\n\n\nInitializes the module and sets the pin configuration.\n\n\n\n\nAttention\n\n\nThis function is deprecated and will be removed in upcoming releases. Use \nl3g4200d.setup()\n instead.\n\n\n\n\nSyntax\n\n\nl3g4200d.init(sda, scl)\n\n\nParameters\n\n\n\n\nsda\n data pin\n\n\nscl\n clock pin\n\n\n\n\nReturns\n\n\nnil\n\n\nl3g4200d.setup()\n\n\nInitializes the module.\n\n\nSyntax\n\n\nl3g4200d.setup()\n\n\nParameters\n\n\nNone\n\n\nReturns\n\n\nnil", 
            "title": "l3g4200d"
        }, 
        {
            "location": "/en/modules/l3g4200d/#l3g4200d-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-04-09  Jason Schmidlapp  Jason Schmidlapp  l3g4200d.c     This module provides access to the  L3G4200D  three axis digital gyroscope.", 
            "title": "L3G4200D Module"
        }, 
        {
            "location": "/en/modules/l3g4200d/#l3g4200dread", 
            "text": "Samples the sensor and returns the gyroscope output.", 
            "title": "l3g4200d.read()"
        }, 
        {
            "location": "/en/modules/l3g4200d/#syntax", 
            "text": "l3g4200d.read()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/l3g4200d/#returns", 
            "text": "X,Y,Z gyroscope output", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/l3g4200d/#example", 
            "text": "local sda, scl = 1, 2\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nl3g4200d.setup()\nlocal x,y,z = l3g4200d.read()\nprint(string.format( X = %d, Y = %d, Z = %d , x, y, z)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/l3g4200d/#l3g4200dinit", 
            "text": "Initializes the module and sets the pin configuration.   Attention  This function is deprecated and will be removed in upcoming releases. Use  l3g4200d.setup()  instead.", 
            "title": "l3g4200d.init()"
        }, 
        {
            "location": "/en/modules/l3g4200d/#syntax_1", 
            "text": "l3g4200d.init(sda, scl)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/l3g4200d/#parameters", 
            "text": "sda  data pin  scl  clock pin", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/l3g4200d/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/l3g4200d/#l3g4200dsetup", 
            "text": "Initializes the module.", 
            "title": "l3g4200d.setup()"
        }, 
        {
            "location": "/en/modules/l3g4200d/#syntax_2", 
            "text": "l3g4200d.setup()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/l3g4200d/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/l3g4200d/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mcp4725/", 
            "text": "MCP4725 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2017-05-10\n\n\ndnc40085\n\n\ndnc40085\n\n\nmcp4725.c\n\n\n\n\n\n\n\n\nThis module provides access to the \nMCP4725 12-bit Digital to Analog Converter\n.\n\n\n!!!important:\n    VDD is the power supply pin for the device. The voltage at the VDD pin is used as the supply input as well as the DAC reference input. The power supply at the VDD pin should be clean as possible for good DAC performance.\n\n\n!!!note:\n    The MCP4725 device address contains four fixed bits ( 1100 = device code) and three address bits (A2, A1, A0). The A2 and A1 bits are hard-wired during manufacturing, and A0 bit is determined by the logic state of A0 pin. The A0 pin can be connected to VDD or VSS , or actively driven by digital logic levels. The address pin(A0) can be actively driven by a GPIO to act as a chip select, allowing more than 2 devices to be used on the same bus.  \n\n\nmcp4725.read()\n\n\nGets contents of the dac register and EEPROM.\n\n\nSyntax\n\n\nmcp4725.read({[a0], [a1], [a2]})\n\n\nParameters\n\n\n\n\nA0\n Address bit 0. This bit is user configurable via MCP4725 pin 6(A0). (valid states: 0 or 1) (default: 0)\n\n\nA1\n Address bit 1. This bit is hard-wired during manufacture. (valid states: 0 or 1) (default: 0)\n\n\nNote: Modules purchased from Adafruit have this bit(A1) set high(1).\n\n\n\n\n\n\nA2\n Address bit 2. This bit is hard-wired during manufacture. (valid states: 0 or 1) (default: 0)\n\n\n\n\nReturns\n\n\n\n\ncur_pwrdn\n Current power down configuration value. \n\n\ncur_val\n Current value stored in dac register.\n\n\neeprom_pwrdn\n Power down configuration stored in EEPROM.\n\n\neeprom_val\n DAC value stored in EEPROM.\n\n\neeprom_state\n EEPROM write status\n\n\n0\n EEPROM write is incomplete.\n\n\n1\n EEPROM write has completed\n\n\n\n\n\n\npor_state\n Power-On-Reset status;\n\n\n0\n The MCP4725 is performing reset and is not ready.\n\n\n1\n The MCP4725 has sucessfully performed reset.\n\n\n\n\n\n\n\n\nExample\n\n\n-- Get current configuration using default i2c address 0x60(A0=0, A1=0, A2=0).\ndo\nlocal ID = 0\nlocal SDA = 6\nlocal SCL = 5\n\ni2c.setup(ID, SDA, SCL, i2c.SLOW)\n\nlocal cur_pwrdn, cur_val, eeprom_pwrdn, eeprom_val, eeprom_state, por_state = mcp4725.read()\n\nprint(\n\\n Current configuration:\\n\\tpower down value: \n..cur_pwrdn..\n\\n\\tdac value: \n..cur_val)\nprint(\n Configuration stored in EEPROM:\\n\\tpower down value: \n..eeprom_pwrdn..\n\\n\\tdac value: \n..eeprom_val)\nprint(\n EEPROM write state: \n..(eeprom_state==1 and \nCompleted\n or \nincomplete\n))\nprint(\n Power-On-Reset state: \n..(por_state==1 and \nCompleted\n or \nincomplete\n))\nend\n\n-- Get current configuration using default i2c address 0x60(A0=0, A1=0, A2=0).\n-- The MCP4725's address pin(A0) is being driven with gpio 4(pin 2).\ndo\nlocal ID = 0\nlocal SDA = 6\nlocal SCL = 5\nlocal mcp4725_chip_sel = 2\n\ni2c.setup(ID, SDA, SCL, i2c.SLOW)\ngpio.mode(mcp4725_chip_sel, gpio.OUTPUT, gpio.PULLUP)\n\ngpio.write(mcp4725_chip_sel, 1)\nlocal cur_pwrdn, cur_val, eeprom_pwrdn, eeprom_val, eeprom_state, por_state = mcp4725.read({A0=1})\ngpio.write(mcp4725_chip_sel, 0)\n\nprint(\n\\n Current configuration:\\n\\tpower down value: \n..cur_pwrdn..\n\\n\\tdac value: \n..cur_val)\nprint(\n Configuration stored in EEPROM:\\n\\tpower down value: \n..eeprom_pwrdn..\n\\n\\tdac value: \n..eeprom_val)\nprint(\n EEPROM write state: \n..(eeprom_state==1 and \nCompleted\n or \nincomplete\n))\nprint(\n Power-On-Reset state: \n..(por_state==1 and \nCompleted\n or \nincomplete\n))\nend\n\n\n\n\nSee also\n\n\n\n\ni2c.setup()\n\n\n\n\nmcp4725.write()\n\n\nWrite configuration to dac register or dac register and eeprom.\n\n\nSyntax\n\n\nmcp4725.write({[a0], [a1], [a2], value, [pwrdn], [save]})\n\n\nParameters\n\n\n\n\nA0\n Address bit 0. This bit is user configurable via MCP4725 pin 6(A0). (valid states: 0 or 1) (default: 0)\n\n\nA1\n Address bit 1. This bit is hard-wired during manufacture. (valid states: 0 or 1) (default: 0)\n\n\nNote: Modules purchased from Adafruit have this bit(A1) set high(1).\n\n\n\n\n\n\nA2\n Address bit 2. This bit is hard-wired during manufacture. (valid states: 0 or 1) (default: 0)\n\n\nvalue\n The value to be used to configure DAC (and EEPROM). (Range: 0 - 4095)\n\n\npwrdn\n Set power down bits.\n\n\nmcp4725.PWRDN_NONE\n MCP4725 output enabled. (Default)\n\n\nmcp4725.PWRDN_1K\n MCP4725 output disabled, output pulled to ground via 1K restistor.\n\n\nmcp4725.PWRDN_100K\n MCP4725 output disabled, output pulled to ground via 100K restistor.\n\n\nmcp4725.PWRDN_500K\n MCP4725 output disabled, output pulled to ground via 500K restistor.\n\n\n\n\n\n\nsave\n Save pwrdn and dac values to EEPROM. (Values are loaded on power-up or during reset.)\n\n\ntrue\n Save configuration to EEPROM.\n\n\nfalse\n Do not save configuration to EEPROM. (Default) \n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n\n-- Set current configuration using default i2c address 0x60(A0=0, A1=0, A2=0).\ndo\n  local ID = 0\n  local SDA = 6\n  local SCL = 5\n\n  i2c.setup(ID, SDA, SCL, i2c.SLOW)\n  mcp4725.write({value=2048})\nend\n\n-- Set current configuration and save to EEPROM using default i2c address 0x60(A0=0, A1=0, A2=0).\ndo\n  local ID = 0\n  local SDA = 6\n  local SCL = 5\n\n  i2c.setup(ID, SDA, SCL, i2c.SLOW)\n  mcp4725.write({value=2048, save=true})\nend\n\n-- Set current configuration using default i2c address 0x60(A0=0, A1=0, A2=0).\n-- The MCP4725's address pin(A0) is being driven with gpio 4(pin 2).\ndo\n  local ID = 0\n  local SDA = 6\n  local SCL = 5\n  local mcp4725_chip_sel = 2\n\n  i2c.setup(ID, SDA, SCL, i2c.SLOW)\n  gpio.mode(mcp4725_chip_sel, gpio.OUTPUT, gpio.PULLUP)\n\n  gpio.write(mcp4725_chip_sel, 1)\n  mcp4725.read({A0=1, value})\n  gpio.write(mcp4725_chip_sel, 0)\nend\n\n\n\n\nSee also\n\n\n\n\ni2c.setup()", 
            "title": "mcp4725"
        }, 
        {
            "location": "/en/modules/mcp4725/#mcp4725-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2017-05-10  dnc40085  dnc40085  mcp4725.c     This module provides access to the  MCP4725 12-bit Digital to Analog Converter .  !!!important:\n    VDD is the power supply pin for the device. The voltage at the VDD pin is used as the supply input as well as the DAC reference input. The power supply at the VDD pin should be clean as possible for good DAC performance.  !!!note:\n    The MCP4725 device address contains four fixed bits ( 1100 = device code) and three address bits (A2, A1, A0). The A2 and A1 bits are hard-wired during manufacturing, and A0 bit is determined by the logic state of A0 pin. The A0 pin can be connected to VDD or VSS , or actively driven by digital logic levels. The address pin(A0) can be actively driven by a GPIO to act as a chip select, allowing more than 2 devices to be used on the same bus.", 
            "title": "MCP4725 Module"
        }, 
        {
            "location": "/en/modules/mcp4725/#mcp4725read", 
            "text": "Gets contents of the dac register and EEPROM.", 
            "title": "mcp4725.read()"
        }, 
        {
            "location": "/en/modules/mcp4725/#syntax", 
            "text": "mcp4725.read({[a0], [a1], [a2]})", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mcp4725/#parameters", 
            "text": "A0  Address bit 0. This bit is user configurable via MCP4725 pin 6(A0). (valid states: 0 or 1) (default: 0)  A1  Address bit 1. This bit is hard-wired during manufacture. (valid states: 0 or 1) (default: 0)  Note: Modules purchased from Adafruit have this bit(A1) set high(1).    A2  Address bit 2. This bit is hard-wired during manufacture. (valid states: 0 or 1) (default: 0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mcp4725/#returns", 
            "text": "cur_pwrdn  Current power down configuration value.   cur_val  Current value stored in dac register.  eeprom_pwrdn  Power down configuration stored in EEPROM.  eeprom_val  DAC value stored in EEPROM.  eeprom_state  EEPROM write status  0  EEPROM write is incomplete.  1  EEPROM write has completed    por_state  Power-On-Reset status;  0  The MCP4725 is performing reset and is not ready.  1  The MCP4725 has sucessfully performed reset.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mcp4725/#example", 
            "text": "-- Get current configuration using default i2c address 0x60(A0=0, A1=0, A2=0).\ndo\nlocal ID = 0\nlocal SDA = 6\nlocal SCL = 5\n\ni2c.setup(ID, SDA, SCL, i2c.SLOW)\n\nlocal cur_pwrdn, cur_val, eeprom_pwrdn, eeprom_val, eeprom_state, por_state = mcp4725.read()\n\nprint( \\n Current configuration:\\n\\tpower down value:  ..cur_pwrdn.. \\n\\tdac value:  ..cur_val)\nprint(  Configuration stored in EEPROM:\\n\\tpower down value:  ..eeprom_pwrdn.. \\n\\tdac value:  ..eeprom_val)\nprint(  EEPROM write state:  ..(eeprom_state==1 and  Completed  or  incomplete ))\nprint(  Power-On-Reset state:  ..(por_state==1 and  Completed  or  incomplete ))\nend\n\n-- Get current configuration using default i2c address 0x60(A0=0, A1=0, A2=0).\n-- The MCP4725's address pin(A0) is being driven with gpio 4(pin 2).\ndo\nlocal ID = 0\nlocal SDA = 6\nlocal SCL = 5\nlocal mcp4725_chip_sel = 2\n\ni2c.setup(ID, SDA, SCL, i2c.SLOW)\ngpio.mode(mcp4725_chip_sel, gpio.OUTPUT, gpio.PULLUP)\n\ngpio.write(mcp4725_chip_sel, 1)\nlocal cur_pwrdn, cur_val, eeprom_pwrdn, eeprom_val, eeprom_state, por_state = mcp4725.read({A0=1})\ngpio.write(mcp4725_chip_sel, 0)\n\nprint( \\n Current configuration:\\n\\tpower down value:  ..cur_pwrdn.. \\n\\tdac value:  ..cur_val)\nprint(  Configuration stored in EEPROM:\\n\\tpower down value:  ..eeprom_pwrdn.. \\n\\tdac value:  ..eeprom_val)\nprint(  EEPROM write state:  ..(eeprom_state==1 and  Completed  or  incomplete ))\nprint(  Power-On-Reset state:  ..(por_state==1 and  Completed  or  incomplete ))\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/mcp4725/#see-also", 
            "text": "i2c.setup()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/mcp4725/#mcp4725write", 
            "text": "Write configuration to dac register or dac register and eeprom.", 
            "title": "mcp4725.write()"
        }, 
        {
            "location": "/en/modules/mcp4725/#syntax_1", 
            "text": "mcp4725.write({[a0], [a1], [a2], value, [pwrdn], [save]})", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mcp4725/#parameters_1", 
            "text": "A0  Address bit 0. This bit is user configurable via MCP4725 pin 6(A0). (valid states: 0 or 1) (default: 0)  A1  Address bit 1. This bit is hard-wired during manufacture. (valid states: 0 or 1) (default: 0)  Note: Modules purchased from Adafruit have this bit(A1) set high(1).    A2  Address bit 2. This bit is hard-wired during manufacture. (valid states: 0 or 1) (default: 0)  value  The value to be used to configure DAC (and EEPROM). (Range: 0 - 4095)  pwrdn  Set power down bits.  mcp4725.PWRDN_NONE  MCP4725 output enabled. (Default)  mcp4725.PWRDN_1K  MCP4725 output disabled, output pulled to ground via 1K restistor.  mcp4725.PWRDN_100K  MCP4725 output disabled, output pulled to ground via 100K restistor.  mcp4725.PWRDN_500K  MCP4725 output disabled, output pulled to ground via 500K restistor.    save  Save pwrdn and dac values to EEPROM. (Values are loaded on power-up or during reset.)  true  Save configuration to EEPROM.  false  Do not save configuration to EEPROM. (Default)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mcp4725/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mcp4725/#example_1", 
            "text": "-- Set current configuration using default i2c address 0x60(A0=0, A1=0, A2=0).\ndo\n  local ID = 0\n  local SDA = 6\n  local SCL = 5\n\n  i2c.setup(ID, SDA, SCL, i2c.SLOW)\n  mcp4725.write({value=2048})\nend\n\n-- Set current configuration and save to EEPROM using default i2c address 0x60(A0=0, A1=0, A2=0).\ndo\n  local ID = 0\n  local SDA = 6\n  local SCL = 5\n\n  i2c.setup(ID, SDA, SCL, i2c.SLOW)\n  mcp4725.write({value=2048, save=true})\nend\n\n-- Set current configuration using default i2c address 0x60(A0=0, A1=0, A2=0).\n-- The MCP4725's address pin(A0) is being driven with gpio 4(pin 2).\ndo\n  local ID = 0\n  local SDA = 6\n  local SCL = 5\n  local mcp4725_chip_sel = 2\n\n  i2c.setup(ID, SDA, SCL, i2c.SLOW)\n  gpio.mode(mcp4725_chip_sel, gpio.OUTPUT, gpio.PULLUP)\n\n  gpio.write(mcp4725_chip_sel, 1)\n  mcp4725.read({A0=1, value})\n  gpio.write(mcp4725_chip_sel, 0)\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/mcp4725/#see-also_1", 
            "text": "i2c.setup()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/mdns/", 
            "text": "mDNS Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-02-24\n\n\nPhilip Gladstone\n\n\nPhilip Gladstone\n\n\nmdns.c\n\n\n\n\n\n\n\n\nMulticast DNS\n is used as part of Bonjour / Zeroconf. This allows system to identify themselves and the services that they provide on a local area network. Clients are then able to discover these systems and connect to them. \n\n\nmdns.register()\n\n\nRegister a hostname and start the mDNS service. If the service is already running, then it will be restarted with the new parameters.\n\n\nSyntax\n\n\nmdns.register(hostname [, attributes])\n\n\nParameters\n\n\n\n\nhostname\n The hostname for this device. Alphanumeric characters are best.\n\n\nattributes\n A optional table of options. The keys must all be strings.\n\n\n\n\nThe \nattributes\n contains two sorts of attributes -- those with specific names, and those that are service specific. \nRFC 6763\n \ndefines how extra, service specific, attributes are encoded into the DNS. One example is that if the device supports printing, then the queue name can \nbe specified as an additional attribute. This module supports up to 10 such attributes.\n\n\nThe specific names are:\n\n\n\n\nport\n The port number for the service. Default value is 80.\n\n\nservice\n The name of the service. Default value is 'http'.\n\n\ndescription\n A short phrase (under 63 characters) describing the service. Default is the hostname.\n\n\n\n\nReturns\n\n\nnil\n\n\nErrors\n\n\nVarious errors can be generated during argument validation. The NodeMCU must have an IP address at the time of the call, otherwise an error is thrown.\n\n\nExample\n\n\nmdns.register(\"fishtank\", {hardware='NodeMCU'})\n\n\n\nUsing \ndns-sd\n on OS X, you can see \nfishtank.local\n as providing the \n_http._tcp\n service. You can also browse directly to \nfishtank.local\n. In Safari you can get all the mDNS web pages as part of your bookmarks menu.\n\n\nmdns.register(\"fishtank\", { description=\"Top Fishtank\", service=\"http\", port=80, location='Living Room' })\n\n\n\nmdns.close()\n\n\nShut down the mDNS service. This is not normally needed.\n\n\nSyntax\n\n\nmdns.close()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil", 
            "title": "mdns"
        }, 
        {
            "location": "/en/modules/mdns/#mdns-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-02-24  Philip Gladstone  Philip Gladstone  mdns.c     Multicast DNS  is used as part of Bonjour / Zeroconf. This allows system to identify themselves and the services that they provide on a local area network. Clients are then able to discover these systems and connect to them.", 
            "title": "mDNS Module"
        }, 
        {
            "location": "/en/modules/mdns/#mdnsregister", 
            "text": "Register a hostname and start the mDNS service. If the service is already running, then it will be restarted with the new parameters.", 
            "title": "mdns.register()"
        }, 
        {
            "location": "/en/modules/mdns/#syntax", 
            "text": "mdns.register(hostname [, attributes])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mdns/#parameters", 
            "text": "hostname  The hostname for this device. Alphanumeric characters are best.  attributes  A optional table of options. The keys must all be strings.   The  attributes  contains two sorts of attributes -- those with specific names, and those that are service specific.  RFC 6763  \ndefines how extra, service specific, attributes are encoded into the DNS. One example is that if the device supports printing, then the queue name can \nbe specified as an additional attribute. This module supports up to 10 such attributes.  The specific names are:   port  The port number for the service. Default value is 80.  service  The name of the service. Default value is 'http'.  description  A short phrase (under 63 characters) describing the service. Default is the hostname.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mdns/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mdns/#errors", 
            "text": "Various errors can be generated during argument validation. The NodeMCU must have an IP address at the time of the call, otherwise an error is thrown.", 
            "title": "Errors"
        }, 
        {
            "location": "/en/modules/mdns/#example", 
            "text": "mdns.register(\"fishtank\", {hardware='NodeMCU'})  Using  dns-sd  on OS X, you can see  fishtank.local  as providing the  _http._tcp  service. You can also browse directly to  fishtank.local . In Safari you can get all the mDNS web pages as part of your bookmarks menu.  mdns.register(\"fishtank\", { description=\"Top Fishtank\", service=\"http\", port=80, location='Living Room' })", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/mdns/#mdnsclose", 
            "text": "Shut down the mDNS service. This is not normally needed.", 
            "title": "mdns.close()"
        }, 
        {
            "location": "/en/modules/mdns/#syntax_1", 
            "text": "mdns.close()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mdns/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mdns/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mqtt/", 
            "text": "MQTT Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-01-23\n\n\nStephen Robinson\n, \nTuan PM\n\n\nVowstar\n\n\nmqtt.c\n\n\n\n\n\n\n\n\nThe client adheres to version 3.1.1 of the \nMQTT\n protocol. Make sure that your broker supports and is correctly configured for version 3.1.1. The client is backwards incompatible with brokers running MQTT 3.1.\n\n\nmqtt.Client()\n\n\nCreates a MQTT client.\n\n\nSyntax\n\n\nmqtt.Client(clientid, keepalive[, username, password, cleansession])\n\n\nParameters\n\n\n\n\nclientid\n client ID\n\n\nkeepalive\n keepalive seconds\n\n\nusername\n user name\n\n\npassword\n user password\n\n\ncleansession\n 0/1 for \nfalse\n/\ntrue\n. Default is 1 (\ntrue\n).\n\n\n\n\nReturns\n\n\nMQTT client\n\n\nExample\n\n\n-- init mqtt client without logins, keepalive timer 120s\nm = mqtt.Client(\nclientid\n, 120)\n\n-- init mqtt client with logins, keepalive timer 120sec\nm = mqtt.Client(\nclientid\n, 120, \nuser\n, \npassword\n)\n\n-- setup Last Will and Testament (optional)\n-- Broker will publish a message with qos = 0, retain = 0, data = \noffline\n \n-- to topic \n/lwt\n if client don't send keepalive packet\nm:lwt(\n/lwt\n, \noffline\n, 0, 0)\n\nm:on(\nconnect\n, function(client) print (\nconnected\n) end)\nm:on(\noffline\n, function(client) print (\noffline\n) end)\n\n-- on publish message receive event\nm:on(\nmessage\n, function(client, topic, data) \n  print(topic .. \n:\n ) \n  if data ~= nil then\n    print(data)\n  end\nend)\n\n-- for TLS: m:connect(\n192.168.11.118\n, secure-port, 1)\nm:connect(\n192.168.11.118\n, 1883, 0, function(client)\n  print(\nconnected\n)\n  -- Calling subscribe/publish only makes sense once the connection\n  -- was successfully established. You can do that either here in the\n  -- 'connect' callback or you need to otherwise make sure the\n  -- connection was established (e.g. tracking connection status or in\n  -- m:on(\nconnect\n, function)).\n\n  -- subscribe topic with qos = 0\n  client:subscribe(\n/topic\n, 0, function(client) print(\nsubscribe success\n) end)\n  -- publish a message with data = hello, QoS = 0, retain = 0\n  client:publish(\n/topic\n, \nhello\n, 0, 0, function(client) print(\nsent\n) end)\nend,\nfunction(client, reason)\n  print(\nfailed reason: \n .. reason)\nend)\n\nm:close();\n-- you can call m:connect again\n\n\n\n\nMQTT Client\n\n\nmqtt.client:close()\n\n\nCloses connection to the broker.\n\n\nSyntax\n\n\nmqtt:close()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\ntrue\n on success, \nfalse\n otherwise\n\n\nmqtt.client:connect()\n\n\nConnects to the broker specified by the given host, port, and secure options.\n\n\nSyntax\n\n\nmqtt:connect(host[, port[, secure[, autoreconnect]]][, function(client)[, function(client, reason)]])\n\n\nParameters\n\n\n\n\nhost\n host, domain or IP (string)\n\n\nport\n broker port (number), default 1883\n\n\nsecure\n 0/1 for \nfalse\n/\ntrue\n, default 0. Take note of constraints documented in the \nnet module\n.\n\n\nautoreconnect\n 0/1 for \nfalse\n/\ntrue\n, default 0. This option is \ndeprecated\n.\n\n\nfunction(client)\n callback function for when the connection was established\n\n\nfunction(client, reason)\n callback function for when the connection could not be established. No further callbacks should be called.\n\n\n\n\nReturns\n\n\ntrue\n on success, \nfalse\n otherwise\n\n\nNotes\n\n\nDon't use \nautoreconnect\n. Let me repeat that, don't use \nautoreconnect\n. You should handle the errors explicitly and appropriately for\nyour application. In particular, the default for \ncleansession\n above is \ntrue\n, so all subscriptions are destroyed when the connection\nis lost for any reason.\n\n\nIn order to acheive a consistent connection, handle errors in the error callback. For example:\n\n\nfunction handle_mqtt_error(client, reason) \n  tmr.create():alarm(10 * 1000, tmr.ALARM_SINGLE, do_mqtt_connect)\nend\n\nfunction do_mqtt_connect()\n  mqtt:connect(\nserver\n, function(client) print(\nconnected\n) end, handle_mqtt_error)\nend\n\n\n\n\nIn reality, the connected function should do something useful!\n\n\nThis is the description of how the \nautoreconnect\n functionality may (or may not) work.\n\n\n\n\nWhen \nautoreconnect\n is set, then the connection will be re-established when it breaks. No error indication will be given (but all the\nsubscriptions may be lost if \ncleansession\n is true). However, if the\nvery first connection fails, then no reconnect attempt is made, and the error is signalled through the callback (if any). The first connection\nis considered a success if the client connects to a server and gets back a good response packet in response to its MQTT connection request.\nThis implies (for example) that the username and password are correct.\n\n\n\n\nConnection failure callback reason codes:\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmqtt.CONN_FAIL_SERVER_NOT_FOUND\n\n\n-5\n\n\nThere is no broker listening at the specified IP Address and Port\n\n\n\n\n\n\nmqtt.CONN_FAIL_NOT_A_CONNACK_MSG\n\n\n-4\n\n\nThe response from the broker was not a CONNACK as required by the protocol\n\n\n\n\n\n\nmqtt.CONN_FAIL_DNS\n\n\n-3\n\n\nDNS Lookup failed\n\n\n\n\n\n\nmqtt.CONN_FAIL_TIMEOUT_RECEIVING\n\n\n-2\n\n\nTimeout waiting for a CONNACK from the broker\n\n\n\n\n\n\nmqtt.CONN_FAIL_TIMEOUT_SENDING\n\n\n-1\n\n\nTimeout trying to send the Connect message\n\n\n\n\n\n\nmqtt.CONNACK_ACCEPTED\n\n\n0\n\n\nNo errors. \nNote: This will not trigger a failure callback.\n\n\n\n\n\n\nmqtt.CONNACK_REFUSED_PROTOCOL_VER\n\n\n1\n\n\nThe broker is not a 3.1.1 MQTT broker.\n\n\n\n\n\n\nmqtt.CONNACK_REFUSED_ID_REJECTED\n\n\n2\n\n\nThe specified ClientID was rejected by the broker. (See \nmqtt.Client()\n)\n\n\n\n\n\n\nmqtt.CONNACK_REFUSED_SERVER_UNAVAILABLE\n\n\n3\n\n\nThe server is unavailable.\n\n\n\n\n\n\nmqtt.CONNACK_REFUSED_BAD_USER_OR_PASS\n\n\n4\n\n\nThe broker refused the specified username or password.\n\n\n\n\n\n\nmqtt.CONNACK_REFUSED_NOT_AUTHORIZED\n\n\n5\n\n\nThe username is not authorized.\n\n\n\n\n\n\n\n\nmqtt.client:lwt()\n\n\nSetup \nLast Will and Testament\n (optional). A broker will publish a message with qos = 0, retain = 0, data = \"offline\" to topic \"/lwt\" if client does not send keepalive packet.\n\n\nSyntax\n\n\nmqtt:lwt(topic, message[, qos[, retain]])\n\n\nParameters\n\n\n\n\ntopic\n the topic to publish to (string)\n\n\nmessage\n the message to publish, (buffer or string)\n\n\nqos\n QoS level, default 0\n\n\nretain\n retain flag, default 0\n\n\n\n\nReturns\n\n\nnil\n\n\nmqtt.client:on()\n\n\nRegisters a callback function for an event.\n\n\nSyntax\n\n\nmqtt:on(event, function(client[, topic[, message]]))\n\n\nParameters\n\n\n\n\nevent\n can be \"connect\", \"message\" or \"offline\"\n\n\nfunction(client[, topic[, message]])\n callback function. The first parameter is the client. If event is \"message\", the 2nd and 3rd param are received topic and message (strings).\n\n\n\n\nReturns\n\n\nnil\n\n\nmqtt.client:publish()\n\n\nPublishes a message.\n\n\nSyntax\n\n\nmqtt:publish(topic, payload, qos, retain[, function(client)])\n\n\nParameters\n\n\n\n\ntopic\n the topic to publish to (\ntopic string\n)\n\n\nmessage\n the message to publish, (buffer or string)\n\n\nqos\n QoS level\n\n\nretain\n retain flag\n\n\nfunction(client)\n optional callback fired when PUBACK received.  NOTE: When calling publish() more than once, the last callback function defined will be called for ALL publish commands.\n\n\n\n\nReturns\n\n\ntrue\n on success, \nfalse\n otherwise\n\n\nmqtt.client:subscribe()\n\n\nSubscribes to one or several topics.\n\n\nSyntax\n\n\nmqtt:subscribe(topic, qos[, function(client)])\n\n\nmqtt:subscribe(table[, function(client)])\n\n\nParameters\n\n\n\n\ntopic\n a \ntopic string\n\n\nqos\n QoS subscription level, default 0\n\n\ntable\n array of 'topic, qos' pairs to subscribe to\n\n\nfunction(client)\n optional callback fired when subscription(s) succeeded.  NOTE: When calling subscribe() more than once, the last callback function defined will be called for ALL subscribe commands.\n\n\n\n\nReturns\n\n\ntrue\n on success, \nfalse\n otherwise\n\n\nExample\n\n\n-- subscribe topic with qos = 0\nm:subscribe(\n/topic\n,0, function(conn) print(\nsubscribe success\n) end)\n\n-- or subscribe multiple topic (topic/0, qos = 0; topic/1, qos = 1; topic2 , qos = 2)\nm:subscribe({[\ntopic/0\n]=0,[\ntopic/1\n]=1,topic2=2}, function(conn) print(\nsubscribe success\n) end)\n\n\n\n\n\n\nCaution\n\n\nRather than calling \nsubscribe\n multiple times you should use the multiple topics syntax shown in the above example if you want to subscribe to more than one topic at once.\n\n\n\n\nmqtt.client:unsubscribe()\n\n\nUnsubscribes from one or several topics.\n\n\nSyntax\n\n\nmqtt:unsubscribe(topic[, function(client)])\n\n\nmqtt:unsubscribe(table[, function(client)])\n\n\nParameters\n\n\n\n\ntopic\n a \ntopic string\n\n\ntable\n array of 'topic, anything' pairs to unsubscribe from\n\n\nfunction(client)\n optional callback fired when unsubscription(s) succeeded.  NOTE: When calling unsubscribe() more than once, the last callback function defined will be called for ALL unsubscribe commands.\n\n\n\n\nReturns\n\n\ntrue\n on success, \nfalse\n otherwise\n\n\nExample\n\n\n-- unsubscribe topic\nm:unsubscribe(\n/topic\n, function(conn) print(\nunsubscribe success\n) end)\n\n-- or unsubscribe multiple topic (topic/0; topic/1; topic2)\nm:unsubscribe({[\ntopic/0\n]=0,[\ntopic/1\n]=0,topic2=\nanything\n}, function(conn) print(\nunsubscribe success\n) end)", 
            "title": "mqtt"
        }, 
        {
            "location": "/en/modules/mqtt/#mqtt-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-01-23  Stephen Robinson ,  Tuan PM  Vowstar  mqtt.c     The client adheres to version 3.1.1 of the  MQTT  protocol. Make sure that your broker supports and is correctly configured for version 3.1.1. The client is backwards incompatible with brokers running MQTT 3.1.", 
            "title": "MQTT Module"
        }, 
        {
            "location": "/en/modules/mqtt/#mqttclient", 
            "text": "Creates a MQTT client.", 
            "title": "mqtt.Client()"
        }, 
        {
            "location": "/en/modules/mqtt/#syntax", 
            "text": "mqtt.Client(clientid, keepalive[, username, password, cleansession])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mqtt/#parameters", 
            "text": "clientid  client ID  keepalive  keepalive seconds  username  user name  password  user password  cleansession  0/1 for  false / true . Default is 1 ( true ).", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mqtt/#returns", 
            "text": "MQTT client", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mqtt/#example", 
            "text": "-- init mqtt client without logins, keepalive timer 120s\nm = mqtt.Client( clientid , 120)\n\n-- init mqtt client with logins, keepalive timer 120sec\nm = mqtt.Client( clientid , 120,  user ,  password )\n\n-- setup Last Will and Testament (optional)\n-- Broker will publish a message with qos = 0, retain = 0, data =  offline  \n-- to topic  /lwt  if client don't send keepalive packet\nm:lwt( /lwt ,  offline , 0, 0)\n\nm:on( connect , function(client) print ( connected ) end)\nm:on( offline , function(client) print ( offline ) end)\n\n-- on publish message receive event\nm:on( message , function(client, topic, data) \n  print(topic ..  :  ) \n  if data ~= nil then\n    print(data)\n  end\nend)\n\n-- for TLS: m:connect( 192.168.11.118 , secure-port, 1)\nm:connect( 192.168.11.118 , 1883, 0, function(client)\n  print( connected )\n  -- Calling subscribe/publish only makes sense once the connection\n  -- was successfully established. You can do that either here in the\n  -- 'connect' callback or you need to otherwise make sure the\n  -- connection was established (e.g. tracking connection status or in\n  -- m:on( connect , function)).\n\n  -- subscribe topic with qos = 0\n  client:subscribe( /topic , 0, function(client) print( subscribe success ) end)\n  -- publish a message with data = hello, QoS = 0, retain = 0\n  client:publish( /topic ,  hello , 0, 0, function(client) print( sent ) end)\nend,\nfunction(client, reason)\n  print( failed reason:   .. reason)\nend)\n\nm:close();\n-- you can call m:connect again", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/mqtt/#mqtt-client", 
            "text": "", 
            "title": "MQTT Client"
        }, 
        {
            "location": "/en/modules/mqtt/#mqttclientclose", 
            "text": "Closes connection to the broker.", 
            "title": "mqtt.client:close()"
        }, 
        {
            "location": "/en/modules/mqtt/#syntax_1", 
            "text": "mqtt:close()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mqtt/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mqtt/#returns_1", 
            "text": "true  on success,  false  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mqtt/#mqttclientconnect", 
            "text": "Connects to the broker specified by the given host, port, and secure options.", 
            "title": "mqtt.client:connect()"
        }, 
        {
            "location": "/en/modules/mqtt/#syntax_2", 
            "text": "mqtt:connect(host[, port[, secure[, autoreconnect]]][, function(client)[, function(client, reason)]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mqtt/#parameters_2", 
            "text": "host  host, domain or IP (string)  port  broker port (number), default 1883  secure  0/1 for  false / true , default 0. Take note of constraints documented in the  net module .  autoreconnect  0/1 for  false / true , default 0. This option is  deprecated .  function(client)  callback function for when the connection was established  function(client, reason)  callback function for when the connection could not be established. No further callbacks should be called.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mqtt/#returns_2", 
            "text": "true  on success,  false  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mqtt/#notes", 
            "text": "Don't use  autoreconnect . Let me repeat that, don't use  autoreconnect . You should handle the errors explicitly and appropriately for\nyour application. In particular, the default for  cleansession  above is  true , so all subscriptions are destroyed when the connection\nis lost for any reason.  In order to acheive a consistent connection, handle errors in the error callback. For example:  function handle_mqtt_error(client, reason) \n  tmr.create():alarm(10 * 1000, tmr.ALARM_SINGLE, do_mqtt_connect)\nend\n\nfunction do_mqtt_connect()\n  mqtt:connect( server , function(client) print( connected ) end, handle_mqtt_error)\nend  In reality, the connected function should do something useful!  This is the description of how the  autoreconnect  functionality may (or may not) work.   When  autoreconnect  is set, then the connection will be re-established when it breaks. No error indication will be given (but all the\nsubscriptions may be lost if  cleansession  is true). However, if the\nvery first connection fails, then no reconnect attempt is made, and the error is signalled through the callback (if any). The first connection\nis considered a success if the client connects to a server and gets back a good response packet in response to its MQTT connection request.\nThis implies (for example) that the username and password are correct.", 
            "title": "Notes"
        }, 
        {
            "location": "/en/modules/mqtt/#connection-failure-callback-reason-codes", 
            "text": "Constant  Value  Description      mqtt.CONN_FAIL_SERVER_NOT_FOUND  -5  There is no broker listening at the specified IP Address and Port    mqtt.CONN_FAIL_NOT_A_CONNACK_MSG  -4  The response from the broker was not a CONNACK as required by the protocol    mqtt.CONN_FAIL_DNS  -3  DNS Lookup failed    mqtt.CONN_FAIL_TIMEOUT_RECEIVING  -2  Timeout waiting for a CONNACK from the broker    mqtt.CONN_FAIL_TIMEOUT_SENDING  -1  Timeout trying to send the Connect message    mqtt.CONNACK_ACCEPTED  0  No errors.  Note: This will not trigger a failure callback.    mqtt.CONNACK_REFUSED_PROTOCOL_VER  1  The broker is not a 3.1.1 MQTT broker.    mqtt.CONNACK_REFUSED_ID_REJECTED  2  The specified ClientID was rejected by the broker. (See  mqtt.Client() )    mqtt.CONNACK_REFUSED_SERVER_UNAVAILABLE  3  The server is unavailable.    mqtt.CONNACK_REFUSED_BAD_USER_OR_PASS  4  The broker refused the specified username or password.    mqtt.CONNACK_REFUSED_NOT_AUTHORIZED  5  The username is not authorized.", 
            "title": "Connection failure callback reason codes:"
        }, 
        {
            "location": "/en/modules/mqtt/#mqttclientlwt", 
            "text": "Setup  Last Will and Testament  (optional). A broker will publish a message with qos = 0, retain = 0, data = \"offline\" to topic \"/lwt\" if client does not send keepalive packet.", 
            "title": "mqtt.client:lwt()"
        }, 
        {
            "location": "/en/modules/mqtt/#syntax_3", 
            "text": "mqtt:lwt(topic, message[, qos[, retain]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mqtt/#parameters_3", 
            "text": "topic  the topic to publish to (string)  message  the message to publish, (buffer or string)  qos  QoS level, default 0  retain  retain flag, default 0", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mqtt/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mqtt/#mqttclienton", 
            "text": "Registers a callback function for an event.", 
            "title": "mqtt.client:on()"
        }, 
        {
            "location": "/en/modules/mqtt/#syntax_4", 
            "text": "mqtt:on(event, function(client[, topic[, message]]))", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mqtt/#parameters_4", 
            "text": "event  can be \"connect\", \"message\" or \"offline\"  function(client[, topic[, message]])  callback function. The first parameter is the client. If event is \"message\", the 2nd and 3rd param are received topic and message (strings).", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mqtt/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mqtt/#mqttclientpublish", 
            "text": "Publishes a message.", 
            "title": "mqtt.client:publish()"
        }, 
        {
            "location": "/en/modules/mqtt/#syntax_5", 
            "text": "mqtt:publish(topic, payload, qos, retain[, function(client)])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mqtt/#parameters_5", 
            "text": "topic  the topic to publish to ( topic string )  message  the message to publish, (buffer or string)  qos  QoS level  retain  retain flag  function(client)  optional callback fired when PUBACK received.  NOTE: When calling publish() more than once, the last callback function defined will be called for ALL publish commands.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mqtt/#returns_5", 
            "text": "true  on success,  false  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mqtt/#mqttclientsubscribe", 
            "text": "Subscribes to one or several topics.", 
            "title": "mqtt.client:subscribe()"
        }, 
        {
            "location": "/en/modules/mqtt/#syntax_6", 
            "text": "mqtt:subscribe(topic, qos[, function(client)])  mqtt:subscribe(table[, function(client)])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mqtt/#parameters_6", 
            "text": "topic  a  topic string  qos  QoS subscription level, default 0  table  array of 'topic, qos' pairs to subscribe to  function(client)  optional callback fired when subscription(s) succeeded.  NOTE: When calling subscribe() more than once, the last callback function defined will be called for ALL subscribe commands.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mqtt/#returns_6", 
            "text": "true  on success,  false  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mqtt/#example_1", 
            "text": "-- subscribe topic with qos = 0\nm:subscribe( /topic ,0, function(conn) print( subscribe success ) end)\n\n-- or subscribe multiple topic (topic/0, qos = 0; topic/1, qos = 1; topic2 , qos = 2)\nm:subscribe({[ topic/0 ]=0,[ topic/1 ]=1,topic2=2}, function(conn) print( subscribe success ) end)   Caution  Rather than calling  subscribe  multiple times you should use the multiple topics syntax shown in the above example if you want to subscribe to more than one topic at once.", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/mqtt/#mqttclientunsubscribe", 
            "text": "Unsubscribes from one or several topics.", 
            "title": "mqtt.client:unsubscribe()"
        }, 
        {
            "location": "/en/modules/mqtt/#syntax_7", 
            "text": "mqtt:unsubscribe(topic[, function(client)])  mqtt:unsubscribe(table[, function(client)])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/mqtt/#parameters_7", 
            "text": "topic  a  topic string  table  array of 'topic, anything' pairs to unsubscribe from  function(client)  optional callback fired when unsubscription(s) succeeded.  NOTE: When calling unsubscribe() more than once, the last callback function defined will be called for ALL unsubscribe commands.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/mqtt/#returns_7", 
            "text": "true  on success,  false  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/mqtt/#example_2", 
            "text": "-- unsubscribe topic\nm:unsubscribe( /topic , function(conn) print( unsubscribe success ) end)\n\n-- or unsubscribe multiple topic (topic/0; topic/1; topic2)\nm:unsubscribe({[ topic/0 ]=0,[ topic/1 ]=0,topic2= anything }, function(conn) print( unsubscribe success ) end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/", 
            "text": "net Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-22\n\n\nZeroday\n\n\nPhoeniX\n\n\nnet.c\n\n\n\n\n\n\n\n\n TLS operations was moved to the \nTLS\n module \n\n\nConstants\n\n\nConstants to be used in other functions: \nnet.TCP\n, \nnet.UDP\n\n\nnet.createConnection()\n\n\nCreates a client.\n\n\nSyntax\n\n\nnet.createConnection([type[, secure]])\n\n\nParameters\n\n\n\n\ntype\n \nnet.TCP\n (default) or \nnet.UDP\n\n\nsecure\n 1 for encrypted, 0 for plain (default)\n\n\n\n\n\n\nAttention\n\n\nThis will change in upcoming releases so that \nnet.createConnection\n will always create an unencrypted TCP connection.\n\n\nThere's no such thing as a UDP \nconnection\n because UDP is connection\nless\n. Thus no connection \ntype\n parameter should be required. For UDP use \nnet.createUDPSocket()\n instead. To create \nsecure\n connections use \ntls.createConnection()\n instead.\n\n\n\n\nReturns\n\n\n\n\nfor \nnet.TCP\n - net.socket sub module\n\n\nfor \nnet.UDP\n - net.udpsocket sub module\n\n\nfor \nnet.TCP\n with \nsecure\n - tls.socket sub module\n\n\n\n\nExample\n\n\nnet.createConnection(net.TCP, 0)\n\n\n\n\nSee also\n\n\nnet.createServer()\n, \nnet.createUDPSocket()\n, \ntls.createConnection()\n\n\nnet.createServer()\n\n\nCreates a server.\n\n\nSyntax\n\n\nnet.createServer([type[, timeout]])\n\n\nParameters\n\n\n\n\ntype\n \nnet.TCP\n (default) or \nnet.UDP\n\n\ntimeout\n for a TCP server timeout is 1~28'800 seconds, 30 sec by default (for an inactive client to be disconnected)\n\n\n\n\n\n\nAttention\n\n\nThe \ntype\n parameter will be removed in upcoming releases so that \nnet.createServer\n will always create a TCP-based server. For UDP use \nnet.createUDPSocket()\n instead.\n\n\n\n\nReturns\n\n\n\n\nfor \nnet.TCP\n - net.server sub module\n\n\nfor \nnet.UDP\n - net.udpsocket sub module\n\n\n\n\nExample\n\n\nnet.createServer(net.TCP, 30) -- 30s timeout\n\n\n\n\nSee also\n\n\nnet.createConnection()\n, \nnet.createUDPSocket()\n\n\nnet.createUDPSocket()\n\n\nCreates an UDP socket.\n\n\nSyntax\n\n\nnet.createUDPSocket()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnet.udpsocket sub module\n\n\nSee also\n\n\nnet.createConnection()\n\n\nnet.multicastJoin()\n\n\nJoin multicast group.\n\n\nSyntax\n\n\nnet.multicastJoin(if_ip, multicast_ip)\n\n\nParameters\n\n\n\n\nif_ip\n string containing the interface ip to join the multicast group. \"any\" or \"\" affects all interfaces.\n\n\nmulticast_ip\n of the group to join\n\n\n\n\nReturns\n\n\nnil\n\n\nnet.multicastLeave()\n\n\nLeave multicast group.\n\n\nSyntax\n\n\nnet.multicastLeave(if_ip, multicast_ip)\n\n\nParameters\n\n\n\n\nif_ip\n string containing the interface ip to leave the multicast group. \"any\" or \"\" affects all interfaces.\n\n\nmulticast_ip\n of the group to leave\n\n\n\n\nReturns\n\n\nnil\n\n\nnet.server Module\n\n\nnet.server:close()\n\n\nCloses the server.\n\n\nSyntax\n\n\nnet.server.close()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- creates a server\nsv = net.createServer(net.TCP, 30)\n-- closes the server\nsv:close()\n\n\n\n\nSee also\n\n\nnet.createServer()\n\n\nnet.server:listen()\n\n\nListen on port from IP address.\n\n\nSyntax\n\n\nnet.server.listen([port],[ip],function(net.socket))\n\n\nParameters\n\n\n\n\nport\n port number, can be omitted (random port will be chosen)\n\n\nip\n IP address string, can be omitted\n\n\nfunction(net.socket)\n callback function, pass to caller function as param if a connection is created successfully\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- server listens on 80, if data received, print data to console and send \nhello world\n back to caller\n-- 30s time out for a inactive client\nsv = net.createServer(net.TCP, 30)\n\nfunction receiver(sck, data)\n  print(data)\n  sck:close()\nend\n\nif sv then\n  sv:listen(80, function(conn)\n    conn:on(\nreceive\n, receiver)\n    conn:send(\nhello world\n)\n  end)\nend\n\n\n\n\nSee also\n\n\nnet.createServer()\n\n\nnet.server:getaddr()\n\n\nReturns server local address/port.\n\n\nSyntax\n\n\nnet.server.getaddr()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nport\n, \nip\n (or \nnil, nil\n if not listening)\n\n\nSee also\n\n\nnet.server:listen()\n\n\nnet.socket Module\n\n\nnet.socket:close()\n\n\nCloses socket.\n\n\nSyntax\n\n\nclose()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nnet.createServer()\n\n\nnet.socket:connect()\n\n\nConnect to a remote server.\n\n\nSyntax\n\n\nconnect(port, ip|domain)\n\n\nParameters\n\n\n\n\nport\n port number\n\n\nip\n IP address or domain name string\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nnet.socket:on()\n\n\nnet.socket:dns()\n\n\nProvides DNS resolution for a hostname.\n\n\nSyntax\n\n\ndns(domain, function(net.socket, ip))\n\n\nParameters\n\n\n\n\ndomain\n domain name\n\n\nfunction(net.socket, ip)\n callback function. The first parameter is the socket, the second parameter is the IP address as a string.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nsk = net.createConnection(net.TCP, 0)\nsk:dns(\nwww.nodemcu.com\n, function(conn, ip) print(ip) end)\nsk = nil\n\n\n\n\nSee also\n\n\nnet.createServer()\n\n\nnet.socket:getpeer()\n\n\nRetrieve port and ip of remote peer.\n\n\nSyntax\n\n\ngetpeer()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nport\n, \nip\n (or \nnil, nil\n if not connected)\n\n\nnet.socket:getaddr()\n\n\nRetrieve local port and ip of socket.\n\n\nSyntax\n\n\ngetaddr()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nport\n, \nip\n (or \nnil, nil\n if not connected)\n\n\nnet.socket:hold()\n\n\nThrottle data reception by placing a request to block the TCP receive function. This request is not effective immediately, Espressif recommends to call it while reserving 5*1460 bytes of memory.\n\n\nSyntax\n\n\nhold()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nnet.socket:unhold()\n\n\nnet.socket:on()\n\n\nRegister callback functions for specific events.\n\n\nSyntax\n\n\non(event, function())\n\n\nParameters\n\n\n\n\nevent\n string, which can be \"connection\", \"reconnection\", \"disconnection\", \"receive\" or \"sent\"\n\n\nfunction(net.socket[, string])\n callback function. Can be \nnil\n to remove callback.\n\n\n\n\nThe first parameter of callback is the socket.\n\n\n\n\nIf event is \"receive\", the second parameter is the received data as string.\n\n\nIf event is \"disconnection\" or \"reconnection\", the second parameter is error code.\n\n\n\n\nIf reconnection event is specified, disconnection receives only \"normal close\" events.\n\n\nOtherwise, all connection errors (with normal close) passed to disconnection event.\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nsrv = net.createConnection(net.TCP, 0)\nsrv:on(\nreceive\n, function(sck, c) print(c) end)\n-- Wait for connection before sending.\nsrv:on(\nconnection\n, function(sck, c)\n  -- 'Connection: close' rather than 'Connection: keep-alive' to have server \n  -- initiate a close of the connection after final response (frees memory \n  -- earlier here), https://tools.ietf.org/html/rfc7230#section-6.6 \n  sck:send(\nGET /get HTTP/1.1\\r\\nHost: httpbin.org\\r\\nConnection: close\\r\\nAccept: */*\\r\\n\\r\\n\n)\nend)\nsrv:connect(80,\nhttpbin.org\n)\n\n\n\n\n\n\nNote\n\n\nThe \nreceive\n event is fired for every network frame! Hence, if the data sent to the device exceeds 1460 bytes (derived from \nEthernet frame size\n) it will fire more than once. There may be other situations where incoming data is split across multiple frames (e.g. HTTP POST with \nmultipart/form-data\n). You need to manually buffer the data and find means to determine if all data was received.\n\n\n\n\nlocal buffer = nil\n\nsrv:on(\nreceive\n, function(sck, c)\n  if buffer == nil then\n    buffer = c\n  else\n    buffer = buffer .. c\n  end\nend)\n-- throttling could be implemented using socket:hold()\n-- example: https://github.com/nodemcu/nodemcu-firmware/blob/master/lua_examples/pcm/play_network.lua#L83\n\n\n\n\nSee also\n\n\n\n\nnet.createServer()\n\n\nnet.socket:hold()\n\n\n\n\nnet.socket:send()\n\n\nSends data to remote peer.\n\n\nSyntax\n\n\nsend(string[, function(sent)])\n\n\nsck:send(data, fnA)\n is functionally equivalent to \nsck:send(data) sck:on(\"sent\", fnA)\n.\n\n\nParameters\n\n\n\n\nstring\n data in string which will be sent to server\n\n\nfunction(sent)\n callback function for sending string\n\n\n\n\nReturns\n\n\nnil\n\n\nNote\n\n\nMultiple consecutive \nsend()\n calls aren't guaranteed to work (and often don't) as network requests are treated as separate tasks by the SDK. Instead, subscribe to the \"sent\" event on the socket and send additional data (or close) in that callback. See \n#730\n for details.\n\n\nExample\n\n\nsrv = net.createServer(net.TCP)\n\nfunction receiver(sck, data)\n  local response = {}\n\n  -- if you're sending back HTML over HTTP you'll want something like this instead\n  -- local response = {\nHTTP/1.0 200 OK\\r\\nServer: NodeMCU on ESP8266\\r\\nContent-Type: text/html\\r\\n\\r\\n\n}\n\n  response[#response + 1] = \nlots of data\n\n  response[#response + 1] = \neven more data\n\n  response[#response + 1] = \ne.g. content read from a file\n\n\n  -- sends and removes the first element from the 'response' table\n  local function send(localSocket)\n    if #response \n 0 then\n      localSocket:send(table.remove(response, 1))\n    else\n      localSocket:close()\n      response = nil\n    end\n  end\n\n  -- triggers the send() function again once the first chunk of data was sent\n  sck:on(\nsent\n, send)\n\n  send(sck)\nend\n\nsrv:listen(80, function(conn)\n  conn:on(\nreceive\n, receiver)\nend)\n\n\n\n\nIf you do not or can not keep all the data you send back in memory at one time (remember that \nresponse\n is an aggregation) you may use explicit callbacks instead of building up a table like so:\n\n\nsck:send(header, function() \n  local data1 = \nsome large chunk of dynamically loaded data\n\n  sck:send(data1, function()\n    local data2 = \neven more dynamically loaded data\n\n    sck:send(data2, function(sk) \n      sk:close()\n    end)\n  end)\nend)\n\n\n\n\nSee also\n\n\nnet.socket:on()\n\n\nnet.socket:ttl()\n\n\nChanges or retrieves Time-To-Live value on socket.\n\n\nSyntax\n\n\nttl([ttl])\n\n\nParameters\n\n\n\n\nttl\n (optional) new time-to-live value\n\n\n\n\nReturns\n\n\ncurrent / new ttl value\n\n\nExample\n\n\nsk = net.createConnection(net.TCP, 0)\nsk:connect(80, '192.168.1.1')\nsk:ttl(1) -- restrict frames to single subnet\n\n\n\n\nSee also\n\n\nnet.createConnection()\n\n\nnet.socket:unhold()\n\n\nUnblock TCP receiving data by revocation of a preceding \nhold()\n.\n\n\nSyntax\n\n\nunhold()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nnet.socket:hold()\n\n\nnet.udpsocket Module\n\n\nRemember that in contrast to TCP \nUDP\n is connectionless. Therefore, there is a minor but natural mismatch as for TCP/UDP functions in this module. While you would call \nnet.createConnection()\n for TCP it is \nnet.createUDPSocket()\n for UDP.\n\n\nOther points worth noting:\n\n\n\n\nUDP sockets do not have a connection callback for the \nlisten\n function.\n\n\nUDP sockets do not have a \nconnect\n function. Remote IP and port thus need to be defined in \nsend()\n.\n\n\nUDP socket's \nreceive\n callback receives port/ip after the \ndata\n argument.\n\n\n\n\nnet.udpsocket:close()\n\n\nCloses UDP socket.\n\n\nThe syntax and functional identical to \nnet.socket:close()\n.\n\n\nnet.udpsocket:listen()\n\n\nListen on port from IP address.\n\n\nThe syntax and functional similar to \nnet.server:listen()\n, but callback parameter is not provided.\n\n\nnet.udpsocket:on()\n\n\nRegister callback functions for specific events.\n\n\nThe syntax and functional similar to \nnet.socket:on()\n. However, only \"receive\", \"sent\" and \"dns\" are supported events.\n\n\n\n\nNote\n\n\nThe \nreceive\n callback receives \nport\n and \nip\n \nafter\n the \ndata\n argument.\n\n\n\n\nnet.udpsocket:send()\n\n\nSends data to specific remote peer.\n\n\nSyntax\n\n\nsend(port, ip, data)\n\n\nParameters\n\n\n\n\nport\n remote socket port\n\n\nip\n remote socket IP\n\n\ndata\n the payload to send\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nudpSocket = net.createUDPSocket()\nudpSocket:listen(5000)\nudpSocket:on(\nreceive\n, function(s, data, port, ip)\n    print(string.format(\nreceived '%s' from %s:%d\n, data, ip, port))\n    s:send(port, ip, \necho: \n .. data)\nend)\nport, ip = udpSocket:getaddr()\nprint(string.format(\nlocal UDP socket address / port: %s:%d\n, ip, port))\n\n\n\n\nOn *nix systems that can then be tested by issuing\n\n\necho -n \nfoo\n | nc -w1 -u \ndevice-IP-address\n 5000\n\n\n\n\nnet.udpsocket:dns()\n\n\nProvides DNS resolution for a hostname.\n\n\nThe syntax and functional identical to \nnet.socket:dns()\n.\n\n\nnet.udpsocket:getaddr()\n\n\nRetrieve local port and ip of socket.\n\n\nThe syntax and functional identical to \nnet.socket:getaddr()\n.\n\n\nnet.udpsocket:ttl()\n\n\nChanges or retrieves Time-To-Live value on socket.\n\n\nThe syntax and functional identical to \nnet.socket:ttl()\n.\n\n\nnet.dns Module\n\n\nnet.dns.getdnsserver()\n\n\nGets the IP address of the DNS server used to resolve hostnames.\n\n\nSyntax\n\n\nnet.dns.getdnsserver(dns_index)\n\n\nParameters\n\n\ndns_index which DNS server to get (range 0~1)\n\n\nReturns\n\n\nIP address (string) of DNS server\n\n\nExample\n\n\nprint(net.dns.getdnsserver(0)) -- 208.67.222.222\nprint(net.dns.getdnsserver(1)) -- nil\n\nnet.dns.setdnsserver(\n8.8.8.8\n, 0)\nnet.dns.setdnsserver(\n192.168.1.252\n, 1)\n\nprint(net.dns.getdnsserver(0)) -- 8.8.8.8\nprint(net.dns.getdnsserver(1)) -- 192.168.1.252\n\n\n\n\nSee also\n\n\nnet.dns:setdnsserver()\n\n\nnet.dns.resolve()\n\n\nResolve a hostname to an IP address. Doesn't require a socket like \nnet.socket.dns()\n.\n\n\nSyntax\n\n\nnet.dns.resolve(host, function(sk, ip))\n\n\nParameters\n\n\n\n\nhost\n hostname to resolve\n\n\nfunction(sk, ip)\n callback called when the name was resolved. \nsk\n is always \nnil\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nnet.dns.resolve(\nwww.google.com\n, function(sk, ip)\n    if (ip == nil) then print(\nDNS fail!\n) else print(ip) end\nend)\n\n\n\n\nSee also\n\n\nnet.socket:dns()\n\n\nnet.dns.setdnsserver()\n\n\nSets the IP of the DNS server used to resolve hostnames. Default: resolver1.opendns.com (208.67.222.222). You can specify up to 2 DNS servers.\n\n\nSyntax\n\n\nnet.dns.setdnsserver(dns_ip_addr, dns_index)\n\n\nParameters\n\n\n\n\ndns_ip_addr\n IP address of a DNS server\n\n\ndns_index\n which DNS server to set (range 0~1). Hence, it supports max. 2 servers. \n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nnet.dns:getdnsserver()\n\n\nnet.cert Module\n\n\nThis part gone to the \nTLS\n module, link kept for backward compatibility.", 
            "title": "net"
        }, 
        {
            "location": "/en/modules/net/#net-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-22  Zeroday  PhoeniX  net.c      TLS operations was moved to the  TLS  module", 
            "title": "net Module"
        }, 
        {
            "location": "/en/modules/net/#constants", 
            "text": "Constants to be used in other functions:  net.TCP ,  net.UDP", 
            "title": "Constants"
        }, 
        {
            "location": "/en/modules/net/#netcreateconnection", 
            "text": "Creates a client.", 
            "title": "net.createConnection()"
        }, 
        {
            "location": "/en/modules/net/#syntax", 
            "text": "net.createConnection([type[, secure]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters", 
            "text": "type   net.TCP  (default) or  net.UDP  secure  1 for encrypted, 0 for plain (default)    Attention  This will change in upcoming releases so that  net.createConnection  will always create an unencrypted TCP connection.  There's no such thing as a UDP  connection  because UDP is connection less . Thus no connection  type  parameter should be required. For UDP use  net.createUDPSocket()  instead. To create  secure  connections use  tls.createConnection()  instead.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns", 
            "text": "for  net.TCP  - net.socket sub module  for  net.UDP  - net.udpsocket sub module  for  net.TCP  with  secure  - tls.socket sub module", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example", 
            "text": "net.createConnection(net.TCP, 0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also", 
            "text": "net.createServer() ,  net.createUDPSocket() ,  tls.createConnection()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netcreateserver", 
            "text": "Creates a server.", 
            "title": "net.createServer()"
        }, 
        {
            "location": "/en/modules/net/#syntax_1", 
            "text": "net.createServer([type[, timeout]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_1", 
            "text": "type   net.TCP  (default) or  net.UDP  timeout  for a TCP server timeout is 1~28'800 seconds, 30 sec by default (for an inactive client to be disconnected)    Attention  The  type  parameter will be removed in upcoming releases so that  net.createServer  will always create a TCP-based server. For UDP use  net.createUDPSocket()  instead.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_1", 
            "text": "for  net.TCP  - net.server sub module  for  net.UDP  - net.udpsocket sub module", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example_1", 
            "text": "net.createServer(net.TCP, 30) -- 30s timeout", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also_1", 
            "text": "net.createConnection() ,  net.createUDPSocket()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netcreateudpsocket", 
            "text": "Creates an UDP socket.", 
            "title": "net.createUDPSocket()"
        }, 
        {
            "location": "/en/modules/net/#syntax_2", 
            "text": "net.createUDPSocket()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_2", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_2", 
            "text": "net.udpsocket sub module", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#see-also_2", 
            "text": "net.createConnection()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netmulticastjoin", 
            "text": "Join multicast group.", 
            "title": "net.multicastJoin()"
        }, 
        {
            "location": "/en/modules/net/#syntax_3", 
            "text": "net.multicastJoin(if_ip, multicast_ip)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_3", 
            "text": "if_ip  string containing the interface ip to join the multicast group. \"any\" or \"\" affects all interfaces.  multicast_ip  of the group to join", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#netmulticastleave", 
            "text": "Leave multicast group.", 
            "title": "net.multicastLeave()"
        }, 
        {
            "location": "/en/modules/net/#syntax_4", 
            "text": "net.multicastLeave(if_ip, multicast_ip)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_4", 
            "text": "if_ip  string containing the interface ip to leave the multicast group. \"any\" or \"\" affects all interfaces.  multicast_ip  of the group to leave", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#netserver-module", 
            "text": "", 
            "title": "net.server Module"
        }, 
        {
            "location": "/en/modules/net/#netserverclose", 
            "text": "Closes the server.", 
            "title": "net.server:close()"
        }, 
        {
            "location": "/en/modules/net/#syntax_5", 
            "text": "net.server.close()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_5", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_5", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example_2", 
            "text": "-- creates a server\nsv = net.createServer(net.TCP, 30)\n-- closes the server\nsv:close()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also_3", 
            "text": "net.createServer()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netserverlisten", 
            "text": "Listen on port from IP address.", 
            "title": "net.server:listen()"
        }, 
        {
            "location": "/en/modules/net/#syntax_6", 
            "text": "net.server.listen([port],[ip],function(net.socket))", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_6", 
            "text": "port  port number, can be omitted (random port will be chosen)  ip  IP address string, can be omitted  function(net.socket)  callback function, pass to caller function as param if a connection is created successfully", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_6", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example_3", 
            "text": "-- server listens on 80, if data received, print data to console and send  hello world  back to caller\n-- 30s time out for a inactive client\nsv = net.createServer(net.TCP, 30)\n\nfunction receiver(sck, data)\n  print(data)\n  sck:close()\nend\n\nif sv then\n  sv:listen(80, function(conn)\n    conn:on( receive , receiver)\n    conn:send( hello world )\n  end)\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also_4", 
            "text": "net.createServer()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netservergetaddr", 
            "text": "Returns server local address/port.", 
            "title": "net.server:getaddr()"
        }, 
        {
            "location": "/en/modules/net/#syntax_7", 
            "text": "net.server.getaddr()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_7", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_7", 
            "text": "port ,  ip  (or  nil, nil  if not listening)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#see-also_5", 
            "text": "net.server:listen()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netsocket-module", 
            "text": "", 
            "title": "net.socket Module"
        }, 
        {
            "location": "/en/modules/net/#netsocketclose", 
            "text": "Closes socket.", 
            "title": "net.socket:close()"
        }, 
        {
            "location": "/en/modules/net/#syntax_8", 
            "text": "close()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_8", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_8", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#see-also_6", 
            "text": "net.createServer()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netsocketconnect", 
            "text": "Connect to a remote server.", 
            "title": "net.socket:connect()"
        }, 
        {
            "location": "/en/modules/net/#syntax_9", 
            "text": "connect(port, ip|domain)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_9", 
            "text": "port  port number  ip  IP address or domain name string", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_9", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#see-also_7", 
            "text": "net.socket:on()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netsocketdns", 
            "text": "Provides DNS resolution for a hostname.", 
            "title": "net.socket:dns()"
        }, 
        {
            "location": "/en/modules/net/#syntax_10", 
            "text": "dns(domain, function(net.socket, ip))", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_10", 
            "text": "domain  domain name  function(net.socket, ip)  callback function. The first parameter is the socket, the second parameter is the IP address as a string.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_10", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example_4", 
            "text": "sk = net.createConnection(net.TCP, 0)\nsk:dns( www.nodemcu.com , function(conn, ip) print(ip) end)\nsk = nil", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also_8", 
            "text": "net.createServer()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netsocketgetpeer", 
            "text": "Retrieve port and ip of remote peer.", 
            "title": "net.socket:getpeer()"
        }, 
        {
            "location": "/en/modules/net/#syntax_11", 
            "text": "getpeer()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_11", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_11", 
            "text": "port ,  ip  (or  nil, nil  if not connected)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#netsocketgetaddr", 
            "text": "Retrieve local port and ip of socket.", 
            "title": "net.socket:getaddr()"
        }, 
        {
            "location": "/en/modules/net/#syntax_12", 
            "text": "getaddr()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_12", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_12", 
            "text": "port ,  ip  (or  nil, nil  if not connected)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#netsockethold", 
            "text": "Throttle data reception by placing a request to block the TCP receive function. This request is not effective immediately, Espressif recommends to call it while reserving 5*1460 bytes of memory.", 
            "title": "net.socket:hold()"
        }, 
        {
            "location": "/en/modules/net/#syntax_13", 
            "text": "hold()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_13", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_13", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#see-also_9", 
            "text": "net.socket:unhold()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netsocketon", 
            "text": "Register callback functions for specific events.", 
            "title": "net.socket:on()"
        }, 
        {
            "location": "/en/modules/net/#syntax_14", 
            "text": "on(event, function())", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_14", 
            "text": "event  string, which can be \"connection\", \"reconnection\", \"disconnection\", \"receive\" or \"sent\"  function(net.socket[, string])  callback function. Can be  nil  to remove callback.   The first parameter of callback is the socket.   If event is \"receive\", the second parameter is the received data as string.  If event is \"disconnection\" or \"reconnection\", the second parameter is error code.   If reconnection event is specified, disconnection receives only \"normal close\" events.  Otherwise, all connection errors (with normal close) passed to disconnection event.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_14", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example_5", 
            "text": "srv = net.createConnection(net.TCP, 0)\nsrv:on( receive , function(sck, c) print(c) end)\n-- Wait for connection before sending.\nsrv:on( connection , function(sck, c)\n  -- 'Connection: close' rather than 'Connection: keep-alive' to have server \n  -- initiate a close of the connection after final response (frees memory \n  -- earlier here), https://tools.ietf.org/html/rfc7230#section-6.6 \n  sck:send( GET /get HTTP/1.1\\r\\nHost: httpbin.org\\r\\nConnection: close\\r\\nAccept: */*\\r\\n\\r\\n )\nend)\nsrv:connect(80, httpbin.org )   Note  The  receive  event is fired for every network frame! Hence, if the data sent to the device exceeds 1460 bytes (derived from  Ethernet frame size ) it will fire more than once. There may be other situations where incoming data is split across multiple frames (e.g. HTTP POST with  multipart/form-data ). You need to manually buffer the data and find means to determine if all data was received.   local buffer = nil\n\nsrv:on( receive , function(sck, c)\n  if buffer == nil then\n    buffer = c\n  else\n    buffer = buffer .. c\n  end\nend)\n-- throttling could be implemented using socket:hold()\n-- example: https://github.com/nodemcu/nodemcu-firmware/blob/master/lua_examples/pcm/play_network.lua#L83", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also_10", 
            "text": "net.createServer()  net.socket:hold()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netsocketsend", 
            "text": "Sends data to remote peer.", 
            "title": "net.socket:send()"
        }, 
        {
            "location": "/en/modules/net/#syntax_15", 
            "text": "send(string[, function(sent)])  sck:send(data, fnA)  is functionally equivalent to  sck:send(data) sck:on(\"sent\", fnA) .", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_15", 
            "text": "string  data in string which will be sent to server  function(sent)  callback function for sending string", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_15", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#note", 
            "text": "Multiple consecutive  send()  calls aren't guaranteed to work (and often don't) as network requests are treated as separate tasks by the SDK. Instead, subscribe to the \"sent\" event on the socket and send additional data (or close) in that callback. See  #730  for details.", 
            "title": "Note"
        }, 
        {
            "location": "/en/modules/net/#example_6", 
            "text": "srv = net.createServer(net.TCP)\n\nfunction receiver(sck, data)\n  local response = {}\n\n  -- if you're sending back HTML over HTTP you'll want something like this instead\n  -- local response = { HTTP/1.0 200 OK\\r\\nServer: NodeMCU on ESP8266\\r\\nContent-Type: text/html\\r\\n\\r\\n }\n\n  response[#response + 1] =  lots of data \n  response[#response + 1] =  even more data \n  response[#response + 1] =  e.g. content read from a file \n\n  -- sends and removes the first element from the 'response' table\n  local function send(localSocket)\n    if #response   0 then\n      localSocket:send(table.remove(response, 1))\n    else\n      localSocket:close()\n      response = nil\n    end\n  end\n\n  -- triggers the send() function again once the first chunk of data was sent\n  sck:on( sent , send)\n\n  send(sck)\nend\n\nsrv:listen(80, function(conn)\n  conn:on( receive , receiver)\nend)  If you do not or can not keep all the data you send back in memory at one time (remember that  response  is an aggregation) you may use explicit callbacks instead of building up a table like so:  sck:send(header, function() \n  local data1 =  some large chunk of dynamically loaded data \n  sck:send(data1, function()\n    local data2 =  even more dynamically loaded data \n    sck:send(data2, function(sk) \n      sk:close()\n    end)\n  end)\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also_11", 
            "text": "net.socket:on()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netsocketttl", 
            "text": "Changes or retrieves Time-To-Live value on socket.", 
            "title": "net.socket:ttl()"
        }, 
        {
            "location": "/en/modules/net/#syntax_16", 
            "text": "ttl([ttl])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_16", 
            "text": "ttl  (optional) new time-to-live value", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_16", 
            "text": "current / new ttl value", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example_7", 
            "text": "sk = net.createConnection(net.TCP, 0)\nsk:connect(80, '192.168.1.1')\nsk:ttl(1) -- restrict frames to single subnet", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also_12", 
            "text": "net.createConnection()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netsocketunhold", 
            "text": "Unblock TCP receiving data by revocation of a preceding  hold() .", 
            "title": "net.socket:unhold()"
        }, 
        {
            "location": "/en/modules/net/#syntax_17", 
            "text": "unhold()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_17", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_17", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#see-also_13", 
            "text": "net.socket:hold()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netudpsocket-module", 
            "text": "Remember that in contrast to TCP  UDP  is connectionless. Therefore, there is a minor but natural mismatch as for TCP/UDP functions in this module. While you would call  net.createConnection()  for TCP it is  net.createUDPSocket()  for UDP.  Other points worth noting:   UDP sockets do not have a connection callback for the  listen  function.  UDP sockets do not have a  connect  function. Remote IP and port thus need to be defined in  send() .  UDP socket's  receive  callback receives port/ip after the  data  argument.", 
            "title": "net.udpsocket Module"
        }, 
        {
            "location": "/en/modules/net/#netudpsocketclose", 
            "text": "Closes UDP socket.  The syntax and functional identical to  net.socket:close() .", 
            "title": "net.udpsocket:close()"
        }, 
        {
            "location": "/en/modules/net/#netudpsocketlisten", 
            "text": "Listen on port from IP address.  The syntax and functional similar to  net.server:listen() , but callback parameter is not provided.", 
            "title": "net.udpsocket:listen()"
        }, 
        {
            "location": "/en/modules/net/#netudpsocketon", 
            "text": "Register callback functions for specific events.  The syntax and functional similar to  net.socket:on() . However, only \"receive\", \"sent\" and \"dns\" are supported events.   Note  The  receive  callback receives  port  and  ip   after  the  data  argument.", 
            "title": "net.udpsocket:on()"
        }, 
        {
            "location": "/en/modules/net/#netudpsocketsend", 
            "text": "Sends data to specific remote peer.", 
            "title": "net.udpsocket:send()"
        }, 
        {
            "location": "/en/modules/net/#syntax_18", 
            "text": "send(port, ip, data)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_18", 
            "text": "port  remote socket port  ip  remote socket IP  data  the payload to send", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_18", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example_8", 
            "text": "udpSocket = net.createUDPSocket()\nudpSocket:listen(5000)\nudpSocket:on( receive , function(s, data, port, ip)\n    print(string.format( received '%s' from %s:%d , data, ip, port))\n    s:send(port, ip,  echo:   .. data)\nend)\nport, ip = udpSocket:getaddr()\nprint(string.format( local UDP socket address / port: %s:%d , ip, port))  On *nix systems that can then be tested by issuing  echo -n  foo  | nc -w1 -u  device-IP-address  5000", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#netudpsocketdns", 
            "text": "Provides DNS resolution for a hostname.  The syntax and functional identical to  net.socket:dns() .", 
            "title": "net.udpsocket:dns()"
        }, 
        {
            "location": "/en/modules/net/#netudpsocketgetaddr", 
            "text": "Retrieve local port and ip of socket.  The syntax and functional identical to  net.socket:getaddr() .", 
            "title": "net.udpsocket:getaddr()"
        }, 
        {
            "location": "/en/modules/net/#netudpsocketttl", 
            "text": "Changes or retrieves Time-To-Live value on socket.  The syntax and functional identical to  net.socket:ttl() .", 
            "title": "net.udpsocket:ttl()"
        }, 
        {
            "location": "/en/modules/net/#netdns-module", 
            "text": "", 
            "title": "net.dns Module"
        }, 
        {
            "location": "/en/modules/net/#netdnsgetdnsserver", 
            "text": "Gets the IP address of the DNS server used to resolve hostnames.", 
            "title": "net.dns.getdnsserver()"
        }, 
        {
            "location": "/en/modules/net/#syntax_19", 
            "text": "net.dns.getdnsserver(dns_index)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_19", 
            "text": "dns_index which DNS server to get (range 0~1)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_19", 
            "text": "IP address (string) of DNS server", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example_9", 
            "text": "print(net.dns.getdnsserver(0)) -- 208.67.222.222\nprint(net.dns.getdnsserver(1)) -- nil\n\nnet.dns.setdnsserver( 8.8.8.8 , 0)\nnet.dns.setdnsserver( 192.168.1.252 , 1)\n\nprint(net.dns.getdnsserver(0)) -- 8.8.8.8\nprint(net.dns.getdnsserver(1)) -- 192.168.1.252", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also_14", 
            "text": "net.dns:setdnsserver()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netdnsresolve", 
            "text": "Resolve a hostname to an IP address. Doesn't require a socket like  net.socket.dns() .", 
            "title": "net.dns.resolve()"
        }, 
        {
            "location": "/en/modules/net/#syntax_20", 
            "text": "net.dns.resolve(host, function(sk, ip))", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_20", 
            "text": "host  hostname to resolve  function(sk, ip)  callback called when the name was resolved.  sk  is always  nil", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_20", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#example_10", 
            "text": "net.dns.resolve( www.google.com , function(sk, ip)\n    if (ip == nil) then print( DNS fail! ) else print(ip) end\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/net/#see-also_15", 
            "text": "net.socket:dns()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netdnssetdnsserver", 
            "text": "Sets the IP of the DNS server used to resolve hostnames. Default: resolver1.opendns.com (208.67.222.222). You can specify up to 2 DNS servers.", 
            "title": "net.dns.setdnsserver()"
        }, 
        {
            "location": "/en/modules/net/#syntax_21", 
            "text": "net.dns.setdnsserver(dns_ip_addr, dns_index)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/net/#parameters_21", 
            "text": "dns_ip_addr  IP address of a DNS server  dns_index  which DNS server to set (range 0~1). Hence, it supports max. 2 servers.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/net/#returns_21", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/net/#see-also_16", 
            "text": "net.dns:getdnsserver()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/net/#netcert-module", 
            "text": "This part gone to the  TLS  module, link kept for backward compatibility.", 
            "title": "net.cert Module"
        }, 
        {
            "location": "/en/modules/node/", 
            "text": "node Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-22\n\n\nZeroday\n\n\nZeroday\n\n\nnode.c\n\n\n\n\n\n\n\n\nThe node module provides access to system-level features such as sleep, restart and various info and IDs.\n\n\nnode.bootreason()\n\n\nReturns the boot reason and extended reset info.\n\n\nThe first value returned is the raw code, not the new \"reset info\" code which was introduced in recent SDKs. Values are:\n\n\n\n\n1, power-on\n\n\n2, reset (software?)\n\n\n3, hardware reset via reset pin\n\n\n4, WDT reset (watchdog timeout)\n\n\n\n\nThe second value returned is the extended reset cause. Values are:\n\n\n\n\n0, power-on\n\n\n1, hardware watchdog reset\n\n\n2, exception reset\n\n\n3, software watchdog reset\n\n\n4, software restart\n\n\n5, wake from deep sleep\n\n\n6, external reset\n\n\n\n\nIn general, the extended reset cause supercedes the raw code. The raw code is kept for backwards compatibility only. For new applications it is highly recommended to use the extended reset cause instead.\n\n\nIn case of extended reset cause 3 (exception reset), additional values are returned containing the crash information. These are, in order, EXCCAUSE, EPC1, EPC2, EPC3, EXCVADDR, and DEPC.\n\n\nSyntax\n\n\nnode.bootreason()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nrawcode, reason [, exccause, epc1, epc2, epc3, excvaddr, depc ]\n\n\nExample\n\n\n_, reset_reason = node.bootreason()\nif reset_reason == 0 then print(\nPower UP!\n) end\n\n\n\n\nnode.chipid()\n\n\nReturns the ESP chip ID.\n\n\nSyntax\n\n\nnode.chipid()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nchip ID (number)\n\n\nnode.compile()\n\n\nCompiles a Lua text file into Lua bytecode, and saves it as .lc file.\n\n\nSyntax\n\n\nnode.compile(\"file.lua\")\n\n\nParameters\n\n\nfilename\n name of Lua text file\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nfile.open(\nhello.lua\n,\nw+\n)\nfile.writeline([[print(\nhello nodemcu\n)]])\nfile.writeline([[print(node.heap())]])\nfile.close()\n\nnode.compile(\nhello.lua\n)\ndofile(\nhello.lua\n)\ndofile(\nhello.lc\n)\n\n\n\n\nnode.dsleep()\n\n\nEnters deep sleep mode, wakes up when timed out.\n\n\nThe maximum sleep time is 4294967295us, ~71 minutes. This is an SDK limitation.\nFirmware from before 05 Jan 2016 have a maximum sleeptime of ~35 minutes.\n\n\n\n\nCaution\n\n\nThis function can only be used in the condition that esp8266 PIN32(RST) and PIN8(XPD_DCDC aka GPIO16) are connected together. Using sleep(0) will set no wake up timer, connect a GPIO to pin RST, the chip will wake up by a falling-edge on pin RST.\n\n\n\n\nSyntax\n\n\nnode.dsleep(us, option, instant)\n\n\nParameters\n\n\n\n\n\n\nus\n number (integer) or \nnil\n, sleep time in micro second. If \nus == 0\n, it will sleep forever. If \nus == nil\n, will not set sleep time.\n\n\n\n\n\n\noption\n number (integer) or \nnil\n. If \nnil\n, it will use last alive setting as default option.\n\n\n\n\n0, init data byte 108 is valuable\n\n\n> 0, init data byte 108 is valueless\n\n\n0, RF_CAL or not after deep-sleep wake up, depends on init data byte 108\n\n\n1, RF_CAL after deep-sleep wake up, there will be large current\n\n\n2, no RF_CAL after deep-sleep wake up, there will only be small current\n\n\n4, disable RF after deep-sleep wake up, just like modem sleep, there will be the smallest current\n\n\n\n\n\n\ninstant\n number (integer) or \nnil\n. If present and non-zero, do not use\n    the normal grace time before entering deep sleep.  This is a largely\n    undocumented feature, and is only briefly mentioned in Espressif's\n    \nlow power solutions\n document (chapter 4.5).\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n--do nothing\nnode.dsleep()\n--sleep \u03bcs\nnode.dsleep(1000000)\n--set sleep option, then sleep \u03bcs\nnode.dsleep(1000000, 4)\n--set sleep option only\nnode.dsleep(nil,4)\n\n\n\n\nSee also\n\n\n\n\nwifi.suspend()\n\n\nwifi.resume()\n\n\nnode.sleep()\n\n\n\n\nnode.flashid()\n\n\nReturns the flash chip ID.\n\n\nSyntax\n\n\nnode.flashid()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nflash ID (number)\n\n\nnode.flashsize()\n\n\nReturns the flash chip size in bytes. On 4MB modules like ESP-12 the return value is 4194304 = 4096KB.\n\n\nSyntax\n\n\nnode.flashsize()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nflash size in bytes (integer)\n\n\nnode.heap()\n\n\nReturns the current available heap size in bytes. Note that due to fragmentation, actual allocations of this size may not be possible.\n\n\nSyntax\n\n\nnode.heap()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nsystem heap size left in bytes (number)\n\n\nnode.info()\n\n\nReturns NodeMCU version, chipid, flashid, flash size, flash mode, flash speed.\n\n\nSyntax\n\n\nnode.info()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nmajorVer\n (number)\n\n\nminorVer\n (number)\n\n\ndevVer\n (number)\n\n\nchipid\n (number)\n\n\nflashid\n (number)\n\n\nflashsize\n (number)\n\n\nflashmode\n (number)\n\n\nflashspeed\n (number)\n\n\n\n\nExample\n\n\nmajorVer, minorVer, devVer, chipid, flashid, flashsize, flashmode, flashspeed = node.info()\nprint(\nNodeMCU \n..majorVer..\n.\n..minorVer..\n.\n..devVer)\n\n\n\n\nnode.input()\n\n\nSubmits a string to the Lua interpreter. Similar to \npcall(loadstring(str))\n, but without the single-line limitation.\n\n\n\n\nAttention\n\n\nThis function only has an effect when invoked from a callback. Using it directly on the console \ndoes not work\n.\n\n\n\n\nSyntax\n\n\nnode.input(str)\n\n\nParameters\n\n\nstr\n Lua chunk\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nsk:on(\nreceive\n, function(conn, payload) node.input(payload) end)\n\n\n\n\nSee also\n\n\nnode.output()\n\n\nnode.output()\n\n\nRedirects the Lua interpreter output to a callback function. Optionally also prints it to the serial console.\n\n\n\n\nCaution\n\n\nDo \nnot\n attempt to \nprint()\n or otherwise induce the Lua interpreter to produce output from within the callback function. Doing so results in infinite recursion, and leads to a watchdog-triggered restart.\n\n\n\n\nSyntax\n\n\nnode.output(function(str), serial_debug)\n\n\nParameters\n\n\n\n\noutput_fn(str)\n a function accept every output as str, and can send the output to a socket (or maybe a file).\n\n\nserial_debug\n 1 output also show in serial. 0: no serial output.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nfunction tonet(str)\n  sk:send(str)\nend\nnode.output(tonet, 1)  -- serial also get the lua output.\n\n\n\n\n-- a simple telnet server\ns=net.createServer(net.TCP)\ns:listen(2323,function(c)\n   con_std = c\n   function s_output(str)\n      if(con_std~=nil)\n         then con_std:send(str)\n      end\n   end\n   node.output(s_output, 0)   -- re-direct output to function s_ouput.\n   c:on(\nreceive\n,function(c,l)\n      node.input(l)           -- works like pcall(loadstring(l)) but support multiple separate line\n   end)\n   c:on(\ndisconnection\n,function(c)\n      con_std = nil\n      node.output(nil)        -- un-regist the redirect output function, output goes to serial\n   end)\nend)\n\n\n\n\nSee also\n\n\nnode.input()\n\n\nnode.readvdd33() --deprecated\n\n\nMoved to \nadc.readvdd33()\n.\n\n\nnode.restart()\n\n\nRestarts the chip.\n\n\nSyntax\n\n\nnode.restart()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nnode.restore()\n\n\nRestores system configuration to defaults using the SDK function \nsystem_restore()\n, which is described in the documentation as:\n\n\n\n\nReset default settings of following APIs: \nwifi_station_set_auto_connect\n, \nwifi_set_phy_mode\n, \nwifi_softap_set_config\n related, \nwifi_station_set_config\n related, \nwifi_set_opmode\n, and APs\u2019 information recorded by \n#define AP_CACHE\n.\n\n\n\n\nSyntax\n\n\nnode.restore()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nnode.restore()\nnode.restart() -- ensure the restored settings take effect\n\n\n\n\nnode.setcpufreq()\n\n\nChange the working CPU Frequency.\n\n\nSyntax\n\n\nnode.setcpufreq(speed)\n\n\nParameters\n\n\nspeed\n constant 'node.CPU80MHZ' or 'node.CPU160MHZ'\n\n\nReturns\n\n\ntarget CPU frequency (number)\n\n\nExample\n\n\nnode.setcpufreq(node.CPU80MHZ)\n\n\n\n\nnode.sleep()\n\n\nPut NodeMCU in light sleep mode to reduce current consumption. \n\n\n\n\nNodeMCU can not enter light sleep mode if wifi is suspended.\n\n\nAll active timers will be suspended and then resumed when NodeMCU wakes from sleep. \n\n\nAny previously suspended timers will be resumed when NodeMCU wakes from sleep.\n\n\n\n\nSyntax\n\n\nnode.sleep({wake_gpio[, duration, int_type, resume_cb, preserve_mode]})\n\n\nParameters\n\n\n\n\nduration\n Sleep duration in microseconds(\u03bcs). If a sleep duration of \n0\n is specified, suspension will be indefinite (Range: 0 or 50000 - 268435454 \u03bcs (0:4:28.000454))\n\n\nwake_pin\n 1-12, pin to attach wake interrupt to. Note that pin 0(GPIO 16) does not support interrupts. \n\n\nIf sleep duration is indefinite, \nwake_pin\n must be specified\n\n\nPlease refer to the \nGPIO module\n for more info on the pin map.\n\n\nint_type\n type of interrupt that you would like to wake on. (Optional, Default: \nnode.INT_LOW\n)\n\n\nvalid interrupt modes:\n\n\nnode.INT_UP\n   Rising edge\n\n\nnode.INT_DOWN\n Falling edge\n\n\nnode.INT_BOTH\n Both edges\n\n\nnode.INT_LOW\n  Low level\n\n\nnode.INT_HIGH\n High level\n\n\nresume_cb\n Callback to execute when WiFi wakes from suspension. (Optional)\n\n\npreserve_mode\n preserve current WiFi mode through node sleep. (Optional, Default: true)  \n\n\nIf true, Station and StationAP modes will automatically reconnect to previously configured Access Point when NodeMCU resumes.\n\n\nIf false, discard WiFi mode and leave NodeMCU in \nwifi.NULL_MODE\n. WiFi mode will be restored to original mode on restart.\n\n\n\n\nReturns\n\n\n\n\nnil\n\n\n\n\nExample\n\n\n\n--Put NodeMCU in light sleep mode indefinitely with resume callback and wake interrupt\n cfg={}\n cfg.wake_pin=3\n cfg.resume_cb=function() print(\nWiFi resume\n) end\n\n node.sleep(cfg)\n\n--Put NodeMCU in light sleep mode with interrupt, resume callback and discard WiFi mode\n cfg={}\n cfg.wake_pin=3 --GPIO0\n cfg.resume_cb=function() print(\nWiFi resume\n) end\n cfg.preserve_mode=false\n\n node.sleep(cfg)\n\n--Put NodeMCU in light sleep mode for 10 seconds with resume callback\n cfg={}\n cfg.duration=10*1000*1000\n cfg.resume_cb=function() print(\nWiFi resume\n) end\n\n node.sleep(cfg)\n\n\n\n\n\nSee also\n\n\n\n\nwifi.suspend()\n\n\nwifi.resume()\n\n\nnode.dsleep()\n\n\n\n\nnode.stripdebug()\n\n\nControls the amount of debug information kept during \nnode.compile()\n, and allows removal of debug information from already compiled Lua code.\n\n\nOnly recommended for advanced users, the NodeMCU defaults are fine for almost all use cases.\n\n\nSyntax\n\n\nnode.stripdebug([level[, function]])\n\n\nParameters\n\n\n\n\nlevel\n\n\n1, don't discard debug info\n\n\n2, discard Local and Upvalue debug info\n\n\n3, discard Local, Upvalue and line-number debug info\n\n\n\n\n\n\nfunction\n a compiled function to be stripped per setfenv except 0 is not permitted.\n\n\n\n\nIf no arguments are given then the current default setting is returned. If function is omitted, this is the default setting for future compiles. The function argument uses the same rules as for \nsetfenv()\n.\n\n\nReturns\n\n\nIf invoked without arguments, returns the current level settings. Otherwise, \nnil\n is returned.\n\n\nExample\n\n\nnode.stripdebug(3)\nnode.compile('bigstuff.lua')\n\n\n\n\nSee also\n\n\nnode.compile()\n\n\nnode.osprint()\n\n\nControls whether the debugging output from the Espressif SDK is printed. Note that this is only available if\nthe firmware is build with DEVELOPMENT_TOOLS defined.\n\n\nSyntax\n\n\nnode.osprint(enabled)\n\n\nParameters\n\n\n\n\nenabled\n This is either \ntrue\n to enable printing, or \nfalse\n to disable it. The default is \nfalse\n.\n\n\n\n\nReturns\n\n\nNothing\n\n\nExample\n\n\nnode.osprint(true)\n\n\n\n\nnode.random()\n\n\nThis behaves like math.random except that it uses true random numbers derived from the ESP8266 hardware. It returns uniformly distributed\nnumbers in the required range. It also takes care to get large ranges correct. \n\n\nIt can be called in three ways. Without arguments in the floating point build of NodeMCU, it returns a random real number with uniform distribution in the interval [0,1). \nWhen called with only one argument, an integer n, it returns an integer random number x such that 1 \n= x \n= n. For instance, you can simulate the result of a die with random(6). \nFinally, random can be called with two integer arguments, l and u, to get a pseudo-random integer x such that l \n= x \n= u.\n\n\nSyntax\n\n\nnode.random()\n\n\nnode.random(n)\n\n\nnode.random(l, u)\n\n\nParameters\n\n\n\n\nn\n the number of distinct integer values that can be returned -- in the (inclusive) range 1 .. \nn\n\n\nl\n the lower bound of the range\n\n\nu\n the upper bound of the range\n\n\n\n\nReturns\n\n\nThe random number in the appropriate range. Note that the zero argument form will always return 0 in the integer build.\n\n\nExample\n\n\nprint (\nI rolled a\n, node.random(6))\n\n\n\n\nnode.egc module\n\n\nnode.egc.setmode()\n\n\nSets the Emergency Garbage Collector mode. \nThe EGC whitepaper\n\nprovides more detailed information on the EGC.\n\n\nSyntax\n\n\nnode.egc.setmode(mode, [param])\n\n\nParameters\n\n\n\n\nmode\n\n\nnode.egc.NOT_ACTIVE\n EGC inactive, no collection cycle will be forced in low memory situations\n\n\nnode.egc.ON_ALLOC_FAILURE\n Try to allocate a new block of memory, and run the garbage collector if the allocation fails. If the allocation fails even after running the garbage collector, the allocator will return with error. \n\n\nnode.egc.ON_MEM_LIMIT\n Run the garbage collector when the memory used by the Lua script goes beyond an upper \nlimit\n. If the upper limit can't be satisfied even after running the garbage collector, the allocator will return with error.\n\n\nnode.egc.ALWAYS\n Run the garbage collector before each memory allocation. If the allocation fails even after running the garbage collector, the allocator will return with error. This mode is very efficient with regards to memory savings, but it's also the slowest.\n\n\n\n\n\n\nlevel\n in the case of \nnode.egc.ON_MEM_LIMIT\n, this specifies the memory limit.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nnode.egc.setmode(node.egc.ALWAYS, 4096)  -- This is the default setting at startup.\n\n\nnode.egc.setmode(node.egc.ON_ALLOC_FAILURE) -- This is the fastest activeEGC mode.\n\n\nnode.task module\n\n\nnode.task.post()\n\n\nEnable a Lua callback or task to post another task request. Note that as per the \nexample multiple tasks can be posted in any task, but the highest priority is \nalways delivered first.\n\n\nIf the task queue is full then a queue full error is raised.  \n\n\nSyntax\n\n\nnode.task.post([task_priority], function)\n\n\nParameters\n\n\n\n\ntask_priority\n (optional)\n\n\nnode.task.LOW_PRIORITY\n = 0\n\n\nnode.task.MEDIUM_PRIORITY\n = 1\n\n\nnode.task.HIGH_PRIORITY\n = 2\n\n\n\n\n\n\nfunction\n a callback function to be executed when the task is run. \n\n\n\n\nIf the priority is omitted then  this defaults  to \nnode.task.MEDIUM_PRIORITY\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nfor i = node.task.LOW_PRIORITY, node.task.HIGH_PRIORITY do \n  node.task.post(i,function(p2)\n    print(\npriority is \n..p2)\n  end) \nend      \n\n\n\n\nprints\n\n\npriority is 2\npriority is 1\npriority is 0", 
            "title": "node"
        }, 
        {
            "location": "/en/modules/node/#node-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-22  Zeroday  Zeroday  node.c     The node module provides access to system-level features such as sleep, restart and various info and IDs.", 
            "title": "node Module"
        }, 
        {
            "location": "/en/modules/node/#nodebootreason", 
            "text": "Returns the boot reason and extended reset info.  The first value returned is the raw code, not the new \"reset info\" code which was introduced in recent SDKs. Values are:   1, power-on  2, reset (software?)  3, hardware reset via reset pin  4, WDT reset (watchdog timeout)   The second value returned is the extended reset cause. Values are:   0, power-on  1, hardware watchdog reset  2, exception reset  3, software watchdog reset  4, software restart  5, wake from deep sleep  6, external reset   In general, the extended reset cause supercedes the raw code. The raw code is kept for backwards compatibility only. For new applications it is highly recommended to use the extended reset cause instead.  In case of extended reset cause 3 (exception reset), additional values are returned containing the crash information. These are, in order, EXCCAUSE, EPC1, EPC2, EPC3, EXCVADDR, and DEPC.", 
            "title": "node.bootreason()"
        }, 
        {
            "location": "/en/modules/node/#syntax", 
            "text": "node.bootreason()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns", 
            "text": "rawcode, reason [, exccause, epc1, epc2, epc3, excvaddr, depc ]", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example", 
            "text": "_, reset_reason = node.bootreason()\nif reset_reason == 0 then print( Power UP! ) end", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#nodechipid", 
            "text": "Returns the ESP chip ID.", 
            "title": "node.chipid()"
        }, 
        {
            "location": "/en/modules/node/#syntax_1", 
            "text": "node.chipid()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_1", 
            "text": "chip ID (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#nodecompile", 
            "text": "Compiles a Lua text file into Lua bytecode, and saves it as .lc file.", 
            "title": "node.compile()"
        }, 
        {
            "location": "/en/modules/node/#syntax_2", 
            "text": "node.compile(\"file.lua\")", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_2", 
            "text": "filename  name of Lua text file", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_1", 
            "text": "file.open( hello.lua , w+ )\nfile.writeline([[print( hello nodemcu )]])\nfile.writeline([[print(node.heap())]])\nfile.close()\n\nnode.compile( hello.lua )\ndofile( hello.lua )\ndofile( hello.lc )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#nodedsleep", 
            "text": "Enters deep sleep mode, wakes up when timed out.  The maximum sleep time is 4294967295us, ~71 minutes. This is an SDK limitation.\nFirmware from before 05 Jan 2016 have a maximum sleeptime of ~35 minutes.   Caution  This function can only be used in the condition that esp8266 PIN32(RST) and PIN8(XPD_DCDC aka GPIO16) are connected together. Using sleep(0) will set no wake up timer, connect a GPIO to pin RST, the chip will wake up by a falling-edge on pin RST.", 
            "title": "node.dsleep()"
        }, 
        {
            "location": "/en/modules/node/#syntax_3", 
            "text": "node.dsleep(us, option, instant)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_3", 
            "text": "us  number (integer) or  nil , sleep time in micro second. If  us == 0 , it will sleep forever. If  us == nil , will not set sleep time.    option  number (integer) or  nil . If  nil , it will use last alive setting as default option.   0, init data byte 108 is valuable  > 0, init data byte 108 is valueless  0, RF_CAL or not after deep-sleep wake up, depends on init data byte 108  1, RF_CAL after deep-sleep wake up, there will be large current  2, no RF_CAL after deep-sleep wake up, there will only be small current  4, disable RF after deep-sleep wake up, just like modem sleep, there will be the smallest current    instant  number (integer) or  nil . If present and non-zero, do not use\n    the normal grace time before entering deep sleep.  This is a largely\n    undocumented feature, and is only briefly mentioned in Espressif's\n     low power solutions  document (chapter 4.5).", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_2", 
            "text": "--do nothing\nnode.dsleep()\n--sleep \u03bcs\nnode.dsleep(1000000)\n--set sleep option, then sleep \u03bcs\nnode.dsleep(1000000, 4)\n--set sleep option only\nnode.dsleep(nil,4)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#see-also", 
            "text": "wifi.suspend()  wifi.resume()  node.sleep()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/node/#nodeflashid", 
            "text": "Returns the flash chip ID.", 
            "title": "node.flashid()"
        }, 
        {
            "location": "/en/modules/node/#syntax_4", 
            "text": "node.flashid()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_4", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_4", 
            "text": "flash ID (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#nodeflashsize", 
            "text": "Returns the flash chip size in bytes. On 4MB modules like ESP-12 the return value is 4194304 = 4096KB.", 
            "title": "node.flashsize()"
        }, 
        {
            "location": "/en/modules/node/#syntax_5", 
            "text": "node.flashsize()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_5", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_5", 
            "text": "flash size in bytes (integer)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#nodeheap", 
            "text": "Returns the current available heap size in bytes. Note that due to fragmentation, actual allocations of this size may not be possible.", 
            "title": "node.heap()"
        }, 
        {
            "location": "/en/modules/node/#syntax_6", 
            "text": "node.heap()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_6", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_6", 
            "text": "system heap size left in bytes (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#nodeinfo", 
            "text": "Returns NodeMCU version, chipid, flashid, flash size, flash mode, flash speed.", 
            "title": "node.info()"
        }, 
        {
            "location": "/en/modules/node/#syntax_7", 
            "text": "node.info()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_7", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_7", 
            "text": "majorVer  (number)  minorVer  (number)  devVer  (number)  chipid  (number)  flashid  (number)  flashsize  (number)  flashmode  (number)  flashspeed  (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_3", 
            "text": "majorVer, minorVer, devVer, chipid, flashid, flashsize, flashmode, flashspeed = node.info()\nprint( NodeMCU  ..majorVer.. . ..minorVer.. . ..devVer)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#nodeinput", 
            "text": "Submits a string to the Lua interpreter. Similar to  pcall(loadstring(str)) , but without the single-line limitation.   Attention  This function only has an effect when invoked from a callback. Using it directly on the console  does not work .", 
            "title": "node.input()"
        }, 
        {
            "location": "/en/modules/node/#syntax_8", 
            "text": "node.input(str)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_8", 
            "text": "str  Lua chunk", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_8", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_4", 
            "text": "sk:on( receive , function(conn, payload) node.input(payload) end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#see-also_1", 
            "text": "node.output()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/node/#nodeoutput", 
            "text": "Redirects the Lua interpreter output to a callback function. Optionally also prints it to the serial console.   Caution  Do  not  attempt to  print()  or otherwise induce the Lua interpreter to produce output from within the callback function. Doing so results in infinite recursion, and leads to a watchdog-triggered restart.", 
            "title": "node.output()"
        }, 
        {
            "location": "/en/modules/node/#syntax_9", 
            "text": "node.output(function(str), serial_debug)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_9", 
            "text": "output_fn(str)  a function accept every output as str, and can send the output to a socket (or maybe a file).  serial_debug  1 output also show in serial. 0: no serial output.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_9", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_5", 
            "text": "function tonet(str)\n  sk:send(str)\nend\nnode.output(tonet, 1)  -- serial also get the lua output.  -- a simple telnet server\ns=net.createServer(net.TCP)\ns:listen(2323,function(c)\n   con_std = c\n   function s_output(str)\n      if(con_std~=nil)\n         then con_std:send(str)\n      end\n   end\n   node.output(s_output, 0)   -- re-direct output to function s_ouput.\n   c:on( receive ,function(c,l)\n      node.input(l)           -- works like pcall(loadstring(l)) but support multiple separate line\n   end)\n   c:on( disconnection ,function(c)\n      con_std = nil\n      node.output(nil)        -- un-regist the redirect output function, output goes to serial\n   end)\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#see-also_2", 
            "text": "node.input()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/node/#nodereadvdd33-deprecated", 
            "text": "Moved to  adc.readvdd33() .", 
            "title": "node.readvdd33() --deprecated"
        }, 
        {
            "location": "/en/modules/node/#noderestart", 
            "text": "Restarts the chip.", 
            "title": "node.restart()"
        }, 
        {
            "location": "/en/modules/node/#syntax_10", 
            "text": "node.restart()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_10", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_10", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#noderestore", 
            "text": "Restores system configuration to defaults using the SDK function  system_restore() , which is described in the documentation as:   Reset default settings of following APIs:  wifi_station_set_auto_connect ,  wifi_set_phy_mode ,  wifi_softap_set_config  related,  wifi_station_set_config  related,  wifi_set_opmode , and APs\u2019 information recorded by  #define AP_CACHE .", 
            "title": "node.restore()"
        }, 
        {
            "location": "/en/modules/node/#syntax_11", 
            "text": "node.restore()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_11", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_11", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_6", 
            "text": "node.restore()\nnode.restart() -- ensure the restored settings take effect", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#nodesetcpufreq", 
            "text": "Change the working CPU Frequency.", 
            "title": "node.setcpufreq()"
        }, 
        {
            "location": "/en/modules/node/#syntax_12", 
            "text": "node.setcpufreq(speed)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_12", 
            "text": "speed  constant 'node.CPU80MHZ' or 'node.CPU160MHZ'", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_12", 
            "text": "target CPU frequency (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_7", 
            "text": "node.setcpufreq(node.CPU80MHZ)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#nodesleep", 
            "text": "Put NodeMCU in light sleep mode to reduce current consumption.    NodeMCU can not enter light sleep mode if wifi is suspended.  All active timers will be suspended and then resumed when NodeMCU wakes from sleep.   Any previously suspended timers will be resumed when NodeMCU wakes from sleep.", 
            "title": "node.sleep()"
        }, 
        {
            "location": "/en/modules/node/#syntax_13", 
            "text": "node.sleep({wake_gpio[, duration, int_type, resume_cb, preserve_mode]})", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_13", 
            "text": "duration  Sleep duration in microseconds(\u03bcs). If a sleep duration of  0  is specified, suspension will be indefinite (Range: 0 or 50000 - 268435454 \u03bcs (0:4:28.000454))  wake_pin  1-12, pin to attach wake interrupt to. Note that pin 0(GPIO 16) does not support interrupts.   If sleep duration is indefinite,  wake_pin  must be specified  Please refer to the  GPIO module  for more info on the pin map.  int_type  type of interrupt that you would like to wake on. (Optional, Default:  node.INT_LOW )  valid interrupt modes:  node.INT_UP    Rising edge  node.INT_DOWN  Falling edge  node.INT_BOTH  Both edges  node.INT_LOW   Low level  node.INT_HIGH  High level  resume_cb  Callback to execute when WiFi wakes from suspension. (Optional)  preserve_mode  preserve current WiFi mode through node sleep. (Optional, Default: true)    If true, Station and StationAP modes will automatically reconnect to previously configured Access Point when NodeMCU resumes.  If false, discard WiFi mode and leave NodeMCU in  wifi.NULL_MODE . WiFi mode will be restored to original mode on restart.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_13", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_8", 
            "text": "--Put NodeMCU in light sleep mode indefinitely with resume callback and wake interrupt\n cfg={}\n cfg.wake_pin=3\n cfg.resume_cb=function() print( WiFi resume ) end\n\n node.sleep(cfg)\n\n--Put NodeMCU in light sleep mode with interrupt, resume callback and discard WiFi mode\n cfg={}\n cfg.wake_pin=3 --GPIO0\n cfg.resume_cb=function() print( WiFi resume ) end\n cfg.preserve_mode=false\n\n node.sleep(cfg)\n\n--Put NodeMCU in light sleep mode for 10 seconds with resume callback\n cfg={}\n cfg.duration=10*1000*1000\n cfg.resume_cb=function() print( WiFi resume ) end\n\n node.sleep(cfg)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#see-also_3", 
            "text": "wifi.suspend()  wifi.resume()  node.dsleep()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/node/#nodestripdebug", 
            "text": "Controls the amount of debug information kept during  node.compile() , and allows removal of debug information from already compiled Lua code.  Only recommended for advanced users, the NodeMCU defaults are fine for almost all use cases.", 
            "title": "node.stripdebug()"
        }, 
        {
            "location": "/en/modules/node/#syntax_14", 
            "text": "node.stripdebug([level[, function]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_14", 
            "text": "level  1, don't discard debug info  2, discard Local and Upvalue debug info  3, discard Local, Upvalue and line-number debug info    function  a compiled function to be stripped per setfenv except 0 is not permitted.   If no arguments are given then the current default setting is returned. If function is omitted, this is the default setting for future compiles. The function argument uses the same rules as for  setfenv() .", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_14", 
            "text": "If invoked without arguments, returns the current level settings. Otherwise,  nil  is returned.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_9", 
            "text": "node.stripdebug(3)\nnode.compile('bigstuff.lua')", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#see-also_4", 
            "text": "node.compile()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/node/#nodeosprint", 
            "text": "Controls whether the debugging output from the Espressif SDK is printed. Note that this is only available if\nthe firmware is build with DEVELOPMENT_TOOLS defined.", 
            "title": "node.osprint()"
        }, 
        {
            "location": "/en/modules/node/#syntax_15", 
            "text": "node.osprint(enabled)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_15", 
            "text": "enabled  This is either  true  to enable printing, or  false  to disable it. The default is  false .", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_15", 
            "text": "Nothing", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_10", 
            "text": "node.osprint(true)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#noderandom", 
            "text": "This behaves like math.random except that it uses true random numbers derived from the ESP8266 hardware. It returns uniformly distributed\nnumbers in the required range. It also takes care to get large ranges correct.   It can be called in three ways. Without arguments in the floating point build of NodeMCU, it returns a random real number with uniform distribution in the interval [0,1). \nWhen called with only one argument, an integer n, it returns an integer random number x such that 1  = x  = n. For instance, you can simulate the result of a die with random(6). \nFinally, random can be called with two integer arguments, l and u, to get a pseudo-random integer x such that l  = x  = u.", 
            "title": "node.random()"
        }, 
        {
            "location": "/en/modules/node/#syntax_16", 
            "text": "node.random()  node.random(n)  node.random(l, u)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_16", 
            "text": "n  the number of distinct integer values that can be returned -- in the (inclusive) range 1 ..  n  l  the lower bound of the range  u  the upper bound of the range", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_16", 
            "text": "The random number in the appropriate range. Note that the zero argument form will always return 0 in the integer build.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_11", 
            "text": "print ( I rolled a , node.random(6))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#nodeegc-module", 
            "text": "", 
            "title": "node.egc module"
        }, 
        {
            "location": "/en/modules/node/#nodeegcsetmode", 
            "text": "Sets the Emergency Garbage Collector mode.  The EGC whitepaper \nprovides more detailed information on the EGC.", 
            "title": "node.egc.setmode()"
        }, 
        {
            "location": "/en/modules/node/#syntax_17", 
            "text": "node.egc.setmode(mode, [param])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_17", 
            "text": "mode  node.egc.NOT_ACTIVE  EGC inactive, no collection cycle will be forced in low memory situations  node.egc.ON_ALLOC_FAILURE  Try to allocate a new block of memory, and run the garbage collector if the allocation fails. If the allocation fails even after running the garbage collector, the allocator will return with error.   node.egc.ON_MEM_LIMIT  Run the garbage collector when the memory used by the Lua script goes beyond an upper  limit . If the upper limit can't be satisfied even after running the garbage collector, the allocator will return with error.  node.egc.ALWAYS  Run the garbage collector before each memory allocation. If the allocation fails even after running the garbage collector, the allocator will return with error. This mode is very efficient with regards to memory savings, but it's also the slowest.    level  in the case of  node.egc.ON_MEM_LIMIT , this specifies the memory limit.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_17", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_12", 
            "text": "node.egc.setmode(node.egc.ALWAYS, 4096)  -- This is the default setting at startup.  node.egc.setmode(node.egc.ON_ALLOC_FAILURE) -- This is the fastest activeEGC mode.", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/node/#nodetask-module", 
            "text": "", 
            "title": "node.task module"
        }, 
        {
            "location": "/en/modules/node/#nodetaskpost", 
            "text": "Enable a Lua callback or task to post another task request. Note that as per the \nexample multiple tasks can be posted in any task, but the highest priority is \nalways delivered first.  If the task queue is full then a queue full error is raised.", 
            "title": "node.task.post()"
        }, 
        {
            "location": "/en/modules/node/#syntax_18", 
            "text": "node.task.post([task_priority], function)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/node/#parameters_18", 
            "text": "task_priority  (optional)  node.task.LOW_PRIORITY  = 0  node.task.MEDIUM_PRIORITY  = 1  node.task.HIGH_PRIORITY  = 2    function  a callback function to be executed when the task is run.    If the priority is omitted then  this defaults  to  node.task.MEDIUM_PRIORITY", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/node/#returns_18", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/node/#example_13", 
            "text": "for i = node.task.LOW_PRIORITY, node.task.HIGH_PRIORITY do \n  node.task.post(i,function(p2)\n    print( priority is  ..p2)\n  end) \nend        prints  priority is 2\npriority is 1\npriority is 0", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ow/", 
            "text": "1-Wire Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-22\n\n\nZeroday\n\n\nZeroday\n\n\now.c\n\n\n\n\n\n\n\n\nThis module provides functions to work with the \n1-Wire\n device communications bus system.\n\n\now.check_crc16()\n\n\nComputes the 1-Wire CRC16 and compare it against the received CRC.\n\n\nSyntax\n\n\now.check_crc16(buf, inverted_crc0, inverted_crc1[, crc])\n\n\nParameters\n\n\n\n\nbuf\n string value, data to be calculated check sum in string\n\n\ninverted_crc0\n LSB of received CRC\n\n\ninverted_crc1\n MSB of received CRC\n\n\ncrc\n CRC starting value (optional)\n\n\n\n\nReturns\n\n\ntrue if the CRC matches, false otherwise\n\n\now.crc16()\n\n\nComputes a Dallas Semiconductor 16 bit CRC.  This is required to check the integrity of data received from many 1-Wire devices.  Note that the CRC computed here is \nnot\n what you'll get from the 1-Wire network, for two reasons:\n\n\n\n\nThe CRC is transmitted bitwise inverted.\n\n\nDepending on the endian-ness of your processor, the binary representation of the two-byte return value may have a different byte order than the two bytes you get from 1-Wire.\n\n\n\n\nSyntax\n\n\now.crc16(buf[, crc])\n\n\nParameters\n\n\n\n\nbuf\n string value, data to be calculated check sum in string\n\n\ncrc\n CRC starting value (optional)\n\n\n\n\nReturns\n\n\nthe CRC16 as defined by Dallas Semiconductor\n\n\now.crc8()\n\n\nComputes a Dallas Semiconductor 8 bit CRC, these are used in the ROM and scratchpad registers.\n\n\nSyntax\n\n\now.crc8(buf)\n\n\nParameters\n\n\nbuf\n string value, data to be calculated check sum in string\n\n\nReturns\n\n\nCRC result as byte\n\n\now.depower()\n\n\nStops forcing power onto the bus. You only need to do this if you used the 'power' flag to \now.write()\n or used a \now.write_bytes()\n and aren't about to do another read or write.\n\n\nSyntax\n\n\now.depower(pin)\n\n\nParameters\n\n\npin\n 1~12, I/O index\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\n\n\now.write()\n\n\now.write_bytes()\n\n\n\n\now.read()\n\n\nReads a byte.\n\n\nSyntax\n\n\now.read(pin)\n\n\nParameters\n\n\npin\n 1~12, I/O index\n\n\nReturns\n\n\nbyte read from slave device\n\n\now.read_bytes()\n\n\nReads multi bytes.\n\n\nSyntax\n\n\now.read_bytes(pin, size)\n\n\nParameters\n\n\n\n\npin\n 1~12, I/O index\n\n\nsize\n number of bytes to be read from slave device (up to 256)\n\n\n\n\nReturns\n\n\nstring\n bytes read from slave device\n\n\now.reset()\n\n\nPerforms a 1-Wire reset cycle.\n\n\nSyntax\n\n\now.reset(pin)\n\n\nParameters\n\n\npin\n 1~12, I/O index\n\n\nReturns\n\n\n\n\n1\n if a device responds with a presence pulse\n\n\n0\n if there is no device or the bus is shorted or otherwise held low for more than 250 \u00b5S\n\n\n\n\now.reset_search()\n\n\nClears the search state so that it will start from the beginning again.\n\n\nSyntax\n\n\now.reset_search(pin)\n\n\nParameters\n\n\npin\n 1~12, I/O index\n\n\nReturns\n\n\nnil\n\n\now.search()\n\n\nLooks for the next device.\n\n\nSyntax\n\n\now.search(pin)\n\n\nParameters\n\n\npin\n 1~12, I/O index\n\n\nReturns\n\n\nrom_code\n string with length of 8 upon success. It contains the rom code of slave device. Returns \nnil\n if search was unsuccessful.\n\n\nSee also\n\n\now.target_search()\n\n\now.select()\n\n\nIssues a 1-Wire rom select command. Make sure you do the \now.reset(pin)\n first.\n\n\nSyntax\n\n\now.select(pin, rom)\n\n\nParameters\n\n\n\n\npin\n 1~12, I/O index\n\n\nrom\n string value, len 8, rom code of the slave device\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- 18b20 Example\npin = 9\now.setup(pin)\ncount = 0\nrepeat\n  count = count + 1\n  addr = ow.reset_search(pin)\n  addr = ow.search(pin)\n  tmr.wdclr()\nuntil (addr ~= nil) or (count \n 100)\nif addr == nil then\n  print(\nNo more addresses.\n)\nelse\n  print(addr:byte(1,8))\n  crc = ow.crc8(string.sub(addr,1,7))\n  if crc == addr:byte(8) then\n    if (addr:byte(1) == 0x10) or (addr:byte(1) == 0x28) then\n      print(\nDevice is a DS18S20 family device.\n)\n        repeat\n          ow.reset(pin)\n          ow.select(pin, addr)\n          ow.write(pin, 0x44, 1)\n          tmr.delay(1000000)\n          present = ow.reset(pin)\n          ow.select(pin, addr)\n          ow.write(pin,0xBE,1)\n          print(\nP=\n..present)  \n          data = nil\n          data = string.char(ow.read(pin))\n          for i = 1, 8 do\n            data = data .. string.char(ow.read(pin))\n          end\n          print(data:byte(1,9))\n          crc = ow.crc8(string.sub(data,1,8))\n          print(\nCRC=\n..crc)\n          if crc == data:byte(9) then\n             t = (data:byte(1) + data:byte(2) * 256) * 625\n             t1 = t / 10000\n             t2 = t % 10000\n             print(\nTemperature=\n..t1..\n.\n..t2..\nCentigrade\n)\n          end                   \n          tmr.wdclr()\n        until false\n    else\n      print(\nDevice family is not recognized.\n)\n    end\n  else\n    print(\nCRC is not valid!\n)\n  end\nend\n\n\n\n\nSee also\n\n\now.reset()\n\n\now.setup()\n\n\nSets a pin in onewire mode.\n\n\nSyntax\n\n\now.setup(pin)\n\n\nParameters\n\n\npin\n 1~12, I/O index\n\n\nReturns\n\n\nnil\n\n\now.skip()\n\n\nIssues a 1-Wire rom skip command, to address all on bus.\n\n\nSyntax\n\n\now.skip(pin)\n\n\nParameters\n\n\npin\n 1~12, I/O index\n\n\nReturns\n\n\nnil\n\n\now.target_search()\n\n\nSets up the search to find the device type \nfamily_code\n. The search itself has to be initiated with a subsequent call to \now.search()\n.\n\n\nSyntax\n\n\now.target_search(pin, family_code)\n\n\nParameters\n\n\n\n\npin\n 1~12, I/O index\n\n\nfamily_code\n byte for family code\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\now.search()\n\n\now.write()\n\n\nWrites a byte. If \npower\n is 1 then the wire is held high at the end for parasitically powered devices. You are responsible for eventually depowering it by calling \now.depower()\n or doing another read or write.\n\n\nSyntax\n\n\now.write(pin, v, power)\n\n\nParameters\n\n\n\n\npin\n 1~12, I/O index\n\n\nv\n byte to be written to slave device \n\n\npower\n 1 for wire being held high for parasitically powered devices\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\now.depower()\n\n\now.write_bytes()\n\n\nWrites multi bytes. If \npower\n is 1 then the wire is held high at the end for parasitically powered devices. You are responsible for eventually depowering it by calling \now.depower()\n or doing another read or write.\n\n\nSyntax\n\n\now.write_bytes(pin, buf, power)\n\n\nParameters\n\n\n\n\npin\n 1~12, IO index\n\n\nbuf\n string to be written to slave device\n\n\npower\n 1 for wire being held high for parasitically powered devices\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\now.depower()", 
            "title": "ow (1-Wire)"
        }, 
        {
            "location": "/en/modules/ow/#1-wire-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-22  Zeroday  Zeroday  ow.c     This module provides functions to work with the  1-Wire  device communications bus system.", 
            "title": "1-Wire Module"
        }, 
        {
            "location": "/en/modules/ow/#owcheck_crc16", 
            "text": "Computes the 1-Wire CRC16 and compare it against the received CRC.", 
            "title": "ow.check_crc16()"
        }, 
        {
            "location": "/en/modules/ow/#syntax", 
            "text": "ow.check_crc16(buf, inverted_crc0, inverted_crc1[, crc])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters", 
            "text": "buf  string value, data to be calculated check sum in string  inverted_crc0  LSB of received CRC  inverted_crc1  MSB of received CRC  crc  CRC starting value (optional)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns", 
            "text": "true if the CRC matches, false otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#owcrc16", 
            "text": "Computes a Dallas Semiconductor 16 bit CRC.  This is required to check the integrity of data received from many 1-Wire devices.  Note that the CRC computed here is  not  what you'll get from the 1-Wire network, for two reasons:   The CRC is transmitted bitwise inverted.  Depending on the endian-ness of your processor, the binary representation of the two-byte return value may have a different byte order than the two bytes you get from 1-Wire.", 
            "title": "ow.crc16()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_1", 
            "text": "ow.crc16(buf[, crc])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_1", 
            "text": "buf  string value, data to be calculated check sum in string  crc  CRC starting value (optional)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_1", 
            "text": "the CRC16 as defined by Dallas Semiconductor", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#owcrc8", 
            "text": "Computes a Dallas Semiconductor 8 bit CRC, these are used in the ROM and scratchpad registers.", 
            "title": "ow.crc8()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_2", 
            "text": "ow.crc8(buf)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_2", 
            "text": "buf  string value, data to be calculated check sum in string", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_2", 
            "text": "CRC result as byte", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#owdepower", 
            "text": "Stops forcing power onto the bus. You only need to do this if you used the 'power' flag to  ow.write()  or used a  ow.write_bytes()  and aren't about to do another read or write.", 
            "title": "ow.depower()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_3", 
            "text": "ow.depower(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_3", 
            "text": "pin  1~12, I/O index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#see-also", 
            "text": "ow.write()  ow.write_bytes()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/ow/#owread", 
            "text": "Reads a byte.", 
            "title": "ow.read()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_4", 
            "text": "ow.read(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_4", 
            "text": "pin  1~12, I/O index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_4", 
            "text": "byte read from slave device", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#owread_bytes", 
            "text": "Reads multi bytes.", 
            "title": "ow.read_bytes()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_5", 
            "text": "ow.read_bytes(pin, size)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_5", 
            "text": "pin  1~12, I/O index  size  number of bytes to be read from slave device (up to 256)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_5", 
            "text": "string  bytes read from slave device", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#owreset", 
            "text": "Performs a 1-Wire reset cycle.", 
            "title": "ow.reset()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_6", 
            "text": "ow.reset(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_6", 
            "text": "pin  1~12, I/O index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_6", 
            "text": "1  if a device responds with a presence pulse  0  if there is no device or the bus is shorted or otherwise held low for more than 250 \u00b5S", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#owreset_search", 
            "text": "Clears the search state so that it will start from the beginning again.", 
            "title": "ow.reset_search()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_7", 
            "text": "ow.reset_search(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_7", 
            "text": "pin  1~12, I/O index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_7", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#owsearch", 
            "text": "Looks for the next device.", 
            "title": "ow.search()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_8", 
            "text": "ow.search(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_8", 
            "text": "pin  1~12, I/O index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_8", 
            "text": "rom_code  string with length of 8 upon success. It contains the rom code of slave device. Returns  nil  if search was unsuccessful.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#see-also_1", 
            "text": "ow.target_search()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/ow/#owselect", 
            "text": "Issues a 1-Wire rom select command. Make sure you do the  ow.reset(pin)  first.", 
            "title": "ow.select()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_9", 
            "text": "ow.select(pin, rom)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_9", 
            "text": "pin  1~12, I/O index  rom  string value, len 8, rom code of the slave device", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_9", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#example", 
            "text": "-- 18b20 Example\npin = 9\now.setup(pin)\ncount = 0\nrepeat\n  count = count + 1\n  addr = ow.reset_search(pin)\n  addr = ow.search(pin)\n  tmr.wdclr()\nuntil (addr ~= nil) or (count   100)\nif addr == nil then\n  print( No more addresses. )\nelse\n  print(addr:byte(1,8))\n  crc = ow.crc8(string.sub(addr,1,7))\n  if crc == addr:byte(8) then\n    if (addr:byte(1) == 0x10) or (addr:byte(1) == 0x28) then\n      print( Device is a DS18S20 family device. )\n        repeat\n          ow.reset(pin)\n          ow.select(pin, addr)\n          ow.write(pin, 0x44, 1)\n          tmr.delay(1000000)\n          present = ow.reset(pin)\n          ow.select(pin, addr)\n          ow.write(pin,0xBE,1)\n          print( P= ..present)  \n          data = nil\n          data = string.char(ow.read(pin))\n          for i = 1, 8 do\n            data = data .. string.char(ow.read(pin))\n          end\n          print(data:byte(1,9))\n          crc = ow.crc8(string.sub(data,1,8))\n          print( CRC= ..crc)\n          if crc == data:byte(9) then\n             t = (data:byte(1) + data:byte(2) * 256) * 625\n             t1 = t / 10000\n             t2 = t % 10000\n             print( Temperature= ..t1.. . ..t2.. Centigrade )\n          end                   \n          tmr.wdclr()\n        until false\n    else\n      print( Device family is not recognized. )\n    end\n  else\n    print( CRC is not valid! )\n  end\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ow/#see-also_2", 
            "text": "ow.reset()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/ow/#owsetup", 
            "text": "Sets a pin in onewire mode.", 
            "title": "ow.setup()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_10", 
            "text": "ow.setup(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_10", 
            "text": "pin  1~12, I/O index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_10", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#owskip", 
            "text": "Issues a 1-Wire rom skip command, to address all on bus.", 
            "title": "ow.skip()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_11", 
            "text": "ow.skip(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_11", 
            "text": "pin  1~12, I/O index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_11", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#owtarget_search", 
            "text": "Sets up the search to find the device type  family_code . The search itself has to be initiated with a subsequent call to  ow.search() .", 
            "title": "ow.target_search()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_12", 
            "text": "ow.target_search(pin, family_code)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_12", 
            "text": "pin  1~12, I/O index  family_code  byte for family code", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_12", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#see-also_3", 
            "text": "ow.search()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/ow/#owwrite", 
            "text": "Writes a byte. If  power  is 1 then the wire is held high at the end for parasitically powered devices. You are responsible for eventually depowering it by calling  ow.depower()  or doing another read or write.", 
            "title": "ow.write()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_13", 
            "text": "ow.write(pin, v, power)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_13", 
            "text": "pin  1~12, I/O index  v  byte to be written to slave device   power  1 for wire being held high for parasitically powered devices", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_13", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#see-also_4", 
            "text": "ow.depower()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/ow/#owwrite_bytes", 
            "text": "Writes multi bytes. If  power  is 1 then the wire is held high at the end for parasitically powered devices. You are responsible for eventually depowering it by calling  ow.depower()  or doing another read or write.", 
            "title": "ow.write_bytes()"
        }, 
        {
            "location": "/en/modules/ow/#syntax_14", 
            "text": "ow.write_bytes(pin, buf, power)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ow/#parameters_14", 
            "text": "pin  1~12, IO index  buf  string to be written to slave device  power  1 for wire being held high for parasitically powered devices", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ow/#returns_14", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ow/#see-also_5", 
            "text": "ow.depower()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/pcm/", 
            "text": "pcm module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-06-05\n\n\nArnim L\u00e4uger\n\n\nArnim L\u00e4uger\n\n\npcm.c\n\n\n\n\n\n\n\n\nPlay sounds through various back-ends.\n\n\nSigma-Delta hardware\n\n\nThe ESP contains a sigma-delta generator that can be used to synthesize audio with the help of an external low-pass filter. All regular GPIOs (except GPIO0) are able to output the digital waveform, though there is only one single generator.\n\n\nThe external filter circuit is shown in the following schematic. Note that the voltage divider resistors limit the output voltage to 1\nV\nPP\n. This should match most amplifier boards, but cross-checking against your specific configuration is required.\n\n\n\n\n\n\nImportant\n\n\nThis driver shares hardware resources with other modules. Thus you can't operate it in parallel to the \nsigma delta\n, \nperf\n, or \npwm\n modules. They require the sigma-delta generator and the hw_timer, respectively.\n\n\n\n\nAudio format\n\n\nAudio is expected as a mono raw unsigned 8\nbit stream at sample rates between 1\nk and 16\nk samples per second. Regular WAV files can be converted with OSS tools like \nAudacity\n or \nSoX\n. Adjust the volume before the conversion.\n\n\nsox jump.wav -r 8000 -b 8 -c 1 jump_8k.u8\n\n\n\n\nAlso see \nplay_file.lua\n in the examples folder.\n\n\npcm.new()\n\n\nInitializes the audio driver.\n\n\nSigma-Delta driver\n\n\nSyntax\n\n\npcm.new(pcm.SD, pin)\n\n\nParameters\n\n\npcm.SD\n use sigma-delta hardware\n- \npin\n 1~10, IO index\n\n\nReturns\n\n\nAudio driver object.\n\n\nAudio driver sub-module\n\n\nEach audio driver exhibits the same control methods for playing sounds.\n\n\npcm.drv:close()\n\n\nStops playback and releases the audio hardware.\n\n\nSyntax\n\n\ndrv:close()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\npcm.drv:on()\n\n\nRegister callback functions for events.\n\n\nSyntax\n\n\ndrv:on(event[, cb_fn[, freq]])\n\n\nParameters\n\n\n\n\nevent\n identifier, one of:\n\n\ndata\n callback function is supposed to return a string containing the next chunk of data.\n\n\ndrained\n playback was stopped due to lack of data. The last 2 invocations of the \ndata\n callback didn't provide new chunks in time (intentionally or unintentionally) and the internal buffers were fully consumed.\n\n\npaused\n playback was paused by \npcm.drv:pause()\n.\n\n\nstopped\n playback was stopped by \npcm.drv:stop()\n.\n\n\nvu\n new peak data, \ncb_fn\n is triggered \nfreq\n times per second (1 to 200 Hz).\n\n\n\n\n\n\ncb_fn\n callback function for the specified event. Unregisters previous function if omitted. First parameter is \ndrv\n, followed by peak data for \nvu\n callback.\n\n\n\n\nReturns\n\n\nnil\n\n\npcm.drv:play()\n\n\nStarts playback.\n\n\nSyntax\n\n\ndrv:play(rate)\n\n\nParameters\n\n\nrate\n sample rate. Supported are \npcm.RATE_1K\n, \npcm.RATE_2K\n, \npcm.RATE_4K\n, \npcm.RATE_5K\n, \npcm.RATE_8K\n, \npcm.RATE_10K\n, \npcm.RATE_12K\n, \npcm.RATE_16K\n and defaults to \nRATE_8K\n if omitted.\n\n\nReturns\n\n\nnil\n\n\npcm.drv:pause()\n\n\nPauses playback. A call to \ndrv:play()\n will resume from the last position.\n\n\nSyntax\n\n\ndrv:pause()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\npcm.drv:stop()\n\n\nStops playback and releases buffered chunks.\n\n\nSyntax\n\n\ndrv:stop()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil", 
            "title": "pcm"
        }, 
        {
            "location": "/en/modules/pcm/#pcm-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-06-05  Arnim L\u00e4uger  Arnim L\u00e4uger  pcm.c     Play sounds through various back-ends.", 
            "title": "pcm module"
        }, 
        {
            "location": "/en/modules/pcm/#sigma-delta-hardware", 
            "text": "The ESP contains a sigma-delta generator that can be used to synthesize audio with the help of an external low-pass filter. All regular GPIOs (except GPIO0) are able to output the digital waveform, though there is only one single generator.  The external filter circuit is shown in the following schematic. Note that the voltage divider resistors limit the output voltage to 1 V PP . This should match most amplifier boards, but cross-checking against your specific configuration is required.    Important  This driver shares hardware resources with other modules. Thus you can't operate it in parallel to the  sigma delta ,  perf , or  pwm  modules. They require the sigma-delta generator and the hw_timer, respectively.", 
            "title": "Sigma-Delta hardware"
        }, 
        {
            "location": "/en/modules/pcm/#audio-format", 
            "text": "Audio is expected as a mono raw unsigned 8 bit stream at sample rates between 1 k and 16 k samples per second. Regular WAV files can be converted with OSS tools like  Audacity  or  SoX . Adjust the volume before the conversion.  sox jump.wav -r 8000 -b 8 -c 1 jump_8k.u8  Also see  play_file.lua  in the examples folder.", 
            "title": "Audio format"
        }, 
        {
            "location": "/en/modules/pcm/#pcmnew", 
            "text": "Initializes the audio driver.", 
            "title": "pcm.new()"
        }, 
        {
            "location": "/en/modules/pcm/#sigma-delta-driver", 
            "text": "", 
            "title": "Sigma-Delta driver"
        }, 
        {
            "location": "/en/modules/pcm/#syntax", 
            "text": "pcm.new(pcm.SD, pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pcm/#parameters", 
            "text": "pcm.SD  use sigma-delta hardware\n-  pin  1~10, IO index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pcm/#returns", 
            "text": "Audio driver object.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pcm/#audio-driver-sub-module", 
            "text": "Each audio driver exhibits the same control methods for playing sounds.", 
            "title": "Audio driver sub-module"
        }, 
        {
            "location": "/en/modules/pcm/#pcmdrvclose", 
            "text": "Stops playback and releases the audio hardware.", 
            "title": "pcm.drv:close()"
        }, 
        {
            "location": "/en/modules/pcm/#syntax_1", 
            "text": "drv:close()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pcm/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pcm/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pcm/#pcmdrvon", 
            "text": "Register callback functions for events.", 
            "title": "pcm.drv:on()"
        }, 
        {
            "location": "/en/modules/pcm/#syntax_2", 
            "text": "drv:on(event[, cb_fn[, freq]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pcm/#parameters_2", 
            "text": "event  identifier, one of:  data  callback function is supposed to return a string containing the next chunk of data.  drained  playback was stopped due to lack of data. The last 2 invocations of the  data  callback didn't provide new chunks in time (intentionally or unintentionally) and the internal buffers were fully consumed.  paused  playback was paused by  pcm.drv:pause() .  stopped  playback was stopped by  pcm.drv:stop() .  vu  new peak data,  cb_fn  is triggered  freq  times per second (1 to 200 Hz).    cb_fn  callback function for the specified event. Unregisters previous function if omitted. First parameter is  drv , followed by peak data for  vu  callback.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pcm/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pcm/#pcmdrvplay", 
            "text": "Starts playback.", 
            "title": "pcm.drv:play()"
        }, 
        {
            "location": "/en/modules/pcm/#syntax_3", 
            "text": "drv:play(rate)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pcm/#parameters_3", 
            "text": "rate  sample rate. Supported are  pcm.RATE_1K ,  pcm.RATE_2K ,  pcm.RATE_4K ,  pcm.RATE_5K ,  pcm.RATE_8K ,  pcm.RATE_10K ,  pcm.RATE_12K ,  pcm.RATE_16K  and defaults to  RATE_8K  if omitted.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pcm/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pcm/#pcmdrvpause", 
            "text": "Pauses playback. A call to  drv:play()  will resume from the last position.", 
            "title": "pcm.drv:pause()"
        }, 
        {
            "location": "/en/modules/pcm/#syntax_4", 
            "text": "drv:pause()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pcm/#parameters_4", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pcm/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pcm/#pcmdrvstop", 
            "text": "Stops playback and releases buffered chunks.", 
            "title": "pcm.drv:stop()"
        }, 
        {
            "location": "/en/modules/pcm/#syntax_5", 
            "text": "drv:stop()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pcm/#parameters_5", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pcm/#returns_5", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/perf/", 
            "text": "perf Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-02-26\n\n\nPhilip Gladstone\n\n\nPhilip Gladstone\n\n\nperf.c\n\n\n\n\n\n\n\n\nThis module provides simple performance measurement for an application. It samples the program counter roughly every 50 microseconds and builds a histogram of the values that it finds. Since there is only a small amount\nof memory to store the histogram, the user can specify which area of code is of interest. The default is the entire flash which contains code. Once the hotspots are identified, then the run can then be repeated with different areas and at different resolutions to get as much information as required.\n\n\nperf.start()\n\n\nStarts a performance monitoring session. \n\n\nSyntax\n\n\nperf.start([start[, end[, nbins]]])\n\n\nParameters\n\n\n\n\nstart\n (optional) The lowest PC address for the histogram. Default is 0x40000000.\n\n\nend\n (optional) The highest address for the histogram. Default is the end of the used space in the flash memory.\n\n\nnbins\n (optional) The number of bins in the histogram. Keep this reasonable otherwise \nyou will run out of memory. Default is 1024.\n\n\n\n\nNote that the number of bins is an upper limit. The size of each bin is set to be the smallest power of two\nsuch that the number of bins required is less than or equal to the provided number of bins.\n\n\nReturns\n\n\nNothing\n\n\nperf.stop()\n\n\nTerminates a performance monitoring session and returns the histogram.\n\n\nSyntax\n\n\ntotal, outside, histogram, binsize = perf.stop()\n\n\nReturns\n\n\n\n\ntotal\n The total number of samples captured in this run\n\n\noutside\n The number of samples that were outside the histogram range\n\n\nhistogram\n The histogram represented as a table indexed by address where the value is the number of samples. The address is the lowest address for the bin.\n\n\nbinsize\n The number of bytes per histogram bin.\n\n\n\n\nExample\n\n\nperf.start()\n\nfor j = 0, 100 do\n  str = \"str\"..j\nend\n\ntot, out, tbl, binsize = perf.stop()\n\nprint(tot, out)\nlocal keyset = {}\nlocal n = 0\nfor k,v in pairs(tbl) do\n  n=n+1\n  keyset[n]=k\nend\ntable.sort(keyset)\nfor kk,k in ipairs(keyset) do print(string.format(\"%x - %x\",k, k + binsize - 1),tbl[k]) end\n\n\n\nThis runs a loop creating strings 100 times and then prints out the histogram (after sorting it).\nThis takes around 2,500 samples and provides a good indication of where all the CPU time is\nbeing spent.", 
            "title": "perf"
        }, 
        {
            "location": "/en/modules/perf/#perf-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-02-26  Philip Gladstone  Philip Gladstone  perf.c     This module provides simple performance measurement for an application. It samples the program counter roughly every 50 microseconds and builds a histogram of the values that it finds. Since there is only a small amount\nof memory to store the histogram, the user can specify which area of code is of interest. The default is the entire flash which contains code. Once the hotspots are identified, then the run can then be repeated with different areas and at different resolutions to get as much information as required.", 
            "title": "perf Module"
        }, 
        {
            "location": "/en/modules/perf/#perfstart", 
            "text": "Starts a performance monitoring session.", 
            "title": "perf.start()"
        }, 
        {
            "location": "/en/modules/perf/#syntax", 
            "text": "perf.start([start[, end[, nbins]]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/perf/#parameters", 
            "text": "start  (optional) The lowest PC address for the histogram. Default is 0x40000000.  end  (optional) The highest address for the histogram. Default is the end of the used space in the flash memory.  nbins  (optional) The number of bins in the histogram. Keep this reasonable otherwise \nyou will run out of memory. Default is 1024.   Note that the number of bins is an upper limit. The size of each bin is set to be the smallest power of two\nsuch that the number of bins required is less than or equal to the provided number of bins.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/perf/#returns", 
            "text": "Nothing", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/perf/#perfstop", 
            "text": "Terminates a performance monitoring session and returns the histogram.", 
            "title": "perf.stop()"
        }, 
        {
            "location": "/en/modules/perf/#syntax_1", 
            "text": "total, outside, histogram, binsize = perf.stop()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/perf/#returns_1", 
            "text": "total  The total number of samples captured in this run  outside  The number of samples that were outside the histogram range  histogram  The histogram represented as a table indexed by address where the value is the number of samples. The address is the lowest address for the bin.  binsize  The number of bytes per histogram bin.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/perf/#example", 
            "text": "perf.start()\n\nfor j = 0, 100 do\n  str = \"str\"..j\nend\n\ntot, out, tbl, binsize = perf.stop()\n\nprint(tot, out)\nlocal keyset = {}\nlocal n = 0\nfor k,v in pairs(tbl) do\n  n=n+1\n  keyset[n]=k\nend\ntable.sort(keyset)\nfor kk,k in ipairs(keyset) do print(string.format(\"%x - %x\",k, k + binsize - 1),tbl[k]) end  This runs a loop creating strings 100 times and then prints out the histogram (after sorting it).\nThis takes around 2,500 samples and provides a good indication of where all the CPU time is\nbeing spent.", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/pwm/", 
            "text": "PWM Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-22\n\n\nZeroday\n\n\nZeroday\n\n\npwm.c\n\n\n\n\n\n\n\n\npwm.close()\n\n\nQuit PWM mode for the specified GPIO pin.\n\n\nSyntax\n\n\npwm.close(pin)\n\n\nParameters\n\n\npin\n 1~12, IO index\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\npwm.start()\n\n\npwm.getclock()\n\n\nGet selected PWM frequency of pin.\n\n\nSyntax\n\n\npwm.getclock(pin)\n\n\nParameters\n\n\npin\n 1~12, IO index\n\n\nReturns\n\n\nnumber\n PWM frequency of pin\n\n\nSee also\n\n\npwm.setclock()\n\n\nSee also\n\n\npwm.getduty()\n\n\npwm.getduty()\n\n\nGet selected duty cycle of pin.\n\n\nSyntax\n\n\npwm.getduty(pin)\n\n\nParameters\n\n\npin\n 1~12, IO index\n\n\nReturns\n\n\nnumber\n duty cycle, max 1023\n\n\nSee also\n\n\npwm.setduty()\n\n\npwm.setclock()\n\n\nSet PWM frequency.\n\nNote:\n Setup of the PWM frequency will synchronously change other setups as well if there are any. Only one PWM frequency can be allowed for the system.\n\n\nSyntax\n\n\npwm.setclock(pin, clock)\n\n\nParameters\n\n\n\n\npin\n 1~12, IO index\n\n\nclock\n 1~1000, PWM frequency\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\npwm.getclock()\n\n\npwm.setduty()\n\n\nSet duty cycle for a pin.\n\n\nSyntax\n\n\npwm.setduty(pin, duty)\n\n\nParameters\n\n\n\n\npin\n 1~12, IO index\n\n\nduty\n 0~1023, pwm duty cycle, max 1023 (10bit)\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- D1 is connected to green led\n-- D2 is connected to blue led\n-- D3 is connected to red led\npwm.setup(1, 500, 512)\npwm.setup(2, 500, 512)\npwm.setup(3, 500, 512)\npwm.start(1)\npwm.start(2)\npwm.start(3)\nfunction led(r, g, b)\n    pwm.setduty(1, g)\n    pwm.setduty(2, b)\n    pwm.setduty(3, r)\nend\nled(512, 0, 0) --  set led to red\nled(0, 0, 512) -- set led to blue.\n\n\n\n\npwm.setup()\n\n\nSet pin to PWM mode. Only 6 pins can be set to PWM mode at the most.\n\n\nSyntax\n\n\npwm.setup(pin, clock, duty)\n\n\nParameters\n\n\n\n\npin\n 1~12, IO index\n\n\nclock\n 1~1000, pwm frequency\n\n\nduty\n 0~1023, pwm duty cycle, max 1023 (10bit)\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- set pin index 1 as pwm output, frequency is 100Hz, duty cycle is half.\npwm.setup(1, 100, 512)\n\n\n\n\nSee also\n\n\npwm.start()\n\n\npwm.start()\n\n\nPWM starts, the waveform is applied to the GPIO pin.\n\n\nSyntax\n\n\npwm.start(pin)\n\n\nParameters\n\n\npin\n 1~12, IO index\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\npwm.stop()\n\n\npwm.stop()\n\n\nPause the output of the PWM waveform.\n\n\nSyntax\n\n\npwm.stop(pin)\n\n\nParameters\n\n\npin\n 1~12, IO index\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\npwm.start()", 
            "title": "pwm"
        }, 
        {
            "location": "/en/modules/pwm/#pwm-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-22  Zeroday  Zeroday  pwm.c", 
            "title": "PWM Module"
        }, 
        {
            "location": "/en/modules/pwm/#pwmclose", 
            "text": "Quit PWM mode for the specified GPIO pin.", 
            "title": "pwm.close()"
        }, 
        {
            "location": "/en/modules/pwm/#syntax", 
            "text": "pwm.close(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pwm/#parameters", 
            "text": "pin  1~12, IO index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pwm/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pwm/#see-also", 
            "text": "pwm.start()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/pwm/#pwmgetclock", 
            "text": "Get selected PWM frequency of pin.", 
            "title": "pwm.getclock()"
        }, 
        {
            "location": "/en/modules/pwm/#syntax_1", 
            "text": "pwm.getclock(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pwm/#parameters_1", 
            "text": "pin  1~12, IO index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pwm/#returns_1", 
            "text": "number  PWM frequency of pin", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pwm/#see-also_1", 
            "text": "pwm.setclock()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/pwm/#see-also_2", 
            "text": "pwm.getduty()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/pwm/#pwmgetduty", 
            "text": "Get selected duty cycle of pin.", 
            "title": "pwm.getduty()"
        }, 
        {
            "location": "/en/modules/pwm/#syntax_2", 
            "text": "pwm.getduty(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pwm/#parameters_2", 
            "text": "pin  1~12, IO index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pwm/#returns_2", 
            "text": "number  duty cycle, max 1023", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pwm/#see-also_3", 
            "text": "pwm.setduty()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/pwm/#pwmsetclock", 
            "text": "Set PWM frequency. Note:  Setup of the PWM frequency will synchronously change other setups as well if there are any. Only one PWM frequency can be allowed for the system.", 
            "title": "pwm.setclock()"
        }, 
        {
            "location": "/en/modules/pwm/#syntax_3", 
            "text": "pwm.setclock(pin, clock)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pwm/#parameters_3", 
            "text": "pin  1~12, IO index  clock  1~1000, PWM frequency", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pwm/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pwm/#see-also_4", 
            "text": "pwm.getclock()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/pwm/#pwmsetduty", 
            "text": "Set duty cycle for a pin.", 
            "title": "pwm.setduty()"
        }, 
        {
            "location": "/en/modules/pwm/#syntax_4", 
            "text": "pwm.setduty(pin, duty)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pwm/#parameters_4", 
            "text": "pin  1~12, IO index  duty  0~1023, pwm duty cycle, max 1023 (10bit)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pwm/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pwm/#example", 
            "text": "-- D1 is connected to green led\n-- D2 is connected to blue led\n-- D3 is connected to red led\npwm.setup(1, 500, 512)\npwm.setup(2, 500, 512)\npwm.setup(3, 500, 512)\npwm.start(1)\npwm.start(2)\npwm.start(3)\nfunction led(r, g, b)\n    pwm.setduty(1, g)\n    pwm.setduty(2, b)\n    pwm.setduty(3, r)\nend\nled(512, 0, 0) --  set led to red\nled(0, 0, 512) -- set led to blue.", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/pwm/#pwmsetup", 
            "text": "Set pin to PWM mode. Only 6 pins can be set to PWM mode at the most.", 
            "title": "pwm.setup()"
        }, 
        {
            "location": "/en/modules/pwm/#syntax_5", 
            "text": "pwm.setup(pin, clock, duty)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pwm/#parameters_5", 
            "text": "pin  1~12, IO index  clock  1~1000, pwm frequency  duty  0~1023, pwm duty cycle, max 1023 (10bit)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pwm/#returns_5", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pwm/#example_1", 
            "text": "-- set pin index 1 as pwm output, frequency is 100Hz, duty cycle is half.\npwm.setup(1, 100, 512)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/pwm/#see-also_5", 
            "text": "pwm.start()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/pwm/#pwmstart", 
            "text": "PWM starts, the waveform is applied to the GPIO pin.", 
            "title": "pwm.start()"
        }, 
        {
            "location": "/en/modules/pwm/#syntax_6", 
            "text": "pwm.start(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pwm/#parameters_6", 
            "text": "pin  1~12, IO index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pwm/#returns_6", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pwm/#see-also_6", 
            "text": "pwm.stop()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/pwm/#pwmstop", 
            "text": "Pause the output of the PWM waveform.", 
            "title": "pwm.stop()"
        }, 
        {
            "location": "/en/modules/pwm/#syntax_7", 
            "text": "pwm.stop(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/pwm/#parameters_7", 
            "text": "pin  1~12, IO index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/pwm/#returns_7", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/pwm/#see-also_7", 
            "text": "pwm.start()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/rc/", 
            "text": "RC Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-06-12\n\n\nMike Wen\n\n\n-\n\n\nrc.c", 
            "title": "rc"
        }, 
        {
            "location": "/en/modules/rc/#rc-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-06-12  Mike Wen  -  rc.c", 
            "title": "RC Module"
        }, 
        {
            "location": "/en/modules/rfswitch/", 
            "text": "rfswitch Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-12-01\n\n\nRoman Fedorov\n\n\nRoman Fedorov\n\n\nrfswitch.c\n\n\n\n\n\n\n\n\nModule to operate 433/315Mhz devices like power outlet sockets, relays, etc. This will most likely work with all popular low cost power outlet sockets with a SC5262 / SC5272, HX2262 / HX2272, PT2262 / PT2272, EV1527, RT1527, FP1527 or HS1527 chipset.\n\n\nThis module uses some code from the \noriginal rc-switch Arduino lib\n but NodeMCU and Arduino are not fully compatible. This required that \nrc-switch\n was rewritten into  \nrfswitch\n NodeMCU with Lua support.\n\n\nConnection of transmitter\n\n\n\n\n\n\n\n\nTransmitter\n\n\nESP8266\n\n\ncomments\n\n\n\n\n\n\n\n\n\n\nvin or +\n\n\n3V3\n\n\n3.3 - 5 volts on ESP8266 or other power source\n\n\n\n\n\n\nground or -\n\n\nGND\n\n\nground should be connected to ESP8266 and to power source\n\n\n\n\n\n\ndata pin\n\n\n6\n\n\nalmost any pin on ESP8266\n\n\n\n\n\n\n\n\nYou can read more about connection \nhere\n.\n\n\nSelecting proper protocol\n\n\nThis module supports \ntransmitting\n data using 6 different protocols\nand you should use one most suitable for your needs. \nReceiving\n data is not supported yet. So, you cannot listen radio air and get protocol details using Lua.\n\n\nThe easiest way to get the correct protocol is to connect the radio receiver to your ESP8266 or \nArduino\n,\nthen run \nReceiveDemo_Advanced.ino\n\nand view output in serial console (\nexample1\n,\n\nexample2\n).\n\n\nYou should get something like this:\n\n\nDecimal: 11001351 (24Bit)\nBinary: 101001111101111000000111\nTri-State: not applicable\nPulseLength: 517 microseconds\nProtocol: 5\n\nRaw data: 7200,1004,528,504,1048,980,336,1176,356,1176,352,1180,1108,412,356,1172,364,1168,356,1160,1176,1124,412,336,1180,1116,440,328,1188,340,1228,1060,416,1160,380,1160,1108,464,1068,436,328,1232,1060,412,1116,440,1088,428,3024,\n\n\n\n\nMore detailed about low level protocol specifications could be found \nhere\n\nYou can visualize a telegram copy the raw data by paste it into \nhttp://test.sui.li/oszi/\n\n\nrfswitch.send()\n\n\nTransmit data using the radio module.\n\n\nSyntax\n\n\nrfswitch.send(protocol_id, pulse_length, repeat, pin, value, length)\n\n\nParameters\n\n\n\n\nprotocol_id\n positive integer value, from 1-6\n\n\npulse_length\n length of one pulse in microseconds, usually from 100 to 650\n\n\nrepeat\n repeat value, usually from 1 to 5. This is a synchronous task. Setting the repeat count to a large value will cause problems.\nThe recommended limit is about 1-4. If you need more,\nthen call it asynchronously a few more times (e.g. using \nnode.task.post\n)\n\n\npin\n I/O index of pin, example 6 is for GPIO12, see \ndetails\n\n\nvalue\n positive integer value, this is the primary data which will be sent\n\n\nlength\n bit length of value, if value length is 3 bytes, then length is 24\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- lua transmit radio code using protocol #1\n-- pulse_length 300 microseconds\n-- repeat 5 times\n-- use pin #7 (GPIO13)\n-- value to send is 560777\n-- value length is 24 bits (3 bytes)\nrfswitch.send(1, 300, 5, 7, 560777, 24)", 
            "title": "rfswitch"
        }, 
        {
            "location": "/en/modules/rfswitch/#rfswitch-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-12-01  Roman Fedorov  Roman Fedorov  rfswitch.c     Module to operate 433/315Mhz devices like power outlet sockets, relays, etc. This will most likely work with all popular low cost power outlet sockets with a SC5262 / SC5272, HX2262 / HX2272, PT2262 / PT2272, EV1527, RT1527, FP1527 or HS1527 chipset.  This module uses some code from the  original rc-switch Arduino lib  but NodeMCU and Arduino are not fully compatible. This required that  rc-switch  was rewritten into   rfswitch  NodeMCU with Lua support.", 
            "title": "rfswitch Module"
        }, 
        {
            "location": "/en/modules/rfswitch/#connection-of-transmitter", 
            "text": "Transmitter  ESP8266  comments      vin or +  3V3  3.3 - 5 volts on ESP8266 or other power source    ground or -  GND  ground should be connected to ESP8266 and to power source    data pin  6  almost any pin on ESP8266     You can read more about connection  here .", 
            "title": "Connection of transmitter"
        }, 
        {
            "location": "/en/modules/rfswitch/#selecting-proper-protocol", 
            "text": "This module supports  transmitting  data using 6 different protocols\nand you should use one most suitable for your needs.  Receiving  data is not supported yet. So, you cannot listen radio air and get protocol details using Lua.  The easiest way to get the correct protocol is to connect the radio receiver to your ESP8266 or  Arduino ,\nthen run  ReceiveDemo_Advanced.ino \nand view output in serial console ( example1 , example2 ).  You should get something like this:  Decimal: 11001351 (24Bit)\nBinary: 101001111101111000000111\nTri-State: not applicable\nPulseLength: 517 microseconds\nProtocol: 5\n\nRaw data: 7200,1004,528,504,1048,980,336,1176,356,1176,352,1180,1108,412,356,1172,364,1168,356,1160,1176,1124,412,336,1180,1116,440,328,1188,340,1228,1060,416,1160,380,1160,1108,464,1068,436,328,1232,1060,412,1116,440,1088,428,3024,  More detailed about low level protocol specifications could be found  here \nYou can visualize a telegram copy the raw data by paste it into  http://test.sui.li/oszi/", 
            "title": "Selecting proper protocol"
        }, 
        {
            "location": "/en/modules/rfswitch/#rfswitchsend", 
            "text": "Transmit data using the radio module.", 
            "title": "rfswitch.send()"
        }, 
        {
            "location": "/en/modules/rfswitch/#syntax", 
            "text": "rfswitch.send(protocol_id, pulse_length, repeat, pin, value, length)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rfswitch/#parameters", 
            "text": "protocol_id  positive integer value, from 1-6  pulse_length  length of one pulse in microseconds, usually from 100 to 650  repeat  repeat value, usually from 1 to 5. This is a synchronous task. Setting the repeat count to a large value will cause problems.\nThe recommended limit is about 1-4. If you need more,\nthen call it asynchronously a few more times (e.g. using  node.task.post )  pin  I/O index of pin, example 6 is for GPIO12, see  details  value  positive integer value, this is the primary data which will be sent  length  bit length of value, if value length is 3 bytes, then length is 24", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rfswitch/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rfswitch/#example", 
            "text": "-- lua transmit radio code using protocol #1\n-- pulse_length 300 microseconds\n-- repeat 5 times\n-- use pin #7 (GPIO13)\n-- value to send is 560777\n-- value length is 24 bits (3 bytes)\nrfswitch.send(1, 300, 5, 7, 560777, 24)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rotary/", 
            "text": "rotary Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-03-01\n\n\nPhilip Gladstone\n\n\nPhilip Gladstone\n\n\nrotary.c\n\n\n\n\n\n\n\n\nThis module can read the state of cheap rotary encoder switches. These are available at all the standard places for a dollar or two. They are five pin devices where three are used for a gray code encoder for rotation, and two are used for the push switch. These switches are commonly used in car audio systems. \n\n\nThese switches do not have absolute positioning, but only encode the number of positions rotated clockwise / anti-clockwise. To make use of this module, connect the common pin on the quadrature encoder to ground and the A and B phases to the NodeMCU. One pin of the push switch should also be grounded and the other pin connected to the NodeMCU.\n\n\nSources for parts\n\n\n\n\nAmazon: This \nsearch\n shows a variety.\n\n\nEbay: Somewhat cheaper in this \nsearch\n\n\nAdafruit: \nrotary encoder\n\n\nAliexpress: This \nsearch\n reveals all sorts of shapes and sizes.\n\n\n\n\nThere is also a switch mounted on a board with standard 0.1\" pins. \nThis is the KY-040, and can also be found at \nlots of places\n. \nNote that the pins are named somewhat eccentrically, and I suspect that it really does need the VCC connected.\n\n\nConstants\n\n\n\n\nrotary.PRESS = 1\n The eventtype for the switch press.\n\n\nrotary.LONGPRESS = 2\n The eventtype for a long press.\n\n\nrotary.RELEASE = 4\n The eventtype for the switch release.\n\n\nrotary.TURN = 8\n The eventtype for the switch rotation.\n\n\nrotary.CLICK = 16\n The eventtype for a single click (after release)\n\n\nrotary.DBLCLICK = 32\n The eventtype for a double click (after second release)\n\n\nrotary.ALL = 63\n All event types.\n\n\n\n\nrotary.setup()\n\n\nInitialize the nodemcu to talk to a rotary encoder switch.\n\n\nSyntax\n\n\nrotary.setup(channel, pina, pinb[, pinpress[, longpress_time_ms[, dblclick_time_ms]]])\n\n\nParameters\n\n\n\n\nchannel\n The rotary module supports three switches. The channel is either 0, 1 or 2.\n\n\npina\n This is a GPIO number (excluding 0) and connects to pin phase A on the rotary switch.\n\n\npinb\n This is a GPIO number (excluding 0) and connects to pin phase B on the rotary switch.\n\n\npinpress\n (optional) This is a GPIO number (excluding 0) and connects to the press switch.\n\n\nlongpress_time_ms\n (optional) The number of milliseconds (default 500) of press to be considered a long press.\n\n\ndblclick_time_ms\n (optional) The number of milliseconds (default 500) between a release and a press for the next release to be considered a double click.\n\n\n\n\nReturns\n\n\nNothing. If the arguments are in error, or the operation cannot be completed, then an error is thrown.\n\n\nFor all API calls, if the channel number is out of range, then an error will be thrown.\n\n\nExample\n\n\nrotary.setup(0, 5,6, 7)\n\n\n\nrotary.on()\n\n\nSets a callback on specific events.\n\n\nSyntax\n\n\nrotary.on(channel, eventtype[, callback])\n\n\nParameters\n\n\n\n\nchannel\n The rotary module supports three switches. The channel is either 0, 1 or 2.\n\n\neventtype\n This defines the type of event being registered. This is the logical or of one or more of \nPRESS\n, \nLONGPRESS\n, \nRELEASE\n, \nTURN\n, \nCLICK\n or \nDBLCLICK\n.\n\n\ncallback\n This is a function that will be invoked when the specified event happens. \n\n\n\n\nIf the callback is None or omitted, then the registration is cancelled.\n\n\nThe callback will be invoked with three arguments when the event happens. The first argument is the eventtype, \nthe second is the current position of the rotary switch, and the third is the time when the event happened. \n\n\nThe position is tracked\nand is represented as a signed 32-bit integer. Increasing values indicate clockwise motion. The time is the number of microseconds represented\nin a 32-bit integer. Note that this wraps every hour or so.\n\n\nExample\n\n\nrotary.on(0, rotary.ALL, function (type, pos, when) \n  print \"Position=\" .. pos .. \" event type=\" .. type .. \" time=\" .. when\nend)\n\n\n\nNotes\n\n\nEvents will be delivered in order, but there may be missing TURN events. If there is a long \nqueue of events, then PRESS and RELEASE events may also be missed. Multiple pending TURN events \nare typically dispatched as one TURN callback with the final position as its parameter.\n\n\nSome switches have 4 steps per detent. This means that, in practice, the application\nshould divide the position by 4 and use that to determine the number of clicks. It is\nunlikely that a switch will ever reach 30 bits of rotation in either direction -- some\nare rated for under 50,000 revolutions.\n\n\nThe \nCLICK\n and \nLONGPRESS\n events are delivered on a timeout. The \nDBLCLICK\n event is delivered after a \nPRESS\n, \nRELEASE\n, \nPRESS\n, \nRELEASE\n sequence\nwhere this is a short time gap between the middle \nRELEASE\n and \nPRESS\n.\n\n\nErrors\n\n\nIf an invalid \neventtype\n is supplied, then an error will be thrown.\n\n\nrotary.getpos()\n\n\nGets the current position and press status of the switch\n\n\nSyntax\n\n\npos, press, queue = rotary.getpos(channel)\n\n\nParameters\n\n\n\n\nchannel\n The rotary module supports three switches. The channel is either 0, 1 or 2.\n\n\n\n\nReturns\n\n\n\n\npos\n The current position of the switch.\n\n\npress\n A boolean indicating if the switch is currently pressed.\n\n\nqueue\n The number of undelivered callbacks (normally 0).\n\n\n\n\nExample\n\n\nprint rotary.getpos(0)\n\n\n\nrotary.close()\n\n\nReleases the resources associated with the rotary switch.\n\n\nSyntax\n\n\nrotary.close(channel)\n\n\nParameters\n\n\n\n\nchannel\n The rotary module supports three switches. The channel is either 0, 1 or 2.\n\n\n\n\nExample\n\n\nrotary.close(0)", 
            "title": "rotary"
        }, 
        {
            "location": "/en/modules/rotary/#rotary-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-03-01  Philip Gladstone  Philip Gladstone  rotary.c     This module can read the state of cheap rotary encoder switches. These are available at all the standard places for a dollar or two. They are five pin devices where three are used for a gray code encoder for rotation, and two are used for the push switch. These switches are commonly used in car audio systems.   These switches do not have absolute positioning, but only encode the number of positions rotated clockwise / anti-clockwise. To make use of this module, connect the common pin on the quadrature encoder to ground and the A and B phases to the NodeMCU. One pin of the push switch should also be grounded and the other pin connected to the NodeMCU.", 
            "title": "rotary Module"
        }, 
        {
            "location": "/en/modules/rotary/#sources-for-parts", 
            "text": "Amazon: This  search  shows a variety.  Ebay: Somewhat cheaper in this  search  Adafruit:  rotary encoder  Aliexpress: This  search  reveals all sorts of shapes and sizes.   There is also a switch mounted on a board with standard 0.1\" pins. \nThis is the KY-040, and can also be found at  lots of places . \nNote that the pins are named somewhat eccentrically, and I suspect that it really does need the VCC connected.", 
            "title": "Sources for parts"
        }, 
        {
            "location": "/en/modules/rotary/#constants", 
            "text": "rotary.PRESS = 1  The eventtype for the switch press.  rotary.LONGPRESS = 2  The eventtype for a long press.  rotary.RELEASE = 4  The eventtype for the switch release.  rotary.TURN = 8  The eventtype for the switch rotation.  rotary.CLICK = 16  The eventtype for a single click (after release)  rotary.DBLCLICK = 32  The eventtype for a double click (after second release)  rotary.ALL = 63  All event types.", 
            "title": "Constants"
        }, 
        {
            "location": "/en/modules/rotary/#rotarysetup", 
            "text": "Initialize the nodemcu to talk to a rotary encoder switch.", 
            "title": "rotary.setup()"
        }, 
        {
            "location": "/en/modules/rotary/#syntax", 
            "text": "rotary.setup(channel, pina, pinb[, pinpress[, longpress_time_ms[, dblclick_time_ms]]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rotary/#parameters", 
            "text": "channel  The rotary module supports three switches. The channel is either 0, 1 or 2.  pina  This is a GPIO number (excluding 0) and connects to pin phase A on the rotary switch.  pinb  This is a GPIO number (excluding 0) and connects to pin phase B on the rotary switch.  pinpress  (optional) This is a GPIO number (excluding 0) and connects to the press switch.  longpress_time_ms  (optional) The number of milliseconds (default 500) of press to be considered a long press.  dblclick_time_ms  (optional) The number of milliseconds (default 500) between a release and a press for the next release to be considered a double click.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rotary/#returns", 
            "text": "Nothing. If the arguments are in error, or the operation cannot be completed, then an error is thrown.  For all API calls, if the channel number is out of range, then an error will be thrown.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rotary/#example", 
            "text": "rotary.setup(0, 5,6, 7)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rotary/#rotaryon", 
            "text": "Sets a callback on specific events.", 
            "title": "rotary.on()"
        }, 
        {
            "location": "/en/modules/rotary/#syntax_1", 
            "text": "rotary.on(channel, eventtype[, callback])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rotary/#parameters_1", 
            "text": "channel  The rotary module supports three switches. The channel is either 0, 1 or 2.  eventtype  This defines the type of event being registered. This is the logical or of one or more of  PRESS ,  LONGPRESS ,  RELEASE ,  TURN ,  CLICK  or  DBLCLICK .  callback  This is a function that will be invoked when the specified event happens.    If the callback is None or omitted, then the registration is cancelled.  The callback will be invoked with three arguments when the event happens. The first argument is the eventtype, \nthe second is the current position of the rotary switch, and the third is the time when the event happened.   The position is tracked\nand is represented as a signed 32-bit integer. Increasing values indicate clockwise motion. The time is the number of microseconds represented\nin a 32-bit integer. Note that this wraps every hour or so.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rotary/#example_1", 
            "text": "rotary.on(0, rotary.ALL, function (type, pos, when) \n  print \"Position=\" .. pos .. \" event type=\" .. type .. \" time=\" .. when\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rotary/#notes", 
            "text": "Events will be delivered in order, but there may be missing TURN events. If there is a long \nqueue of events, then PRESS and RELEASE events may also be missed. Multiple pending TURN events \nare typically dispatched as one TURN callback with the final position as its parameter.  Some switches have 4 steps per detent. This means that, in practice, the application\nshould divide the position by 4 and use that to determine the number of clicks. It is\nunlikely that a switch will ever reach 30 bits of rotation in either direction -- some\nare rated for under 50,000 revolutions.  The  CLICK  and  LONGPRESS  events are delivered on a timeout. The  DBLCLICK  event is delivered after a  PRESS ,  RELEASE ,  PRESS ,  RELEASE  sequence\nwhere this is a short time gap between the middle  RELEASE  and  PRESS .", 
            "title": "Notes"
        }, 
        {
            "location": "/en/modules/rotary/#errors", 
            "text": "If an invalid  eventtype  is supplied, then an error will be thrown.", 
            "title": "Errors"
        }, 
        {
            "location": "/en/modules/rotary/#rotarygetpos", 
            "text": "Gets the current position and press status of the switch", 
            "title": "rotary.getpos()"
        }, 
        {
            "location": "/en/modules/rotary/#syntax_2", 
            "text": "pos, press, queue = rotary.getpos(channel)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rotary/#parameters_2", 
            "text": "channel  The rotary module supports three switches. The channel is either 0, 1 or 2.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rotary/#returns_1", 
            "text": "pos  The current position of the switch.  press  A boolean indicating if the switch is currently pressed.  queue  The number of undelivered callbacks (normally 0).", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rotary/#example_2", 
            "text": "print rotary.getpos(0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rotary/#rotaryclose", 
            "text": "Releases the resources associated with the rotary switch.", 
            "title": "rotary.close()"
        }, 
        {
            "location": "/en/modules/rotary/#syntax_3", 
            "text": "rotary.close(channel)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rotary/#parameters_3", 
            "text": "channel  The rotary module supports three switches. The channel is either 0, 1 or 2.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rotary/#example_3", 
            "text": "rotary.close(0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtcfifo/", 
            "text": "RTC FIFO Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-06-26\n\n\nDiUS\n, \nJohny Mattsson\n, Bernd Meyer \n\n\nJohny Mattsson\n\n\nrtcfifo.c\n\n\n\n\n\n\n\n\nThe rtcfifo module implements a first-in,first-out storage intended for sensor readings. As the name suggests, it is backed by the \nRTC\n user memory and as such survives deep sleep cycles. Conceptually it can be thought of as a cyclic array of \n{ timestamp, name, value }\n tuples. Internally it uses a space-optimized storage format to allow the greatest number of samples to be kept. This comes with several trade-offs, and as such is not a one-solution-fits-all. Notably:\n\n\n\n\nTimestamps are stored with second-precision.\n\n\nSample frequency must be at least once every 8.5 minutes. This is a side-effect of delta-compression being used for the time stamps.\n\n\nValues are limited to 16 bits of precision, but have a separate field for storing an E\n-n\n multiplier. This allows for high fidelity even when working with very small values. The effective range is thus 1E\n-7\n to 65535.\n\n\nSensor names are limited to a maximum of 4 characters.\n\n\n\n\n\n\nImportant\n\n\nThis module uses two sets of RTC memory slots, 10-20 for its control block, and a variable number of slots for samples and sensor names. By default these span 32-127, but this is configurable. Slots are claimed when \nrtcfifo.prepare()\n is called.\n\n\n\n\nThis is a companion module to the \nrtcmem\n and \nrtctime\n modules.\n\n\nrtcfifo.dsleep_until_sample()\n\n\nWhen the rtcfifo module is compiled in together with the rtctime module, this convenience function is available. It allows for some measure of separation of concerns, enabling writing of modularized Lua code where a sensor reading abstraction may not need to be aware of the sample frequency (which is largely a policy decision, rather than an intrinsic of the sensor). Use of this function is effectively equivalent to \nrtctime.dsleep_aligned(interval_us, minsleep_us)\n where \ninterval_us\n is what was given to \nrtcfifo.prepare()\n.\n\n\nSyntax\n\n\nrtcfifo.dsleep_until_sample(minsleep_us)\n\n\nParameter\n\n\nminsleep_us\n minimum sleep time, in microseconds\n\n\nExample\n\n\n-- deep sleep until it's time to take the next sample\nrtcfifo.dsleep_until_sample(0)\n\n\n\n\nSee also\n\n\nrtctime.dsleep_aligned()\n\n\nrtcfifo.peek()\n\n\nReads a sample from the rtcfifo. An offset into the rtcfifo may be specified, but by default it reads the first sample (offset 0).\n\n\nSyntax:\n\n\nrtcfifo.peek([offset])\n\n\nParameters\n\n\noffset\n Peek at sample at position \noffset\n in the fifo. This is a relative offset, from the current head. Zero-based. Default value is 0.\n\n\nReturns\n\n\nThe values returned match the input arguments used to \nrtcfifo.put()\n.\n\n\n\n\ntimestamp\n timestamp in seconds\n\n\nvalue\n the value\n\n\nneg_e\n scaling factor\n\n\nname\n sensor name\n\n\n\n\nIf no sample is available (at the specified offset), nothing is returned.\n\n\nExample\n\n\nlocal timestamp, value, neg_e, name = rtcfifo.peek()\n\n\n\n\nrtcfifo.pop()\n\n\nReads the first sample from the rtcfifo, and removes it from there.\n\n\nSyntax:\n\n\nrtcfifo.pop()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nThe values returned match the input arguments used to \nrtcfifo.put()\n.\n\n\n\n\ntimestamp\n timestamp in seconds\n\n\nvalue\n the value\n\n\nneg_e\n scaling factor\n\n\nname\n sensor name\n\n\n\n\nExample\n\n\nwhile rtcfifo.count() \n 0 do\n  local timestamp, value, neg_e, name = rtcfifo.pop()\n  -- do something with the sample, e.g. upload to somewhere\nend\n\n\n\n\nrtcfifo.prepare()\n\n\nInitializes the rtcfifo module for use.\n\n\nCalling \nrtcfifo.prepare()\n unconditionally re-initializes the storage - any samples stored are discarded.\n\n\nSyntax\n\n\nrtcfifo.prepare([table])\n\n\nParameters\n\n\nThis function takes an optional configuration table as an argument. The following items may be configured:\n\n\n\n\ninterval_us\n If wanting to make use of the \nrtcfifo.sleep_until_sample()\n function, this field sets the sample interval (in microseconds) to use. It is effectively the first argument of \nrtctime.dsleep_aligned()\n.\n\n\nsensor_count\n Specifies the number of different sensors to allocate name space for. This directly corresponds to a number of slots reserved for names in the variable block. The default value is 5, minimum is 1, and maximum is 16.\n\n\nstorage_begin\n Specifies the first RTC user memory slot to use for the variable block. Default is 32. Only takes effect if \nstorage_end\n is also specified.\n\n\nstorage_end\n Specified the end of the RTC user memory slots. This slot number will \nnot\n be touched. Default is 128. Only takes effect if \nstorage_begin\n is also specified.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- Initialize with default values\nrtcfifo.prepare()\n-- Use RTC slots 19 and up for variable storage\nrtcfifo.prepare({storage_begin=21, storage_end=128})\n\n\n\n\nSee also\n\n\n\n\nrtcfifo.ready()\n\n\nrtcfifo.prepare()\n\n\n\n\nrtcfifo.put()\n\n\nPuts a sample into the rtcfifo.\n\n\nIf the rtcfifo has not been prepared, this function does nothing.\n\n\nSyntax\n\n\nrtcfifo.put(timestamp, value, neg_e, name)\n\n\nParameters\n\n\n\n\ntimestamp\n Timestamp in seconds. The timestamp would typically come from \nrtctime.get()\n.\n\n\nvalue\n The value to store.\n\n\nneg_e\n The effective value stored is valueE\nneg_e\n.\n\n\nname\n Name of the sensor.  Only the first four (ASCII) characters of \nname\n are used.\n\n\n\n\nNote that if the timestamp delta is too large compared to the previous sample stored, the rtcfifo evicts all earlier samples to store this one. Likewise, if \nname\n would mean there are more than the \nsensor_count\n (as specified to \nrtcfifo.prepare()\n) names in use, the rtcfifo evicts all earlier samples.\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- Obtain a sample value from somewhere\nlocal sample = ... \n-- Store sample with no scaling, under the name \nfoo\n\nrtcfifo.put(rtctime.get(), sample, 0, \nfoo\n)\n\n\n\n\nrtcfifo.ready()\n\n\nReturns non-zero if the rtcfifo has been prepared and is ready for use, zero if not.\n\n\nSyntax:\n\n\nrtcfifo.ready()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nNon-zero if the rtcfifo has been prepared and is ready for use, zero if not.\n\n\nExample\n\n\n-- Prepare the rtcfifo if not already done\nif not rtcfifo.ready() then\n  rtcfifo.prepare()\nend", 
            "title": "rtcfifo"
        }, 
        {
            "location": "/en/modules/rtcfifo/#rtc-fifo-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-06-26  DiUS ,  Johny Mattsson , Bernd Meyer   Johny Mattsson  rtcfifo.c     The rtcfifo module implements a first-in,first-out storage intended for sensor readings. As the name suggests, it is backed by the  RTC  user memory and as such survives deep sleep cycles. Conceptually it can be thought of as a cyclic array of  { timestamp, name, value }  tuples. Internally it uses a space-optimized storage format to allow the greatest number of samples to be kept. This comes with several trade-offs, and as such is not a one-solution-fits-all. Notably:   Timestamps are stored with second-precision.  Sample frequency must be at least once every 8.5 minutes. This is a side-effect of delta-compression being used for the time stamps.  Values are limited to 16 bits of precision, but have a separate field for storing an E -n  multiplier. This allows for high fidelity even when working with very small values. The effective range is thus 1E -7  to 65535.  Sensor names are limited to a maximum of 4 characters.    Important  This module uses two sets of RTC memory slots, 10-20 for its control block, and a variable number of slots for samples and sensor names. By default these span 32-127, but this is configurable. Slots are claimed when  rtcfifo.prepare()  is called.   This is a companion module to the  rtcmem  and  rtctime  modules.", 
            "title": "RTC FIFO Module"
        }, 
        {
            "location": "/en/modules/rtcfifo/#rtcfifodsleep_until_sample", 
            "text": "When the rtcfifo module is compiled in together with the rtctime module, this convenience function is available. It allows for some measure of separation of concerns, enabling writing of modularized Lua code where a sensor reading abstraction may not need to be aware of the sample frequency (which is largely a policy decision, rather than an intrinsic of the sensor). Use of this function is effectively equivalent to  rtctime.dsleep_aligned(interval_us, minsleep_us)  where  interval_us  is what was given to  rtcfifo.prepare() .", 
            "title": "rtcfifo.dsleep_until_sample()"
        }, 
        {
            "location": "/en/modules/rtcfifo/#syntax", 
            "text": "rtcfifo.dsleep_until_sample(minsleep_us)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtcfifo/#parameter", 
            "text": "minsleep_us  minimum sleep time, in microseconds", 
            "title": "Parameter"
        }, 
        {
            "location": "/en/modules/rtcfifo/#example", 
            "text": "-- deep sleep until it's time to take the next sample\nrtcfifo.dsleep_until_sample(0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtcfifo/#see-also", 
            "text": "rtctime.dsleep_aligned()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/rtcfifo/#rtcfifopeek", 
            "text": "Reads a sample from the rtcfifo. An offset into the rtcfifo may be specified, but by default it reads the first sample (offset 0).", 
            "title": "rtcfifo.peek()"
        }, 
        {
            "location": "/en/modules/rtcfifo/#syntax_1", 
            "text": "rtcfifo.peek([offset])", 
            "title": "Syntax:"
        }, 
        {
            "location": "/en/modules/rtcfifo/#parameters", 
            "text": "offset  Peek at sample at position  offset  in the fifo. This is a relative offset, from the current head. Zero-based. Default value is 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtcfifo/#returns", 
            "text": "The values returned match the input arguments used to  rtcfifo.put() .   timestamp  timestamp in seconds  value  the value  neg_e  scaling factor  name  sensor name   If no sample is available (at the specified offset), nothing is returned.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtcfifo/#example_1", 
            "text": "local timestamp, value, neg_e, name = rtcfifo.peek()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtcfifo/#rtcfifopop", 
            "text": "Reads the first sample from the rtcfifo, and removes it from there.", 
            "title": "rtcfifo.pop()"
        }, 
        {
            "location": "/en/modules/rtcfifo/#syntax_2", 
            "text": "rtcfifo.pop()", 
            "title": "Syntax:"
        }, 
        {
            "location": "/en/modules/rtcfifo/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtcfifo/#returns_1", 
            "text": "The values returned match the input arguments used to  rtcfifo.put() .   timestamp  timestamp in seconds  value  the value  neg_e  scaling factor  name  sensor name", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtcfifo/#example_2", 
            "text": "while rtcfifo.count()   0 do\n  local timestamp, value, neg_e, name = rtcfifo.pop()\n  -- do something with the sample, e.g. upload to somewhere\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtcfifo/#rtcfifoprepare", 
            "text": "Initializes the rtcfifo module for use.  Calling  rtcfifo.prepare()  unconditionally re-initializes the storage - any samples stored are discarded.", 
            "title": "rtcfifo.prepare()"
        }, 
        {
            "location": "/en/modules/rtcfifo/#syntax_3", 
            "text": "rtcfifo.prepare([table])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtcfifo/#parameters_2", 
            "text": "This function takes an optional configuration table as an argument. The following items may be configured:   interval_us  If wanting to make use of the  rtcfifo.sleep_until_sample()  function, this field sets the sample interval (in microseconds) to use. It is effectively the first argument of  rtctime.dsleep_aligned() .  sensor_count  Specifies the number of different sensors to allocate name space for. This directly corresponds to a number of slots reserved for names in the variable block. The default value is 5, minimum is 1, and maximum is 16.  storage_begin  Specifies the first RTC user memory slot to use for the variable block. Default is 32. Only takes effect if  storage_end  is also specified.  storage_end  Specified the end of the RTC user memory slots. This slot number will  not  be touched. Default is 128. Only takes effect if  storage_begin  is also specified.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtcfifo/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtcfifo/#example_3", 
            "text": "-- Initialize with default values\nrtcfifo.prepare()\n-- Use RTC slots 19 and up for variable storage\nrtcfifo.prepare({storage_begin=21, storage_end=128})", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtcfifo/#see-also_1", 
            "text": "rtcfifo.ready()  rtcfifo.prepare()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/rtcfifo/#rtcfifoput", 
            "text": "Puts a sample into the rtcfifo.  If the rtcfifo has not been prepared, this function does nothing.", 
            "title": "rtcfifo.put()"
        }, 
        {
            "location": "/en/modules/rtcfifo/#syntax_4", 
            "text": "rtcfifo.put(timestamp, value, neg_e, name)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtcfifo/#parameters_3", 
            "text": "timestamp  Timestamp in seconds. The timestamp would typically come from  rtctime.get() .  value  The value to store.  neg_e  The effective value stored is valueE neg_e .  name  Name of the sensor.  Only the first four (ASCII) characters of  name  are used.   Note that if the timestamp delta is too large compared to the previous sample stored, the rtcfifo evicts all earlier samples to store this one. Likewise, if  name  would mean there are more than the  sensor_count  (as specified to  rtcfifo.prepare() ) names in use, the rtcfifo evicts all earlier samples.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtcfifo/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtcfifo/#example_4", 
            "text": "-- Obtain a sample value from somewhere\nlocal sample = ... \n-- Store sample with no scaling, under the name  foo \nrtcfifo.put(rtctime.get(), sample, 0,  foo )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtcfifo/#rtcfifoready", 
            "text": "Returns non-zero if the rtcfifo has been prepared and is ready for use, zero if not.", 
            "title": "rtcfifo.ready()"
        }, 
        {
            "location": "/en/modules/rtcfifo/#syntax_5", 
            "text": "rtcfifo.ready()", 
            "title": "Syntax:"
        }, 
        {
            "location": "/en/modules/rtcfifo/#parameters_4", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtcfifo/#returns_4", 
            "text": "Non-zero if the rtcfifo has been prepared and is ready for use, zero if not.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtcfifo/#example_5", 
            "text": "-- Prepare the rtcfifo if not already done\nif not rtcfifo.ready() then\n  rtcfifo.prepare()\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtcmem/", 
            "text": "RTC User Memory Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-06-25\n\n\nDiUS\n, \nJohny Mattsson\n\n\nJohny Mattsson\n\n\nrtcmem.c\n\n\n\n\n\n\n\n\nThe rtcmem module provides basic access to the \nRTC\n (Real Time Clock) memory.\n\n\nThe RTC in the ESP8266 contains memory registers which survive a deep sleep, making them highly useful for keeping state across sleep cycles. Some of this memory is reserved for system use, but 128 slots (each 32bit wide) are available for application use. This module provides read and write access to these.\n\n\nDue to the very limited amount of memory available, there is no mechanism for arbitrating use of particular slots. It is up to the end user to be aware of which memory is used for what, and avoid conflicts. Note that some Lua modules lay claim to certain slots.\n\n\nThis is a companion module to the \nrtctime\n and \nrtcfifo\n modules.\n\n\nrtcmem.read32()\n\n\nReads one or more 32bit values from RTC user memory.\n\n\nSyntax\n\n\nrtcmem.read32(idx [, num])\n\n\nParameters\n\n\n\n\nidx\n zero-based index to start reading from\n\n\nnum\n number of slots to read (default 1)\n\n\n\n\nReturns\n\n\nThe value(s) read from RTC user memory.\n\n\nIf \nidx\n is outside the valid range [0,127] this function returns nothing.\n\n\nIf \nnum\n results in overstepping the end of available memory, the function only returns the data from the valid slots.\n\n\nExample\n\n\nval = rtcmem.read32(0) -- Read the value in slot 0\nval1, val2 = rtcmem.read32(42, 2) -- Read the values in slots 42 and 43\n\n\n\n\nSee also\n\n\nrtcmem.write32()\n\n\nrtcmem.write32()\n\n\nWrites one or more values to RTC user memory, starting at index \nidx\n.\n\n\nWriting to indices outside the valid range [0,127] has no effect.\n\n\nSyntax\n\n\nrtcmem.write32(idx, val [, val2, ...])\n\n\nParameters\n\n\n\n\nidx\n zero-based index to start writing to. Auto-increments if multiple values are given.\n\n\nval\n value to store (32bit)\n\n\nval2...\n additional values to store (optional)\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nrtcmem.write32(0, 53) -- Store the value 53 in slot 0\nrtcmem.write32(42, 2, 5, 7) -- Store the values 2, 5 and 7 into slots 42, 43 and 44, respectively.\n\n\n\n\nSee also\n\n\nrtcmem.read32()", 
            "title": "rtcmem"
        }, 
        {
            "location": "/en/modules/rtcmem/#rtc-user-memory-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-06-25  DiUS ,  Johny Mattsson  Johny Mattsson  rtcmem.c     The rtcmem module provides basic access to the  RTC  (Real Time Clock) memory.  The RTC in the ESP8266 contains memory registers which survive a deep sleep, making them highly useful for keeping state across sleep cycles. Some of this memory is reserved for system use, but 128 slots (each 32bit wide) are available for application use. This module provides read and write access to these.  Due to the very limited amount of memory available, there is no mechanism for arbitrating use of particular slots. It is up to the end user to be aware of which memory is used for what, and avoid conflicts. Note that some Lua modules lay claim to certain slots.  This is a companion module to the  rtctime  and  rtcfifo  modules.", 
            "title": "RTC User Memory Module"
        }, 
        {
            "location": "/en/modules/rtcmem/#rtcmemread32", 
            "text": "Reads one or more 32bit values from RTC user memory.", 
            "title": "rtcmem.read32()"
        }, 
        {
            "location": "/en/modules/rtcmem/#syntax", 
            "text": "rtcmem.read32(idx [, num])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtcmem/#parameters", 
            "text": "idx  zero-based index to start reading from  num  number of slots to read (default 1)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtcmem/#returns", 
            "text": "The value(s) read from RTC user memory.  If  idx  is outside the valid range [0,127] this function returns nothing.  If  num  results in overstepping the end of available memory, the function only returns the data from the valid slots.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtcmem/#example", 
            "text": "val = rtcmem.read32(0) -- Read the value in slot 0\nval1, val2 = rtcmem.read32(42, 2) -- Read the values in slots 42 and 43", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtcmem/#see-also", 
            "text": "rtcmem.write32()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/rtcmem/#rtcmemwrite32", 
            "text": "Writes one or more values to RTC user memory, starting at index  idx .  Writing to indices outside the valid range [0,127] has no effect.", 
            "title": "rtcmem.write32()"
        }, 
        {
            "location": "/en/modules/rtcmem/#syntax_1", 
            "text": "rtcmem.write32(idx, val [, val2, ...])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtcmem/#parameters_1", 
            "text": "idx  zero-based index to start writing to. Auto-increments if multiple values are given.  val  value to store (32bit)  val2...  additional values to store (optional)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtcmem/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtcmem/#example_1", 
            "text": "rtcmem.write32(0, 53) -- Store the value 53 in slot 0\nrtcmem.write32(42, 2, 5, 7) -- Store the values 2, 5 and 7 into slots 42, 43 and 44, respectively.", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtcmem/#see-also_1", 
            "text": "rtcmem.read32()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/rtctime/", 
            "text": "RTC Time Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-06-25\n\n\nDiUS\n, \nJohny Mattsson\n, Bernd Meyer \n\n\nJohny Mattsson\n\n\nrtctime.c\n\n\n\n\n\n\n\n\nThe rtctime module provides advanced timekeeping support for NodeMCU, including keeping time across deep sleep cycles (provided \nrtctime.dsleep()\n is used instead of \nnode.dsleep()\n). This can be used to significantly extend battery life on battery powered sensor nodes, as it is no longer necessary to fire up the RF module each wake-up in order to obtain an accurate timestamp.\n\n\nThis module is intended for use together with \nNTP\n (Network Time Protocol) for keeping highly accurate real time at all times. Timestamps are available with microsecond precision, based on the Unix Epoch (1970/01/01 00:00:00). However, the accuracy is (in practice) no better then 1ms, and often worse than that. \n\n\nTime keeping on the ESP8266 is technically quite challenging. Despite being named \nRTC\n, the RTC is not really a Real Time Clock in the normal sense of the word. While it does keep a counter ticking while the module is sleeping, the accuracy with which it does so is \nhighly\n dependent on the temperature of the chip. Said temperature changes significantly between when the chip is running and when it is sleeping, meaning that any calibration performed while the chip is active becomes useless mere moments after the chip has gone to sleep. As such, calibration values need to be deduced across sleep cycles in order to enable accurate time keeping. This is one of the things this module does.\n\n\nFurther complicating the matter of time keeping is that the ESP8266 operates on three different clock frequencies - 52MHz right at boot, 80MHz during regular operation, and 160MHz if boosted. This module goes to considerable length to take all of this into account to properly keep the time.\n\n\nTo enable this module, it needs to be given a reference time at least once (via \nrtctime.set()\n). For best accuracy it is recommended to provide reference\ntimes at regular intervals. The \nsntp.sync()\n function has an easy way to do this. It is important that a reference time is provided at least twice, with the second time being after a deep sleep.\n\n\nNote that while the rtctime module can keep time across deep sleeps, it \nwill\n lose the time if the module is unexpectedly reset.\n\n\nThis module can compensate for the underlying clock not running at exactly the required rate. The adjustment is in steps of 1 part in 2^32 (i.e. around 0.25 ppb). This adjustment\nis done automatically if the \nsntp.sync()\n is called with the \nautorepeat\n flag set. The rate is settable using the \nset()\n function below. When the platform\nis booted, it defaults to 0 (i.e. nominal). A sample of modules shows that the actual clock rate is temperature dependant, but is normally within 5ppm of the nominal rate. This translates to around 15 seconds per month. \n\n\nIn the automatic update mode it can take a couple of hours for the clock rate to settle down to the correct value. After that, how well it tracks will depend on the amount\nof variation in timestamps from the NTP servers. If they are close, then the time will track to within a millisecond or so. If they are further away (say 100ms round trip), then\ntime tracking is somewhat worse, but normally within 10ms. \n\n\n\n\nImportant\n\n\n\n\nThis module uses RTC memory slots 0-9, inclusive. As soon as \nrtctime.set()\n (or \nsntp.sync()\n) has been called these RTC memory slots will be used.\n\n\nThis is a companion module to the \nrtcmem\n and \nSNTP\n modules.\n\n\nrtctime.dsleep()\n\n\nPuts the ESP8266 into deep sleep mode, like \nnode.dsleep()\n. It differs from \nnode.dsleep()\n in the following ways:\n\n\n\n\nTime is kept across the deep sleep. I.e. \nrtctime.get()\n will keep working (provided time was available before the sleep).\n\n\nThis call never returns. The module is put to sleep immediately. This is both to support accurate time keeping and to reduce power consumption.\n\n\nThe time slept will generally be considerably more accurate than with \nnode.dsleep()\n.\n\n\nA sleep time of zero does not mean indefinite sleep, it is interpreted as a zero length sleep instead.\n\n\n\n\nWhen the sleep timer expires, the platform is rebooted and the lua code is started with the \ninit.lua\n file. The clock is set reasonably accurately.\n\n\nSyntax\n\n\nrtctime.dsleep(microseconds [, option])\n\n\nParameters\n\n\n\n\nmicroseconds\n number of microseconds to sleep for. Maxmium value is 4294967295us, or ~71 minutes.\n\n\noption\n sleep option, see \nnode.dsleep()\n for specifics.\n\n\n\n\nReturns\n\n\nThis function does not return.\n\n\nExample\n\n\n-- sleep for a minute\nrtctime.dsleep(60*1000000)\n\n\n\n\n-- sleep for 5 seconds, do not start RF on wakeup\nrtctime.dsleep(5000000, 4)\n\n\n\n\nrtctime.dsleep_aligned()\n\n\nFor applications where it is necessary to take samples with high regularity, this function is useful. It provides an easy way to implement a \"wake up on the next 5-minute boundary\" scheme, without having to explicitly take into account how long the module has been active for etc before going back to sleep.\n\n\nSyntax\n\n\nrtctime.dsleep_aligned(aligned_us, minsleep_us [, option])\n\n\nParameters\n\n\n\n\naligned_us\n boundary interval in microseconds\n\n\nminsleep_us\n minimum time that will be slept, if necessary skipping an interval. This is intended for sensors where a sample reading is started before putting the ESP8266 to sleep, and then fetched upon wake-up. Here \nminsleep_us\n should be the minimum time required for the sensor to take the sample.\n\n\noption\n as with \ndsleep()\n, the \noption\n sets the sleep option, if specified.\n\n\n\n\nExample\n\n\n-- sleep at least 3 seconds, then wake up on the next 5-second boundary\nrtctime.dsleep_aligned(5*1000000, 3*1000000)\n\n\n\n\nrtctime.epoch2cal()\n\n\nConverts a Unix timestamp to calendar format. Neither timezone nor DST correction is performed - the result is UTC time.\n\n\nSyntax\n\n\nrtctime.epoch2cal(timestamp)\n\n\nParameters\n\n\ntimestamp\n seconds since Unix epoch\n\n\nReturns\n\n\nA table containing the fields:\n\n\n\n\nyear\n 1970 ~ 2038\n\n\nmon\n month 1 ~ 12 in current year\n\n\nday\n day 1 ~ 31 in current month\n\n\nhour\n\n\nmin\n\n\nsec\n\n\nyday\n day 1 ~ 366 in current year\n\n\nwday\n day 1 ~ 7 in current weak (Sunday is 1)\n\n\n\n\nExample\n\n\ntm = rtctime.epoch2cal(rtctime.get())\nprint(string.format(\n%04d/%02d/%02d %02d:%02d:%02d\n, tm[\nyear\n], tm[\nmon\n], tm[\nday\n], tm[\nhour\n], tm[\nmin\n], tm[\nsec\n]))\n\n\n\n\nrtctime.get()\n\n\nReturns the current time. If current time is not available, zero is returned.\n\n\nSyntax\n\n\nrtctime.get()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nA three-value timestamp containing:\n\n\n\n\nsec\n seconds since the Unix epoch\n\n\nusec\n the microseconds part\n\n\nrate\n the current clock rate offset. This is an offset of \nrate / 2^32\n (where the nominal rate is 1). For example, a value of 4295 corresponds to 1 part per million.\n\n\n\n\nExample\n\n\nsec, usec, rate = rtctime.get()\n\n\n\n\nSee also\n\n\nrtctime.set()\n\n\nrtctime.set()\n\n\nSets the rtctime to a given timestamp in the Unix epoch (i.e. seconds from midnight 1970/01/01). If the module is not already keeping time, it starts now. If the module was already keeping time, it uses this time to help adjust its internal calibration values. Care is taken that timestamps returned from \nrtctime.get()\n \nnever go backwards\n. If necessary, time is slewed and gradually allowed to catch up.\n\n\nIt is highly recommended that the timestamp is obtained via NTP (see \nSNTP module\n), GPS, or other highly accurate time source.\n\n\nValues very close to the epoch are not supported. This is a side effect of keeping the memory requirements as low as possible. Considering that it's no longer 1970, this is not considered a problem.\n\n\nSyntax\n\n\nrtctime.set(seconds, microseconds, [rate])\n\n\nParameters\n\n\n\n\nseconds\n the seconds part, counted from the Unix epoch\n\n\nmicroseconds\n the microseconds part\n\n\nrate\n the rate in the same units as for \nrtctime.get()\n. The stored rate is not modified if not specified.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- Set time to 2015 July 9, 18:29:49\nrtctime.set(1436430589, 0)\n\n\n\n\nSee also\n\n\nsntp.sync()", 
            "title": "rtctime"
        }, 
        {
            "location": "/en/modules/rtctime/#rtc-time-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-06-25  DiUS ,  Johny Mattsson , Bernd Meyer   Johny Mattsson  rtctime.c     The rtctime module provides advanced timekeeping support for NodeMCU, including keeping time across deep sleep cycles (provided  rtctime.dsleep()  is used instead of  node.dsleep() ). This can be used to significantly extend battery life on battery powered sensor nodes, as it is no longer necessary to fire up the RF module each wake-up in order to obtain an accurate timestamp.  This module is intended for use together with  NTP  (Network Time Protocol) for keeping highly accurate real time at all times. Timestamps are available with microsecond precision, based on the Unix Epoch (1970/01/01 00:00:00). However, the accuracy is (in practice) no better then 1ms, and often worse than that.   Time keeping on the ESP8266 is technically quite challenging. Despite being named  RTC , the RTC is not really a Real Time Clock in the normal sense of the word. While it does keep a counter ticking while the module is sleeping, the accuracy with which it does so is  highly  dependent on the temperature of the chip. Said temperature changes significantly between when the chip is running and when it is sleeping, meaning that any calibration performed while the chip is active becomes useless mere moments after the chip has gone to sleep. As such, calibration values need to be deduced across sleep cycles in order to enable accurate time keeping. This is one of the things this module does.  Further complicating the matter of time keeping is that the ESP8266 operates on three different clock frequencies - 52MHz right at boot, 80MHz during regular operation, and 160MHz if boosted. This module goes to considerable length to take all of this into account to properly keep the time.  To enable this module, it needs to be given a reference time at least once (via  rtctime.set() ). For best accuracy it is recommended to provide reference\ntimes at regular intervals. The  sntp.sync()  function has an easy way to do this. It is important that a reference time is provided at least twice, with the second time being after a deep sleep.  Note that while the rtctime module can keep time across deep sleeps, it  will  lose the time if the module is unexpectedly reset.  This module can compensate for the underlying clock not running at exactly the required rate. The adjustment is in steps of 1 part in 2^32 (i.e. around 0.25 ppb). This adjustment\nis done automatically if the  sntp.sync()  is called with the  autorepeat  flag set. The rate is settable using the  set()  function below. When the platform\nis booted, it defaults to 0 (i.e. nominal). A sample of modules shows that the actual clock rate is temperature dependant, but is normally within 5ppm of the nominal rate. This translates to around 15 seconds per month.   In the automatic update mode it can take a couple of hours for the clock rate to settle down to the correct value. After that, how well it tracks will depend on the amount\nof variation in timestamps from the NTP servers. If they are close, then the time will track to within a millisecond or so. If they are further away (say 100ms round trip), then\ntime tracking is somewhat worse, but normally within 10ms.    Important   This module uses RTC memory slots 0-9, inclusive. As soon as  rtctime.set()  (or  sntp.sync() ) has been called these RTC memory slots will be used.  This is a companion module to the  rtcmem  and  SNTP  modules.", 
            "title": "RTC Time Module"
        }, 
        {
            "location": "/en/modules/rtctime/#rtctimedsleep", 
            "text": "Puts the ESP8266 into deep sleep mode, like  node.dsleep() . It differs from  node.dsleep()  in the following ways:   Time is kept across the deep sleep. I.e.  rtctime.get()  will keep working (provided time was available before the sleep).  This call never returns. The module is put to sleep immediately. This is both to support accurate time keeping and to reduce power consumption.  The time slept will generally be considerably more accurate than with  node.dsleep() .  A sleep time of zero does not mean indefinite sleep, it is interpreted as a zero length sleep instead.   When the sleep timer expires, the platform is rebooted and the lua code is started with the  init.lua  file. The clock is set reasonably accurately.", 
            "title": "rtctime.dsleep()"
        }, 
        {
            "location": "/en/modules/rtctime/#syntax", 
            "text": "rtctime.dsleep(microseconds [, option])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtctime/#parameters", 
            "text": "microseconds  number of microseconds to sleep for. Maxmium value is 4294967295us, or ~71 minutes.  option  sleep option, see  node.dsleep()  for specifics.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtctime/#returns", 
            "text": "This function does not return.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtctime/#example", 
            "text": "-- sleep for a minute\nrtctime.dsleep(60*1000000)  -- sleep for 5 seconds, do not start RF on wakeup\nrtctime.dsleep(5000000, 4)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtctime/#rtctimedsleep_aligned", 
            "text": "For applications where it is necessary to take samples with high regularity, this function is useful. It provides an easy way to implement a \"wake up on the next 5-minute boundary\" scheme, without having to explicitly take into account how long the module has been active for etc before going back to sleep.", 
            "title": "rtctime.dsleep_aligned()"
        }, 
        {
            "location": "/en/modules/rtctime/#syntax_1", 
            "text": "rtctime.dsleep_aligned(aligned_us, minsleep_us [, option])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtctime/#parameters_1", 
            "text": "aligned_us  boundary interval in microseconds  minsleep_us  minimum time that will be slept, if necessary skipping an interval. This is intended for sensors where a sample reading is started before putting the ESP8266 to sleep, and then fetched upon wake-up. Here  minsleep_us  should be the minimum time required for the sensor to take the sample.  option  as with  dsleep() , the  option  sets the sleep option, if specified.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtctime/#example_1", 
            "text": "-- sleep at least 3 seconds, then wake up on the next 5-second boundary\nrtctime.dsleep_aligned(5*1000000, 3*1000000)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtctime/#rtctimeepoch2cal", 
            "text": "Converts a Unix timestamp to calendar format. Neither timezone nor DST correction is performed - the result is UTC time.", 
            "title": "rtctime.epoch2cal()"
        }, 
        {
            "location": "/en/modules/rtctime/#syntax_2", 
            "text": "rtctime.epoch2cal(timestamp)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtctime/#parameters_2", 
            "text": "timestamp  seconds since Unix epoch", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtctime/#returns_1", 
            "text": "A table containing the fields:   year  1970 ~ 2038  mon  month 1 ~ 12 in current year  day  day 1 ~ 31 in current month  hour  min  sec  yday  day 1 ~ 366 in current year  wday  day 1 ~ 7 in current weak (Sunday is 1)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtctime/#example_2", 
            "text": "tm = rtctime.epoch2cal(rtctime.get())\nprint(string.format( %04d/%02d/%02d %02d:%02d:%02d , tm[ year ], tm[ mon ], tm[ day ], tm[ hour ], tm[ min ], tm[ sec ]))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtctime/#rtctimeget", 
            "text": "Returns the current time. If current time is not available, zero is returned.", 
            "title": "rtctime.get()"
        }, 
        {
            "location": "/en/modules/rtctime/#syntax_3", 
            "text": "rtctime.get()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtctime/#parameters_3", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtctime/#returns_2", 
            "text": "A three-value timestamp containing:   sec  seconds since the Unix epoch  usec  the microseconds part  rate  the current clock rate offset. This is an offset of  rate / 2^32  (where the nominal rate is 1). For example, a value of 4295 corresponds to 1 part per million.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtctime/#example_3", 
            "text": "sec, usec, rate = rtctime.get()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtctime/#see-also", 
            "text": "rtctime.set()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/rtctime/#rtctimeset", 
            "text": "Sets the rtctime to a given timestamp in the Unix epoch (i.e. seconds from midnight 1970/01/01). If the module is not already keeping time, it starts now. If the module was already keeping time, it uses this time to help adjust its internal calibration values. Care is taken that timestamps returned from  rtctime.get()   never go backwards . If necessary, time is slewed and gradually allowed to catch up.  It is highly recommended that the timestamp is obtained via NTP (see  SNTP module ), GPS, or other highly accurate time source.  Values very close to the epoch are not supported. This is a side effect of keeping the memory requirements as low as possible. Considering that it's no longer 1970, this is not considered a problem.", 
            "title": "rtctime.set()"
        }, 
        {
            "location": "/en/modules/rtctime/#syntax_4", 
            "text": "rtctime.set(seconds, microseconds, [rate])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/rtctime/#parameters_4", 
            "text": "seconds  the seconds part, counted from the Unix epoch  microseconds  the microseconds part  rate  the rate in the same units as for  rtctime.get() . The stored rate is not modified if not specified.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/rtctime/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/rtctime/#example_4", 
            "text": "-- Set time to 2015 July 9, 18:29:49\nrtctime.set(1436430589, 0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/rtctime/#see-also_1", 
            "text": "sntp.sync()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/si7021/", 
            "text": "Si7021 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2017-04-19\n\n\nfetchbot\n\n\nfetchbot\n\n\nsi7021.c\n\n\n\n\n\n\n\n\nThis module provides access to the Si7021 humidity and temperature sensor.\n\n\nsi7021.firmware()\n\n\nRead the internal firmware revision of the Si7021 sensor.\n\n\nSyntax\n\n\nsi7021.firmware()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nfwrev\n Firmware version\n\n \n0xFF\n Firmware version 1.0\n\n \n0x20\n Firmware version 2.0\n\n\nExample\n\n\nlocal sda, scl = 6, 5\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()\n\nfwrev = si7021.firmware()\nprint(string.format(\nFW: %X\\r\\n\n, fwrev))\n\n\n\n\nsi7021.read()\n\n\nSyntax\n\n\nsi7021.read()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nhum\n humidity (see note below)\n\n\ntemp\n temperature (see note below)\n\n\nhum_dec\n humidity decimal\n\n\ntemp_dec\n temperature decimal\n\n\n\n\n\n\nNote\n\n\nIf using float firmware then \nhum\n and \ntemp\n are floating point numbers. On an integer firmware, the final values have to be concatenated from \nhum\n and \nhum_dec\n / \ntemp\n and \ntemp_dec\n.\n\n\n\n\nExample\n\n\nlocal sda, scl = 6, 5\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()\n\nhum, temp, hum_dec, temp_dec = si7021.read()\n\n-- Integer firmware using this example\nprint(string.format(\nHumidity:\\t\\t%d.%03d\\nTemperature:\\t%d.%03d\\n\n, hum, hum_dec, temp, temp_dec))\n\n-- Float firmware using this example\nprint(\nHumidity: \n..hum..\n\\n\n..\nTemperature: \n..temp)\n\n\n\n\nsi7021.serial()\n\n\nRead the individualized 64-bit electronic serial number of the Si7021 sensor.\n\n\nSyntax\n\n\nsi7021.serial()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nsna\n 32-bit serial number part a\n\n\nsnb\n 32-bit serial number part b, upper byte contains the device identification\n\n\n0x00\n or \n0xFF\n engineering samples\n\n\n0x0D\n \n13\n Si7013\n\n\n0x14\n \n20\n Si7020\n\n\n0x15\n \n21\n Si7021\n\n\n\n\n\n\n\n\nExample\n\n\nlocal sda, scl = 6, 5\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()\n\nsna, snb = si7021.serial()\nprint(string.format(\nSN:\\t\\t%X%X\\nDevice:\\tSi70%d\n, sna, snb, bit.rshift(snb,24)))\n\n\n\n\nsi7021.setting()\n\n\nSettings for the sensors configuration register to adjust measurement resolution, on-chip heater and read the supply voltage status.\n\n\nSyntax\n\n\nsi7021.setting(RESOLUTION[, HEATER, HEATER_SETTING])\n\n\nParameters\n\n\n\n\nRESOLUTION\n\n\nsi7021.RH12_TEMP14\n Relative Humidity 12 bit - Temperature 14 bit (default)\n\n\nsi7021.RH08_TEMP12\n Relative Humidity 8 bit - Temperature 12 bit\n\n\nsi7021.RH10_TEMP13\n Relative Humidity 10 bit - Temperature 13 bit\n\n\nsi7021.RH11_TEMP11\n Relative Humidity 11 bit - Temperature 11 bit\n\n\n\n\n\n\nHEATER\n optional\n\n\nsi7021.HEATER_ENABLE\n On-chip Heater Enable\n\n\nsi7021.HEATER_DISABLE\n On-chip Heater Disable (default)\n\n\n\n\n\n\nHEATER_SETTING\n optional\n\n\n0x00\n - \n0x0F\n 3.09 mA - 94.20 mA\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nresolution\n\n\n0\n Relative Humidity 12 bit - Temperature 14 bit\n\n\n1\n Relative Humidity 8 bit - Temperature 12 bit\n\n\n2\n Relative Humidity 10 bit - Temperature 13 bit\n\n\n3\n Relative Humidity 11 bit - Temperature 11 bit\n\n\n\n\n\n\nvdds\n\n\n0\n VDD OK (1.9V - 3.6V)\n\n\n1\n VDD LOW (1.8V - 1.9V)\n\n\n\n\n\n\nheater\n\n\n0\n Disabled\n\n\n1\n Enabled\n\n\n\n\n\n\nheater_setting\n\n\n0\n - \n15\n\n\n\n\n\n\n\n\nExample\n\n\nlocal id, sda, scl = 0, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()\n\nres, vdds, heater, heater_set = si7021.setting(si7021.RH12_TEMP14)\nres, vdds, heater, heater_set = si7021.setting(si7021.RH12_TEMP14, si7021.HEATER_ENABLE, 0x01)\n\n\n\n\nsi7021.setup()\n\n\nInitializes the device on fixed I\u00b2C device address (0x40).\n\n\nSyntax\n\n\nsi7021.setup()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nlocal sda, scl = 6, 5\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()", 
            "title": "si7021"
        }, 
        {
            "location": "/en/modules/si7021/#si7021-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2017-04-19  fetchbot  fetchbot  si7021.c     This module provides access to the Si7021 humidity and temperature sensor.", 
            "title": "Si7021 Module"
        }, 
        {
            "location": "/en/modules/si7021/#si7021firmware", 
            "text": "Read the internal firmware revision of the Si7021 sensor.", 
            "title": "si7021.firmware()"
        }, 
        {
            "location": "/en/modules/si7021/#syntax", 
            "text": "si7021.firmware()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/si7021/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/si7021/#returns", 
            "text": "fwrev  Firmware version   0xFF  Firmware version 1.0   0x20  Firmware version 2.0", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/si7021/#example", 
            "text": "local sda, scl = 6, 5\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()\n\nfwrev = si7021.firmware()\nprint(string.format( FW: %X\\r\\n , fwrev))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/si7021/#si7021read", 
            "text": "", 
            "title": "si7021.read()"
        }, 
        {
            "location": "/en/modules/si7021/#syntax_1", 
            "text": "si7021.read()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/si7021/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/si7021/#returns_1", 
            "text": "hum  humidity (see note below)  temp  temperature (see note below)  hum_dec  humidity decimal  temp_dec  temperature decimal    Note  If using float firmware then  hum  and  temp  are floating point numbers. On an integer firmware, the final values have to be concatenated from  hum  and  hum_dec  /  temp  and  temp_dec .", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/si7021/#example_1", 
            "text": "local sda, scl = 6, 5\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()\n\nhum, temp, hum_dec, temp_dec = si7021.read()\n\n-- Integer firmware using this example\nprint(string.format( Humidity:\\t\\t%d.%03d\\nTemperature:\\t%d.%03d\\n , hum, hum_dec, temp, temp_dec))\n\n-- Float firmware using this example\nprint( Humidity:  ..hum.. \\n .. Temperature:  ..temp)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/si7021/#si7021serial", 
            "text": "Read the individualized 64-bit electronic serial number of the Si7021 sensor.", 
            "title": "si7021.serial()"
        }, 
        {
            "location": "/en/modules/si7021/#syntax_2", 
            "text": "si7021.serial()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/si7021/#parameters_2", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/si7021/#returns_2", 
            "text": "sna  32-bit serial number part a  snb  32-bit serial number part b, upper byte contains the device identification  0x00  or  0xFF  engineering samples  0x0D   13  Si7013  0x14   20  Si7020  0x15   21  Si7021", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/si7021/#example_2", 
            "text": "local sda, scl = 6, 5\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()\n\nsna, snb = si7021.serial()\nprint(string.format( SN:\\t\\t%X%X\\nDevice:\\tSi70%d , sna, snb, bit.rshift(snb,24)))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/si7021/#si7021setting", 
            "text": "Settings for the sensors configuration register to adjust measurement resolution, on-chip heater and read the supply voltage status.", 
            "title": "si7021.setting()"
        }, 
        {
            "location": "/en/modules/si7021/#syntax_3", 
            "text": "si7021.setting(RESOLUTION[, HEATER, HEATER_SETTING])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/si7021/#parameters_3", 
            "text": "RESOLUTION  si7021.RH12_TEMP14  Relative Humidity 12 bit - Temperature 14 bit (default)  si7021.RH08_TEMP12  Relative Humidity 8 bit - Temperature 12 bit  si7021.RH10_TEMP13  Relative Humidity 10 bit - Temperature 13 bit  si7021.RH11_TEMP11  Relative Humidity 11 bit - Temperature 11 bit    HEATER  optional  si7021.HEATER_ENABLE  On-chip Heater Enable  si7021.HEATER_DISABLE  On-chip Heater Disable (default)    HEATER_SETTING  optional  0x00  -  0x0F  3.09 mA - 94.20 mA", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/si7021/#returns_3", 
            "text": "resolution  0  Relative Humidity 12 bit - Temperature 14 bit  1  Relative Humidity 8 bit - Temperature 12 bit  2  Relative Humidity 10 bit - Temperature 13 bit  3  Relative Humidity 11 bit - Temperature 11 bit    vdds  0  VDD OK (1.9V - 3.6V)  1  VDD LOW (1.8V - 1.9V)    heater  0  Disabled  1  Enabled    heater_setting  0  -  15", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/si7021/#example_3", 
            "text": "local id, sda, scl = 0, 6, 5\ni2c.setup(id, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()\n\nres, vdds, heater, heater_set = si7021.setting(si7021.RH12_TEMP14)\nres, vdds, heater, heater_set = si7021.setting(si7021.RH12_TEMP14, si7021.HEATER_ENABLE, 0x01)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/si7021/#si7021setup", 
            "text": "Initializes the device on fixed I\u00b2C device address (0x40).", 
            "title": "si7021.setup()"
        }, 
        {
            "location": "/en/modules/si7021/#syntax_4", 
            "text": "si7021.setup()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/si7021/#parameters_4", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/si7021/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/si7021/#example_4", 
            "text": "local sda, scl = 6, 5\ni2c.setup(0, sda, scl, i2c.SLOW) -- call i2c.setup() only once\nsi7021.setup()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/sigma-delta/", 
            "text": "Sigma-delta Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-02-20\n\n\nEspressif example\n, \nArnim L\u00e4uger\n\n\nArnim L\u00e4uger\n\n\nsigma_delta.c\n\n\n\n\n\n\n\n\nThis module provides access to the \nsigma-delta\n component. It's a hardware signal generator that can be routed to any of the GPIOs except pin 0.\n\n\nThe signal generation is controlled by the \nsetprescale()\n and \nsettarget()\n functions.\n\n\n\n\n0 \n target \n= 128\n\n    t\nhigh\n = (prescale + 1) / 80 \u00b5s\n\n    t\nperiod\n  = t\nhigh\n * 256 / target\n\n\n128 \n target \n 256\n\n    t\nlow\n  = (prescale + 1) / 80 \u00b5s\n\n    t\nperiod\n = t\nlow\n * 256 / (256 - target)\n\n\ntarget = 0\n\n    signal stopped at low\n\n\n\n\nFixed frequency PWM at ~312.5\nkHz is availble with the \nsetpwmduty()\n function.\n\n\nsigma_delta.close()\n\n\nStops signal generation and reenables GPIO functionality at the specified pin.\n\n\nSyntax\n\n\nsigma_delta.close(pin)\n\n\nParameters\n\n\npin\n 1~12, IO index\n\n\nReturns\n\n\nnil\n\n\nsigma_delta.setprescale()\n\n\nSets the prescale value.\n\n\nSyntax\n\n\n`sigma_delta.setprescale(value)\n\n\nParameters\n\n\nvalue\n prescale 1 to 255\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nsigma_delta.settarget()\n\n\nsigma_delta.setpwmduty()\n\n\nOperate the sigma-delta module in PWM-like mode with fixed base frequency.\n\n\nSyntax\n\n\nsigma_delta.setpwmduty(ratio)\n\n\nParameters\n\n\nratio\n 0...255 for duty cycle 0...100%, 0 stops the signal at low\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- attach generator to pin 2\nsigma_delta.setup(2)\n-- set 50% duty cycle ratio (and implicitly start signal)\nsigma_delta.setpwmduty(128)\n-- stop\nsigma_delta.setpwmduty(0)\n-- resume with ~99.6% ratio\nsigma_delta.setpwmduty(255)\n-- stop and detach generator from pin 2\nsigma_delta.close(2)\n\n\n\n\nsigma_delta.settarget()\n\n\nSets the target value.\n\n\nSyntax\n\n\nsigma_delta.settarget(value)\n\n\nParameters\n\n\nvalue\n target 0 to 255\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nsigma_delta.setprescale()\n\n\nsigma_delta.setup()\n\n\nStops the signal generator and routes it to the specified pin.\n\n\nSyntax\n\n\nsigma_delta.setup(pin)\n\n\nParameters\n\n\npin\n 1~12, IO index\n\n\nReturns\n\n\nnil", 
            "title": "sigma delta"
        }, 
        {
            "location": "/en/modules/sigma-delta/#sigma-delta-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-02-20  Espressif example ,  Arnim L\u00e4uger  Arnim L\u00e4uger  sigma_delta.c     This module provides access to the  sigma-delta  component. It's a hardware signal generator that can be routed to any of the GPIOs except pin 0.  The signal generation is controlled by the  setprescale()  and  settarget()  functions.   0   target  = 128 \n    t high  = (prescale + 1) / 80 \u00b5s \n    t period   = t high  * 256 / target  128   target   256 \n    t low   = (prescale + 1) / 80 \u00b5s \n    t period  = t low  * 256 / (256 - target)  target = 0 \n    signal stopped at low   Fixed frequency PWM at ~312.5 kHz is availble with the  setpwmduty()  function.", 
            "title": "Sigma-delta Module"
        }, 
        {
            "location": "/en/modules/sigma-delta/#sigma_deltaclose", 
            "text": "Stops signal generation and reenables GPIO functionality at the specified pin.", 
            "title": "sigma_delta.close()"
        }, 
        {
            "location": "/en/modules/sigma-delta/#syntax", 
            "text": "sigma_delta.close(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sigma-delta/#parameters", 
            "text": "pin  1~12, IO index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sigma-delta/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sigma-delta/#sigma_deltasetprescale", 
            "text": "Sets the prescale value.", 
            "title": "sigma_delta.setprescale()"
        }, 
        {
            "location": "/en/modules/sigma-delta/#syntax_1", 
            "text": "`sigma_delta.setprescale(value)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sigma-delta/#parameters_1", 
            "text": "value  prescale 1 to 255", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sigma-delta/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sigma-delta/#see-also", 
            "text": "sigma_delta.settarget()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/sigma-delta/#sigma_deltasetpwmduty", 
            "text": "Operate the sigma-delta module in PWM-like mode with fixed base frequency.", 
            "title": "sigma_delta.setpwmduty()"
        }, 
        {
            "location": "/en/modules/sigma-delta/#syntax_2", 
            "text": "sigma_delta.setpwmduty(ratio)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sigma-delta/#parameters_2", 
            "text": "ratio  0...255 for duty cycle 0...100%, 0 stops the signal at low", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sigma-delta/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sigma-delta/#example", 
            "text": "-- attach generator to pin 2\nsigma_delta.setup(2)\n-- set 50% duty cycle ratio (and implicitly start signal)\nsigma_delta.setpwmduty(128)\n-- stop\nsigma_delta.setpwmduty(0)\n-- resume with ~99.6% ratio\nsigma_delta.setpwmduty(255)\n-- stop and detach generator from pin 2\nsigma_delta.close(2)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/sigma-delta/#sigma_deltasettarget", 
            "text": "Sets the target value.", 
            "title": "sigma_delta.settarget()"
        }, 
        {
            "location": "/en/modules/sigma-delta/#syntax_3", 
            "text": "sigma_delta.settarget(value)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sigma-delta/#parameters_3", 
            "text": "value  target 0 to 255", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sigma-delta/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sigma-delta/#see-also_1", 
            "text": "sigma_delta.setprescale()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/sigma-delta/#sigma_deltasetup", 
            "text": "Stops the signal generator and routes it to the specified pin.", 
            "title": "sigma_delta.setup()"
        }, 
        {
            "location": "/en/modules/sigma-delta/#syntax_4", 
            "text": "sigma_delta.setup(pin)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sigma-delta/#parameters_4", 
            "text": "pin  1~12, IO index", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sigma-delta/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sjson/", 
            "text": "SJSON Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2017-02-01\n\n\nPhilip Gladstone\n\n\nPhilip Gladstone\n\n\nsjson\n\n\n\n\n\n\n\n\nThe JSON support module. Allows encoding and decoding to/from JSON.\n\n\nPlease note that nested tables can require a lot of memory to encode. To catch out-of-memory errors, use \npcall()\n.\n\n\nThis code using the streaming json library \njsonsl\n to do the parsing of the string.\n\n\nThis module can be used in two ways. The simpler way is to use it as a direct drop-in for cjson (you can just do \n_G.cjson = sjson\n). \nThe more advanced approach is to use the streaming interface. This allows encoding and decoding of significantly larger objects.\n\n\nThe handling of json null is as follows:\n\n\n\n\nBy default, the decoder represents null as sjson.NULL (which is a userdata object). This is the behavior of cjson.\n\n\nThe encoder always converts any userdata object into null.\n\n\nOptionally, a single string can be specified in both the encoder and decoder. This string will be used in encoding/decoding to represent json null values. This string should not be used\nanywhere else in your data structures. A suitable value might be \n\"\\0\"\n.\n\n\n\n\nWhen encoding a lua object, if a function is found, then it is invoked (with no arguments) and the (single) returned value is encoded in the place of the function.\n\n\nsjson.encoder()\n\n\nThis creates an encoder object that can convert a LUA object into a JSON encoded string.\n\n\nSyntax\n\n\nsjson.encoder(table [, opts])\n\n\nParameters\n\n\n\n\ntable\n data to encode\n\n\nopts\n an optional table of options. The possible entries are:\n\n\ndepth\n the maximum encoding depth needed to encode the table. The default is 20 which should be enough for nearly all situations.\n\n\nnull\n the string value to treat as null.\n\n\n\n\nReturns\n\n\nA \nsjson.encoder\n object.\n\n\nsjson.encoder:read\n\n\nThis gets a chunk of JSON encoded data.\n\n\nSyntax\n\n\nencoder:read([size])\n\n\nParameters\n\n\n\n\nsize\n an optional value for the number of bytes to return. The default is 1024.\n\n\n\n\nReturns\n\n\nA string of up to \nsize\n bytes, or \nnil\n if the encoding is complete and all data has been returned.\n\n\nExample\n\n\nThe following example prints out (in 64 byte chunks) a JSON encoded string containing the first 4k of every file in the file system. The total string\ncan be bigger than the total amount of memory on the NodeMCU.\n\n\nfunction files() \n   result = {}\n   for k,v in pairs(file.list()) do\n     result[k] = function() return file.open(k):read(4096) end\n   end\n   return result\nend\n\nlocal encoder = sjson.encoder(files())\n\nwhile true do\n   data = encoder:read(64)\n   if not data then\n      break\n   end\n   print(data)\nend\n\n\n\n\nsjson.encode()\n\n\nEncode a Lua table to a JSON string. This is a convenience method provided for backwards compatibility with \ncjson\n.\n\n\nSyntax\n\n\nsjson.encode(table [, opts])\n\n\nParameters\n\n\n\n\ntable\n data to encode\n\n\nopts\n an optional table of options. The possible entries are:\n\n\ndepth\n the maximum encoding depth needed to encode the table. The default is 20 which should be enough for nearly all situations.\n\n\nnull\n the string value to treat as null.\n\n\n\n\n\n\n\n\nReturns\n\n\nJSON string\n\n\nExample\n\n\nok, json = pcall(sjson.encode, {key=\nvalue\n})\nif ok then\n  print(json)\nelse\n  print(\nfailed to encode!\n)\nend\n\n\n\n\nsjson.decoder()\n\n\nThis makes a decoder object that can parse a JSON encoded string into a lua object. A metatable can be specified for all the newly created lua tables. This allows\nyou to handle each value as it is inserted into each table (by implementing the \n__newindex\n method).\n\n\nSyntax\n\n\nsjson.decoder([opts])\n\n\nParameters\n\n\n\n\nopts\n an optional table of options. The possible entries are:\n\n\ndepth\n the maximum encoding depth needed to encode the table. The default is 20 which should be enough for nearly all situations.\n\n\nnull\n the string value to treat as null.\n\n\nmetatable\n a table to use as the metatable for all the new tables in the returned object.\n\n\n\n\n\n\n\n\nReturns\n\n\nA \nsjson.decoder\n object\n\n\nMetatable\n\n\nThere are two principal methods that are invoked in the metatable (if it is present).\n\n\n\n\n__newindex\n this is the standard method invoked whenever a new table element is created.\n\n\ncheckpath\n this is invoked (if defined) whenever a new table is created. It is invoked with two arguments:\n\n\ntable\n this is the newly created table\n\n\npath\n this is a list of the keys from the root. \nIt must return \ntrue\n if this object is wanted in the result, or \nfalse\n otherwise.\n\n\n\n\n\n\n\n\nFor example, when decoding \n{ \"foo\": [1, 2, []] }\n the checkpath will be invoked as follows:\n\n\n\n\ncheckpath({}, {})\n the \ntable\n argument is the object that will correspond with the value of the JSON object.\n\n\ncheckpath({}, {\"foo\"})\n the \ntable\n argument is the object that will correspond with the value of the outer JSON array.\n\n\ncheckpath({}, {\"foo\", 3})\n the \ntable\n argument is the object that will correspond to the empty inner JSON array.\n\n\n\n\nWhen the \ncheckpath\n method is called, the metatable has already be associated with the new table. Thus the \ncheckpath\n method can replace it\nif desired. For example, if you are decoding \n{ \"foo\": { \"bar\": [1,2,3,4], \"cat\": [5] } }\n and, for some reason, you did not want to capture the\nvalue of the \n\"bar\"\n key, then there are various ways to do this:\n\n\n\n\n\n\nIn the \n__newindex\n metamethod, just check for the value of the key and skip the \nrawset\n if the key is \n\"bar\"\n. This only works if you want to skip all the \n\n\"bar\"\n keys.\n\n\n\n\n\n\nIn the \ncheckpath\n method, if the path is \n[\"foo\"]\n, then return \nfalse\n.\n\n\n\n\n\n\nUse the following \ncheckpath\n:  \ncheckpath=function(tab, path) tab['__json_path'] = path return true end\n This will save the path in each constructed object. Now the \n__newindex\n method can perform more sophisticated filtering.\n\n\n\n\n\n\nThe reason for being able to filter is that it enables processing of very large JSON responses on a memory constrained platform. Many APIs return lots of information\nwhich would exceed the memory budget of the platform. For example, \nhttps://api.github.com/repos/nodemcu/nodemcu-firmware/contents\n is over 13kB, and yet, if \nyou only need the \ndownload_url\n keys, then the total size is around 600B. This can be handled with a simple \n__newindex\n method. \n\n\nsjson.decoder:write\n\n\nThis provides more data to be parsed into the lua object.\n\n\nSyntax\n\n\ndecoder:write(string)\n\n\nParameters\n\n\n\n\nstring\n the next piece of JSON encoded data\n\n\n\n\nReturns\n\n\nThe constructed lua object or \nnil\n if the decode is not yet complete.\n\n\nErrors\n\n\nIf a parse error occurrs during this decode, then an error is thrown and the parse is aborted. The object cannot be used again.\n\n\nsjson.decoder:result\n\n\nThis gets the decoded lua object, or raises an error if the decode is not yet complete. This can be called multiple times and will return the \nsame object each time.\n\n\nSyntax\n\n\ndecoder:result()\n\n\nErrors\n\n\nIf the decode is not complete, then an error is thrown.\n\n\nExample\n\n\nlocal decoder = sjson.decoder()\n\ndecoder:write(\n[10, 1\n)\ndecoder:write(\n1\n)\ndecoder:write(\n, \\\nfoo\\\n]\n)\n\nfor k,v in pairs(decoder:result()) do\n   print (k, v)\nend\n\n\n\n\nThe next example demonstrates the use of the metatable argument. In this case it just prints out the operations, but it could suppress the assignment\naltogether if desired.\n\n\nlocal decoder = sjson.decoder({metatable=\n        {__newindex=function(t,k,v) print(\nSetting '\n .. k .. \n' = '\n .. tostring(v) ..\n'\n) \n                                    rawset(t,k,v) end}})\n\ndecoder:write('[1, 2, {\nfoo\n:\nbar\n}]')\n\n\n\n\n\nsjson.decode()\n\n\nDecode a JSON string to a Lua table. This is a convenience method provided for backwards compatibility with \ncjson\n.\n\n\nSyntax\n\n\nsjson.decode(str[, opts])\n\n\nParameters\n\n\n\n\nstr\n JSON string to decode\n\n\nopts\n an optional table of options. The possible entries are:\n\n\ndepth\n the maximum encoding depth needed to encode the table. The default is 20 which should be enough for nearly all situations.\n\n\nnull\n the string value to treat as null.\n\n\nmetatable\n a table to use as the metatable for all the new tables in the returned object. See the metatable section in the description of \nsjson.decoder()\n above.\n\n\n\n\n\n\n\n\nReturns\n\n\nLua table representation of the JSON data\n\n\nErrors\n\n\nIf the string is not valid JSON, then an error is thrown.\n\n\nExample\n\n\nt = sjson.decode('{\nkey\n:\nvalue\n}')\nfor k,v in pairs(t) do print(k,v) end\n\n\n\n\nConstants\n\n\nThere is one constant -- \nsjson.NULL\n -- which is used in lua structures to represent the presence of a JSON null.", 
            "title": "sjson"
        }, 
        {
            "location": "/en/modules/sjson/#sjson-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2017-02-01  Philip Gladstone  Philip Gladstone  sjson     The JSON support module. Allows encoding and decoding to/from JSON.  Please note that nested tables can require a lot of memory to encode. To catch out-of-memory errors, use  pcall() .  This code using the streaming json library  jsonsl  to do the parsing of the string.  This module can be used in two ways. The simpler way is to use it as a direct drop-in for cjson (you can just do  _G.cjson = sjson ). \nThe more advanced approach is to use the streaming interface. This allows encoding and decoding of significantly larger objects.  The handling of json null is as follows:   By default, the decoder represents null as sjson.NULL (which is a userdata object). This is the behavior of cjson.  The encoder always converts any userdata object into null.  Optionally, a single string can be specified in both the encoder and decoder. This string will be used in encoding/decoding to represent json null values. This string should not be used\nanywhere else in your data structures. A suitable value might be  \"\\0\" .   When encoding a lua object, if a function is found, then it is invoked (with no arguments) and the (single) returned value is encoded in the place of the function.", 
            "title": "SJSON Module"
        }, 
        {
            "location": "/en/modules/sjson/#sjsonencoder", 
            "text": "This creates an encoder object that can convert a LUA object into a JSON encoded string.", 
            "title": "sjson.encoder()"
        }, 
        {
            "location": "/en/modules/sjson/#syntax", 
            "text": "sjson.encoder(table [, opts])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sjson/#parameters", 
            "text": "table  data to encode  opts  an optional table of options. The possible entries are:  depth  the maximum encoding depth needed to encode the table. The default is 20 which should be enough for nearly all situations.  null  the string value to treat as null.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sjson/#returns", 
            "text": "A  sjson.encoder  object.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sjson/#sjsonencoderread", 
            "text": "This gets a chunk of JSON encoded data.", 
            "title": "sjson.encoder:read"
        }, 
        {
            "location": "/en/modules/sjson/#syntax_1", 
            "text": "encoder:read([size])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sjson/#parameters_1", 
            "text": "size  an optional value for the number of bytes to return. The default is 1024.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sjson/#returns_1", 
            "text": "A string of up to  size  bytes, or  nil  if the encoding is complete and all data has been returned.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sjson/#example", 
            "text": "The following example prints out (in 64 byte chunks) a JSON encoded string containing the first 4k of every file in the file system. The total string\ncan be bigger than the total amount of memory on the NodeMCU.  function files() \n   result = {}\n   for k,v in pairs(file.list()) do\n     result[k] = function() return file.open(k):read(4096) end\n   end\n   return result\nend\n\nlocal encoder = sjson.encoder(files())\n\nwhile true do\n   data = encoder:read(64)\n   if not data then\n      break\n   end\n   print(data)\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/sjson/#sjsonencode", 
            "text": "Encode a Lua table to a JSON string. This is a convenience method provided for backwards compatibility with  cjson .", 
            "title": "sjson.encode()"
        }, 
        {
            "location": "/en/modules/sjson/#syntax_2", 
            "text": "sjson.encode(table [, opts])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sjson/#parameters_2", 
            "text": "table  data to encode  opts  an optional table of options. The possible entries are:  depth  the maximum encoding depth needed to encode the table. The default is 20 which should be enough for nearly all situations.  null  the string value to treat as null.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sjson/#returns_2", 
            "text": "JSON string", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sjson/#example_1", 
            "text": "ok, json = pcall(sjson.encode, {key= value })\nif ok then\n  print(json)\nelse\n  print( failed to encode! )\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/sjson/#sjsondecoder", 
            "text": "This makes a decoder object that can parse a JSON encoded string into a lua object. A metatable can be specified for all the newly created lua tables. This allows\nyou to handle each value as it is inserted into each table (by implementing the  __newindex  method).", 
            "title": "sjson.decoder()"
        }, 
        {
            "location": "/en/modules/sjson/#syntax_3", 
            "text": "sjson.decoder([opts])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sjson/#parameters_3", 
            "text": "opts  an optional table of options. The possible entries are:  depth  the maximum encoding depth needed to encode the table. The default is 20 which should be enough for nearly all situations.  null  the string value to treat as null.  metatable  a table to use as the metatable for all the new tables in the returned object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sjson/#returns_3", 
            "text": "A  sjson.decoder  object", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sjson/#metatable", 
            "text": "There are two principal methods that are invoked in the metatable (if it is present).   __newindex  this is the standard method invoked whenever a new table element is created.  checkpath  this is invoked (if defined) whenever a new table is created. It is invoked with two arguments:  table  this is the newly created table  path  this is a list of the keys from the root. \nIt must return  true  if this object is wanted in the result, or  false  otherwise.     For example, when decoding  { \"foo\": [1, 2, []] }  the checkpath will be invoked as follows:   checkpath({}, {})  the  table  argument is the object that will correspond with the value of the JSON object.  checkpath({}, {\"foo\"})  the  table  argument is the object that will correspond with the value of the outer JSON array.  checkpath({}, {\"foo\", 3})  the  table  argument is the object that will correspond to the empty inner JSON array.   When the  checkpath  method is called, the metatable has already be associated with the new table. Thus the  checkpath  method can replace it\nif desired. For example, if you are decoding  { \"foo\": { \"bar\": [1,2,3,4], \"cat\": [5] } }  and, for some reason, you did not want to capture the\nvalue of the  \"bar\"  key, then there are various ways to do this:    In the  __newindex  metamethod, just check for the value of the key and skip the  rawset  if the key is  \"bar\" . This only works if you want to skip all the  \"bar\"  keys.    In the  checkpath  method, if the path is  [\"foo\"] , then return  false .    Use the following  checkpath :   checkpath=function(tab, path) tab['__json_path'] = path return true end  This will save the path in each constructed object. Now the  __newindex  method can perform more sophisticated filtering.    The reason for being able to filter is that it enables processing of very large JSON responses on a memory constrained platform. Many APIs return lots of information\nwhich would exceed the memory budget of the platform. For example,  https://api.github.com/repos/nodemcu/nodemcu-firmware/contents  is over 13kB, and yet, if \nyou only need the  download_url  keys, then the total size is around 600B. This can be handled with a simple  __newindex  method.", 
            "title": "Metatable"
        }, 
        {
            "location": "/en/modules/sjson/#sjsondecoderwrite", 
            "text": "This provides more data to be parsed into the lua object.", 
            "title": "sjson.decoder:write"
        }, 
        {
            "location": "/en/modules/sjson/#syntax_4", 
            "text": "decoder:write(string)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sjson/#parameters_4", 
            "text": "string  the next piece of JSON encoded data", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sjson/#returns_4", 
            "text": "The constructed lua object or  nil  if the decode is not yet complete.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sjson/#errors", 
            "text": "If a parse error occurrs during this decode, then an error is thrown and the parse is aborted. The object cannot be used again.", 
            "title": "Errors"
        }, 
        {
            "location": "/en/modules/sjson/#sjsondecoderresult", 
            "text": "This gets the decoded lua object, or raises an error if the decode is not yet complete. This can be called multiple times and will return the \nsame object each time.", 
            "title": "sjson.decoder:result"
        }, 
        {
            "location": "/en/modules/sjson/#syntax_5", 
            "text": "decoder:result()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sjson/#errors_1", 
            "text": "If the decode is not complete, then an error is thrown.", 
            "title": "Errors"
        }, 
        {
            "location": "/en/modules/sjson/#example_2", 
            "text": "local decoder = sjson.decoder()\n\ndecoder:write( [10, 1 )\ndecoder:write( 1 )\ndecoder:write( , \\ foo\\ ] )\n\nfor k,v in pairs(decoder:result()) do\n   print (k, v)\nend  The next example demonstrates the use of the metatable argument. In this case it just prints out the operations, but it could suppress the assignment\naltogether if desired.  local decoder = sjson.decoder({metatable=\n        {__newindex=function(t,k,v) print( Setting '  .. k ..  ' = '  .. tostring(v) .. ' ) \n                                    rawset(t,k,v) end}})\n\ndecoder:write('[1, 2, { foo : bar }]')", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/sjson/#sjsondecode", 
            "text": "Decode a JSON string to a Lua table. This is a convenience method provided for backwards compatibility with  cjson .", 
            "title": "sjson.decode()"
        }, 
        {
            "location": "/en/modules/sjson/#syntax_6", 
            "text": "sjson.decode(str[, opts])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sjson/#parameters_5", 
            "text": "str  JSON string to decode  opts  an optional table of options. The possible entries are:  depth  the maximum encoding depth needed to encode the table. The default is 20 which should be enough for nearly all situations.  null  the string value to treat as null.  metatable  a table to use as the metatable for all the new tables in the returned object. See the metatable section in the description of  sjson.decoder()  above.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sjson/#returns_5", 
            "text": "Lua table representation of the JSON data", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sjson/#errors_2", 
            "text": "If the string is not valid JSON, then an error is thrown.", 
            "title": "Errors"
        }, 
        {
            "location": "/en/modules/sjson/#example_3", 
            "text": "t = sjson.decode('{ key : value }')\nfor k,v in pairs(t) do print(k,v) end", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/sjson/#constants", 
            "text": "There is one constant --  sjson.NULL  -- which is used in lua structures to represent the presence of a JSON null.", 
            "title": "Constants"
        }, 
        {
            "location": "/en/modules/sntp/", 
            "text": "SNTP Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-06-30\n\n\nDiUS\n, \nJohny Mattsson\n\n\nJohny Mattsson\n\n\nsntp.c\n\n\n\n\n\n\n\n\nThe SNTP module implements a \nSimple Network Time Procotol\n client. This includes support for the \"anycast\" \nNTP\n mode where, if supported by the NTP server(s) in your network, it is not necessary to even know the IP address of the NTP server.\nBy default, this will use the servers 0.nodemcu.pool.ntp.org through 3.nodemcu.pool.ntp.org. These servers will be adequate for nearly all usages.\n\n\nWhen compiled together with the \nrtctime\n module it also offers seamless integration with it, potentially reducing the process of obtaining NTP synchronization to a simple \nsntp.sync()\n call without any arguments.\n\n\nsntp.sync()\n\n\nAttempts to obtain time synchronization. \n\n\nFor best results you may want to to call this periodically in order to compensate for internal clock drift. As stated in the \nrtctime\n module documentation it's advisable to sync time after deep sleep and it's necessary to sync after module reset (add it to \ninit.lua\n after WiFi initialization).\nNote that either a single server can be provided as an argument (name or address), or a list (table) of servers can be provided. \n\n\nSyntax\n\n\nsntp.sync([server_ip], [callback], [errcallback], [autorepeat])\n\n\nsntp.sync({ server1, server2, .. }, [callback], [errcallback], [autorepeat])\n\n\nParameters\n\n\n\n\nserver_ip\n if non-\nnil\n, that server is used. If \nnil\n, then the last contacted server is used. If there is no previous server, then the pool ntp servers are used. If the anycast server was used, then the first responding server will be saved. \n\n\nserver1\n, \nserver2\n these are either the ip address or dns name of one or more servers to try.\n\n\ncallback\n if provided it will be invoked on a successful synchronization, with four parameters: seconds, microseconds, server and info. Note that when the \nrtctime\n module is available, there is no need to explicitly call \nrtctime.set()\n - this module takes care of doing so internally automatically, for best accuracy. The info parameter is a table of (semi) interesting values. These are described below.\n\n\nerrcallback\n failure callback with two parameters. The first is an integer describing the type of error. The module automatically performs a number of retries before giving up and reporting the error. The second is a string containing supplementary information (if any). Error codes:\n\n\n1: DNS lookup failed (the second parameter is the failing DNS name)\n\n\n2: Memory allocation failure\n\n\n3: UDP send failed\n\n\n4: Timeout, no NTP response received\n\n\nautorepeat\n if this is non-nil, then the synchronization will happen every 1000 seconds and try and condition the clock if possible. The callbacks will be called after each sync operation.\n\n\n\n\nReturns\n\n\nnil\n\n\nInfo table\n\n\nThis is passed to the success callback and contains useful information about the time synch that just completed. The keys in this table are:\n\n\n\n\noffset_s\n This is an optional field and contains the number of seconds that the clock was adjusted. This is only present for large (many second) adjustments. Typically, this is only present on the initial sync call.\n\n\noffset_us\n This is an optional field (but one of \noffset_s\n and \noffset_us\n will always be present). This contains the number of microseconds that the clock was adjusted. \n\n\ndelay_us\n This is the round trip delay to the server in microseconds. Thie setting uncertainty is somewhat less than this value.\n\n\nstratum\n This is the stratum of the server. \n\n\nleap\n This contains the leap bits from the NTP protocol. 0 means that no leap second is pending, 1 is a pending extra leap second at the end of the UTC month, and 2 is a pending leap second removal at the end of the UTC month.\n\n\n\n\nExample\n\n\n-- Use the nodemcu specific pool servers and keep the time synced forever (this has the autorepeat flag set).\nsntp.sync(nil, nil, nil, 1)\n\n\n\n\n-- Single shot sync time with a server on the local network.\nsntp.sync(\n224.0.1.1\n,\n  function(sec, usec, server, info)\n    print('sync', sec, usec, server)\n  end,\n  function()\n   print('failed!')\n  end\n)\n\n\n\n\nSee also\n\n\nrtctime.set()\n\n\nsntp.setoffset\n\n\nSets the offset between the rtc clock and the NTP time. Note that NTP time has leap seconds in it and hence it runs slow when a leap second is \ninserted. The \nsetoffset\n call enables explicit leap second tracking and causes the rtc clock to tick more evenly -- but it gets out of step\nwith wall clock time. The number of seconds is the offset.\n\n\nSyntax\n\n\nsntp.setoffset([offset])\n\n\nParameters\n\n\n\n\noffset\n The offset between NTP time and the rtc time. This can be omitted, and defaults to zero. This call enables the offset tracking.\n\n\n\n\nReturns\n\n\nnil\n\n\nsntp.getoffset\n\n\nGets the offset between the rtc clock and the NTP time. This value should be subtracted from the rtc time to get the NTP time -- which\ncorresponds to wall clock time. If the offset returned has changed from the pervious call, then there has been a leap second inbetween.\n\n\nSyntax\n\n\noffset = sntp.getoffset()\n\n\nReturns\n\n\nThe current offset.", 
            "title": "sntp"
        }, 
        {
            "location": "/en/modules/sntp/#sntp-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-06-30  DiUS ,  Johny Mattsson  Johny Mattsson  sntp.c     The SNTP module implements a  Simple Network Time Procotol  client. This includes support for the \"anycast\"  NTP  mode where, if supported by the NTP server(s) in your network, it is not necessary to even know the IP address of the NTP server.\nBy default, this will use the servers 0.nodemcu.pool.ntp.org through 3.nodemcu.pool.ntp.org. These servers will be adequate for nearly all usages.  When compiled together with the  rtctime  module it also offers seamless integration with it, potentially reducing the process of obtaining NTP synchronization to a simple  sntp.sync()  call without any arguments.", 
            "title": "SNTP Module"
        }, 
        {
            "location": "/en/modules/sntp/#sntpsync", 
            "text": "Attempts to obtain time synchronization.   For best results you may want to to call this periodically in order to compensate for internal clock drift. As stated in the  rtctime  module documentation it's advisable to sync time after deep sleep and it's necessary to sync after module reset (add it to  init.lua  after WiFi initialization).\nNote that either a single server can be provided as an argument (name or address), or a list (table) of servers can be provided.", 
            "title": "sntp.sync()"
        }, 
        {
            "location": "/en/modules/sntp/#syntax", 
            "text": "sntp.sync([server_ip], [callback], [errcallback], [autorepeat])  sntp.sync({ server1, server2, .. }, [callback], [errcallback], [autorepeat])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sntp/#parameters", 
            "text": "server_ip  if non- nil , that server is used. If  nil , then the last contacted server is used. If there is no previous server, then the pool ntp servers are used. If the anycast server was used, then the first responding server will be saved.   server1 ,  server2  these are either the ip address or dns name of one or more servers to try.  callback  if provided it will be invoked on a successful synchronization, with four parameters: seconds, microseconds, server and info. Note that when the  rtctime  module is available, there is no need to explicitly call  rtctime.set()  - this module takes care of doing so internally automatically, for best accuracy. The info parameter is a table of (semi) interesting values. These are described below.  errcallback  failure callback with two parameters. The first is an integer describing the type of error. The module automatically performs a number of retries before giving up and reporting the error. The second is a string containing supplementary information (if any). Error codes:  1: DNS lookup failed (the second parameter is the failing DNS name)  2: Memory allocation failure  3: UDP send failed  4: Timeout, no NTP response received  autorepeat  if this is non-nil, then the synchronization will happen every 1000 seconds and try and condition the clock if possible. The callbacks will be called after each sync operation.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sntp/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sntp/#info-table", 
            "text": "This is passed to the success callback and contains useful information about the time synch that just completed. The keys in this table are:   offset_s  This is an optional field and contains the number of seconds that the clock was adjusted. This is only present for large (many second) adjustments. Typically, this is only present on the initial sync call.  offset_us  This is an optional field (but one of  offset_s  and  offset_us  will always be present). This contains the number of microseconds that the clock was adjusted.   delay_us  This is the round trip delay to the server in microseconds. Thie setting uncertainty is somewhat less than this value.  stratum  This is the stratum of the server.   leap  This contains the leap bits from the NTP protocol. 0 means that no leap second is pending, 1 is a pending extra leap second at the end of the UTC month, and 2 is a pending leap second removal at the end of the UTC month.", 
            "title": "Info table"
        }, 
        {
            "location": "/en/modules/sntp/#example", 
            "text": "-- Use the nodemcu specific pool servers and keep the time synced forever (this has the autorepeat flag set).\nsntp.sync(nil, nil, nil, 1)  -- Single shot sync time with a server on the local network.\nsntp.sync( 224.0.1.1 ,\n  function(sec, usec, server, info)\n    print('sync', sec, usec, server)\n  end,\n  function()\n   print('failed!')\n  end\n)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/sntp/#see-also", 
            "text": "rtctime.set()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/sntp/#sntpsetoffset", 
            "text": "Sets the offset between the rtc clock and the NTP time. Note that NTP time has leap seconds in it and hence it runs slow when a leap second is \ninserted. The  setoffset  call enables explicit leap second tracking and causes the rtc clock to tick more evenly -- but it gets out of step\nwith wall clock time. The number of seconds is the offset.", 
            "title": "sntp.setoffset"
        }, 
        {
            "location": "/en/modules/sntp/#syntax_1", 
            "text": "sntp.setoffset([offset])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sntp/#parameters_1", 
            "text": "offset  The offset between NTP time and the rtc time. This can be omitted, and defaults to zero. This call enables the offset tracking.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/sntp/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/sntp/#sntpgetoffset", 
            "text": "Gets the offset between the rtc clock and the NTP time. This value should be subtracted from the rtc time to get the NTP time -- which\ncorresponds to wall clock time. If the offset returned has changed from the pervious call, then there has been a leap second inbetween.", 
            "title": "sntp.getoffset"
        }, 
        {
            "location": "/en/modules/sntp/#syntax_2", 
            "text": "offset = sntp.getoffset()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/sntp/#returns_2", 
            "text": "The current offset.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/somfy/", 
            "text": "Somfy module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-09-27\n\n\nvsky279\n\n\nvsky279\n\n\nsomfy.c\n\n\n\n\n\n\n\n\nThis module provides a simple interface to control Somfy blinds via an RF transmitter (433.42 MHz). It is based on \nNickduino Somfy Remote Arduino skecth\n. \n\n\nThe hardware used is the standard 433 MHz RF transmitter. Unfortunately these chips are usually transmitting at he frequency of 433.92MHz so the crystal resonator should be replaced with the 433.42 MHz resonator though some reporting that it is working even with the original crystal.\n\n\nTo understand details of the Somfy protocol please refer to \nSomfy RTS protocol\n and also discussion \nhere\n.\n\n\nThe module is using hardware timer so it cannot be used at the same time with other NodeMCU modules using the hardware timer, i.e. \nsigma delta\n, \npcm\n, \nperf\n, or \npwm\n modules.\n\n\nsomfy.sendcommand()\n\n\nBuilds an frame defined by Somfy protocol and sends it to the RF transmitter.\n\n\nSyntax\n\n\nsomfy.sendcommand(pin, remote_address, command, rolling_code, repeat_count, call_back)\n\n\nParameters\n\n\n\n\npin\n GPIO pin the RF transmitter is connected to.\n\n\nremote_address\n address of the remote control. The device to be controlled is programmed with the addresses of the remote controls it should listen to.\n\n\ncommand\n command to be transmitted. Can be one of \nsomfy.SOMFY_UP\n, \nsomfy.SOMFY_DOWN\n, \nsomfy.SOMFY_PROG\n, \nsomfy.SOMFY_STOP\n\n\nrolling_code\n The rolling code is increased every time a button is pressed. The receiver only accepts command if the rolling code is above the last received code and is not to far ahead of the last received code. This window is in the order of a 100 big. The rolling code needs to be stored in the EEPROM (i.e. filesystem) to survive the ESP8266 reset.\n\n\nrepeat_count\n how many times the command is repeated\n\n\ncall_back\n a function to be called after the command is transmitted. Allows chaining commands to set the blinds to a defined position.\n\n\n\n\nMy original remote is \nTELIS 4 MODULIS RTS\n. This remote is working with the additional info - additional 56 bits that follow data (shortening the Inter-frame gap). It seems that the scrumbling alhorithm has not been revealed yet.\n\n\nWhen I send the \nsomfy.DOWN\n command, repeating the frame twice (which seems to be the standard for a short button press), i.e. \nrepeat_count\n equal to 2, the blinds go only 1 step down. This corresponds to the movement of the wheel on the original remote. The down button on the original remote sends also \nsomfy.DOWN\n command but the additional info is different and this makes the blinds go full down. Fortunately it seems that repeating the frame 16 times makes the blinds go fully down.\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nTo start with controlling your Somfy blinds you need to:\n\n\n\n\nChoose an arbitrary remote address (different from your existing remote) - \n123\n in this example\n\n\nChoose a starting point for the rolling code. Any unsigned int works, 1 is a good start\n\n\nLong-press the program button of your existing remote control until your blind goes up and down slightly\n\n\nexecute \nsomfy.sendcommand(4, 123, somfy.PROG, 1, 2)\n - the blinds will react and your ESP8266 remote control is now registered\n\n\nrunning \nsomfy.sendcommand(4, 123, somfy.DOWN, 2, 16)\n - fully closes the blinds\n\n\n\n\nFor more elaborated example please refer to \nsomfy.lua\n.", 
            "title": "somfy"
        }, 
        {
            "location": "/en/modules/somfy/#somfy-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-09-27  vsky279  vsky279  somfy.c     This module provides a simple interface to control Somfy blinds via an RF transmitter (433.42 MHz). It is based on  Nickduino Somfy Remote Arduino skecth .   The hardware used is the standard 433 MHz RF transmitter. Unfortunately these chips are usually transmitting at he frequency of 433.92MHz so the crystal resonator should be replaced with the 433.42 MHz resonator though some reporting that it is working even with the original crystal.  To understand details of the Somfy protocol please refer to  Somfy RTS protocol  and also discussion  here .  The module is using hardware timer so it cannot be used at the same time with other NodeMCU modules using the hardware timer, i.e.  sigma delta ,  pcm ,  perf , or  pwm  modules.", 
            "title": "Somfy module"
        }, 
        {
            "location": "/en/modules/somfy/#somfysendcommand", 
            "text": "Builds an frame defined by Somfy protocol and sends it to the RF transmitter.", 
            "title": "somfy.sendcommand()"
        }, 
        {
            "location": "/en/modules/somfy/#syntax", 
            "text": "somfy.sendcommand(pin, remote_address, command, rolling_code, repeat_count, call_back)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/somfy/#parameters", 
            "text": "pin  GPIO pin the RF transmitter is connected to.  remote_address  address of the remote control. The device to be controlled is programmed with the addresses of the remote controls it should listen to.  command  command to be transmitted. Can be one of  somfy.SOMFY_UP ,  somfy.SOMFY_DOWN ,  somfy.SOMFY_PROG ,  somfy.SOMFY_STOP  rolling_code  The rolling code is increased every time a button is pressed. The receiver only accepts command if the rolling code is above the last received code and is not to far ahead of the last received code. This window is in the order of a 100 big. The rolling code needs to be stored in the EEPROM (i.e. filesystem) to survive the ESP8266 reset.  repeat_count  how many times the command is repeated  call_back  a function to be called after the command is transmitted. Allows chaining commands to set the blinds to a defined position.   My original remote is  TELIS 4 MODULIS RTS . This remote is working with the additional info - additional 56 bits that follow data (shortening the Inter-frame gap). It seems that the scrumbling alhorithm has not been revealed yet.  When I send the  somfy.DOWN  command, repeating the frame twice (which seems to be the standard for a short button press), i.e.  repeat_count  equal to 2, the blinds go only 1 step down. This corresponds to the movement of the wheel on the original remote. The down button on the original remote sends also  somfy.DOWN  command but the additional info is different and this makes the blinds go full down. Fortunately it seems that repeating the frame 16 times makes the blinds go fully down.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/somfy/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/somfy/#example", 
            "text": "To start with controlling your Somfy blinds you need to:   Choose an arbitrary remote address (different from your existing remote) -  123  in this example  Choose a starting point for the rolling code. Any unsigned int works, 1 is a good start  Long-press the program button of your existing remote control until your blind goes up and down slightly  execute  somfy.sendcommand(4, 123, somfy.PROG, 1, 2)  - the blinds will react and your ESP8266 remote control is now registered  running  somfy.sendcommand(4, 123, somfy.DOWN, 2, 16)  - fully closes the blinds   For more elaborated example please refer to  somfy.lua .", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/spi/", 
            "text": "SPI Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-01-16\n\n\nIbrahim Abd Elkader\n\n\nArnim L\u00e4uger\n\n\nspi.c\n\n\n\n\n\n\n\n\nAll transactions for sending and receiving are most-significant-bit first and least-significant last.\nFor technical details of the underlying hardware refer to \nmetalphreak's ESP8266 HSPI articles\n.\n\n\n\n\nNote\n\n\nThe ESP hardware provides two SPI busses, with IDs 0, and 1, which map to pins generally labelled SPI and HSPI. If you are using any kind of development board which provides flash, then bus ID 0 (SPI) is almost certainly used for communicating with the flash chip. You probably want to choose bus ID 1 (HSPI) for your communication, as you will have uncontended use of it.\n\n\n\n\nHSPI signals are fixed to the following IO indices and GPIO pins:\n\n\n\n\n\n\n\n\nSignal\n\n\nIO index\n\n\nESP8266 pin\n\n\n\n\n\n\n\n\n\n\nHSPI CLK\n\n\n5\n\n\nGPIO14\n\n\n\n\n\n\nHSPI /CS\n\n\n8\n\n\nGPIO15\n\n\n\n\n\n\nHSPI MOSI\n\n\n7\n\n\nGPIO13\n\n\n\n\n\n\nHSPI MISO\n\n\n6\n\n\nGPIO12\n\n\n\n\n\n\n\n\nSee also \nspi.setup()\n.\n\n\nHigh Level Functions\n\n\nThe high level functions provide a send \n receive API for half- and\nfull-duplex mode. Sent and received data items are restricted to 1 - 32 bit\nlength and each data item is surrounded by (H)SPI CS inactive.\n\n\nspi.recv()\n\n\nReceive data from SPI.\n\n\nSyntax\n\n\nspi.recv(id, size[, default_data])\n\n\nParameters\n\n\n\n\nid\n SPI ID number: 0 for SPI, 1 for HSPI\n\n\nsize\n number of data items to be read\n\n\ndefault_data\n default data being sent on MOSI (all-1 if omitted)\n\n\n\n\nReturns\n\n\nString containing the bytes read from SPI.\n\n\nSee also\n\n\nspi.send()\n\n\nspi.send()\n\n\nSend data via SPI in half-duplex mode. Send \n receive data in full-duplex mode.\n\n\nSyntax\n\n\nHALFDUPLEX:\n\n\nwrote = spi.send(id, data1[, data2[, ..., datan]])\n\n\nFULLDUPLEX:\n\n\nwrote[, rdata1[, ..., rdatan]] = spi.send(id, data1[, data2[, ..., datan]])\n\n\nParameters\n\n\n\n\nid\n SPI ID number: 0 for SPI, 1 for HSPI\n\n\ndata\n data can be either a string, a table or an integer number.\nEach data item is considered with \ndatabits\n number of bits.\n\n\n\n\nReturns\n\n\n\n\nwrote\n number of written bytes\n\n\nrdata\n received data when configured with \nspi.FULLDUPLEX\nSame data type as corresponding data parameter.\n\n\n\n\nExample\n\n\n=spi.send(1, 0, 255, 255, 255)\n4       255     192     32      0\nx = {spi.send(1, 0, 255, 255, 255)}\n=x[1]\n4\n=x[2]\n255\n=x[3]\n192\n=x[4]\n32\n=x[5]\n0\n=x[6]\nnil\n=#x\n5\n\n_, _, x = spi.send(1, 0, {255, 255, 255})\n=x[1]\n192\n=x[2]\n32\n=x[3]\n0\n\n\n\n\nSee also\n\n\n\n\nspi.setup()\n\n\nspi.recv()\n\n\n\n\nspi.setup()\n\n\nSet up the SPI configuration.\nRefer to \nSerial Peripheral Interface Bus\n for details regarding the clock polarity and phase definition.\n\n\nCalling \nspi.setup()\n will route the HSPI signals to the related pins, overriding previous configuration and control by the \ngpio\n module. It is possible to revert any pin back to gpio control if its HSPI functionality is not needed, just set the desired \ngpio.mode()\n for it. This is recommended especially for the HSPI /CS pin function in case that SPI slave-select is driven from a different pin by \ngpio.write()\n - the SPI engine would toggle pin 8 otherwise.\n\n\nSyntax\n\n\nspi.setup(id, mode, cpol, cpha, databits, clock_div[, duplex_mode])\n\n\nParameters\n\n\n\n\nid\n SPI ID number: 0 for SPI, 1 for HSPI\n\n\nmode\n select master or slave mode\n\n\nspi.MASTER\n\n\nspi.SLAVE\n - \nnot supported currently\n\n\n\n\n\n\ncpol\n clock polarity selection\n\n\nspi.CPOL_LOW\n \n\n\nspi.CPOL_HIGH\n\n\n\n\n\n\ncpha\n clock phase selection\n\n\nspi.CPHA_LOW\n\n\nspi.CPHA_HIGH\n\n\n\n\n\n\ndatabits\n number of bits per data item 1 - 32\n\n\nclock_div\n SPI clock divider, f(SPI) = 80 MHz / \nclock_div\n, 1 .. n (0 defaults to divider 8)\n\n\nduplex_mode\n duplex mode\n\n\nspi.HALFDUPLEX\n (default when omitted)\n\n\nspi.FULLDUPLEX\n\n\n\n\n\n\n\n\nReturns\n\n\nNumber: 1\n\n\nExample\n\n\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)\n-- we won't be using the HSPI /CS line, so disable it again\ngpio.mode(8, gpio.INPUT, gpio.PULLUP)\n\n\n\n\nLow Level Hardware Functions\n\n\nThe low level functions provide a hardware-centric API for application\nscenarios that need to excercise more complex SPI transactions. The\nprogramming model is built up around the HW send and receive buffers and SPI\ntransactions are initiated with full control over the hardware features.\n\n\nspi.get_miso()\n\n\nExtract data items from MISO buffer after \nspi.transaction()\n.\n\n\nSyntax\n\n\ndata1[, data2[, ..., datan]] = spi.get_miso(id, offset, bitlen, num)\nstring = spi.get_miso(id, num)\n\n\n\n\nParameters\n\n\n\n\nid\n SPI ID number: 0 for SPI, 1 for HSPI\n\n\noffset\n bit offset into MISO buffer for first data item\n\n\nbitlen\n bit length of a single data item\n\n\nnum\n number of data items to retrieve\n\n\n\n\nReturns\n\n\nnum\n data items or \nstring\n\n\nSee also\n\n\nspi.transaction()\n\n\nspi.set_mosi()\n\n\nInsert data items into MOSI buffer for \nspi.transaction()\n.\n\n\nSyntax\n\n\nspi.set_mosi(id, offset, bitlen, data1[, data2[, ..., datan]])\nspi.set_mosi(id, string)\n\n\n\n\nParameters\n\n\n\n\nid\n SPI ID number: 0 for SPI, 1 for HSPI\n\n\noffset\n bit offset into MOSI buffer for inserting data1 and subsequent items\n\n\nbitlen\n bit length of data1, data2, ...\n\n\ndata\n data items where \nbitlen\n number of bits are considered for the transaction.\n\n\nstring\n send data to be copied into MOSI buffer at offset 0, bit length 8\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nspi.transaction()\n\n\nspi.transaction()\n\n\nStart an SPI transaction, consisting of up to 5 phases:\n\n\n\n\nCommand\n\n\nAddress\n\n\nMOSI\n\n\nDummy\n\n\nMISO\n\n\n\n\nSyntax\n\n\nspi.transaction(id, cmd_bitlen, cmd_data, addr_bitlen, addr_data, mosi_bitlen, dummy_bitlen, miso_bitlen)\n\n\nParameters\n\n\n\n\nid\n SPI ID number: 0 for SPI, 1 for HSPI\n\n\ncmd_bitlen\n bit length of the command phase (0 - 16)\n\n\ncmd_data\n data for command phase\n\n\naddr_bitlen\n bit length for address phase (0 - 32)\n\n\naddr_data\n data for command phase\n\n\nmosi_bitlen\n bit length of the MOSI phase (0 - 512)\n\n\ndummy_bitlen\n bit length of the dummy phase (0 - 256)\n\n\nmiso_bitlen\n bit length of the MISO phase (0 - 512) for half-duplex.\nFull-duplex mode is activated with a negative value.\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\n\n\nspi.set_mosi()\n\n\nspi.get_miso()", 
            "title": "spi"
        }, 
        {
            "location": "/en/modules/spi/#spi-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-01-16  Ibrahim Abd Elkader  Arnim L\u00e4uger  spi.c     All transactions for sending and receiving are most-significant-bit first and least-significant last.\nFor technical details of the underlying hardware refer to  metalphreak's ESP8266 HSPI articles .   Note  The ESP hardware provides two SPI busses, with IDs 0, and 1, which map to pins generally labelled SPI and HSPI. If you are using any kind of development board which provides flash, then bus ID 0 (SPI) is almost certainly used for communicating with the flash chip. You probably want to choose bus ID 1 (HSPI) for your communication, as you will have uncontended use of it.   HSPI signals are fixed to the following IO indices and GPIO pins:     Signal  IO index  ESP8266 pin      HSPI CLK  5  GPIO14    HSPI /CS  8  GPIO15    HSPI MOSI  7  GPIO13    HSPI MISO  6  GPIO12     See also  spi.setup() .", 
            "title": "SPI Module"
        }, 
        {
            "location": "/en/modules/spi/#high-level-functions", 
            "text": "The high level functions provide a send   receive API for half- and\nfull-duplex mode. Sent and received data items are restricted to 1 - 32 bit\nlength and each data item is surrounded by (H)SPI CS inactive.", 
            "title": "High Level Functions"
        }, 
        {
            "location": "/en/modules/spi/#spirecv", 
            "text": "Receive data from SPI.", 
            "title": "spi.recv()"
        }, 
        {
            "location": "/en/modules/spi/#syntax", 
            "text": "spi.recv(id, size[, default_data])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/spi/#parameters", 
            "text": "id  SPI ID number: 0 for SPI, 1 for HSPI  size  number of data items to be read  default_data  default data being sent on MOSI (all-1 if omitted)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/spi/#returns", 
            "text": "String containing the bytes read from SPI.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/spi/#see-also", 
            "text": "spi.send()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/spi/#spisend", 
            "text": "Send data via SPI in half-duplex mode. Send   receive data in full-duplex mode.", 
            "title": "spi.send()"
        }, 
        {
            "location": "/en/modules/spi/#syntax_1", 
            "text": "HALFDUPLEX:  wrote = spi.send(id, data1[, data2[, ..., datan]])  FULLDUPLEX:  wrote[, rdata1[, ..., rdatan]] = spi.send(id, data1[, data2[, ..., datan]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/spi/#parameters_1", 
            "text": "id  SPI ID number: 0 for SPI, 1 for HSPI  data  data can be either a string, a table or an integer number. Each data item is considered with  databits  number of bits.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/spi/#returns_1", 
            "text": "wrote  number of written bytes  rdata  received data when configured with  spi.FULLDUPLEX Same data type as corresponding data parameter.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/spi/#example", 
            "text": "=spi.send(1, 0, 255, 255, 255)\n4       255     192     32      0\nx = {spi.send(1, 0, 255, 255, 255)}\n=x[1]\n4\n=x[2]\n255\n=x[3]\n192\n=x[4]\n32\n=x[5]\n0\n=x[6]\nnil\n=#x\n5\n\n_, _, x = spi.send(1, 0, {255, 255, 255})\n=x[1]\n192\n=x[2]\n32\n=x[3]\n0", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/spi/#see-also_1", 
            "text": "spi.setup()  spi.recv()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/spi/#spisetup", 
            "text": "Set up the SPI configuration.\nRefer to  Serial Peripheral Interface Bus  for details regarding the clock polarity and phase definition.  Calling  spi.setup()  will route the HSPI signals to the related pins, overriding previous configuration and control by the  gpio  module. It is possible to revert any pin back to gpio control if its HSPI functionality is not needed, just set the desired  gpio.mode()  for it. This is recommended especially for the HSPI /CS pin function in case that SPI slave-select is driven from a different pin by  gpio.write()  - the SPI engine would toggle pin 8 otherwise.", 
            "title": "spi.setup()"
        }, 
        {
            "location": "/en/modules/spi/#syntax_2", 
            "text": "spi.setup(id, mode, cpol, cpha, databits, clock_div[, duplex_mode])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/spi/#parameters_2", 
            "text": "id  SPI ID number: 0 for SPI, 1 for HSPI  mode  select master or slave mode  spi.MASTER  spi.SLAVE  -  not supported currently    cpol  clock polarity selection  spi.CPOL_LOW    spi.CPOL_HIGH    cpha  clock phase selection  spi.CPHA_LOW  spi.CPHA_HIGH    databits  number of bits per data item 1 - 32  clock_div  SPI clock divider, f(SPI) = 80 MHz /  clock_div , 1 .. n (0 defaults to divider 8)  duplex_mode  duplex mode  spi.HALFDUPLEX  (default when omitted)  spi.FULLDUPLEX", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/spi/#returns_2", 
            "text": "Number: 1", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/spi/#example_1", 
            "text": "spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)\n-- we won't be using the HSPI /CS line, so disable it again\ngpio.mode(8, gpio.INPUT, gpio.PULLUP)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/spi/#low-level-hardware-functions", 
            "text": "The low level functions provide a hardware-centric API for application\nscenarios that need to excercise more complex SPI transactions. The\nprogramming model is built up around the HW send and receive buffers and SPI\ntransactions are initiated with full control over the hardware features.", 
            "title": "Low Level Hardware Functions"
        }, 
        {
            "location": "/en/modules/spi/#spiget_miso", 
            "text": "Extract data items from MISO buffer after  spi.transaction() .", 
            "title": "spi.get_miso()"
        }, 
        {
            "location": "/en/modules/spi/#syntax_3", 
            "text": "data1[, data2[, ..., datan]] = spi.get_miso(id, offset, bitlen, num)\nstring = spi.get_miso(id, num)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/spi/#parameters_3", 
            "text": "id  SPI ID number: 0 for SPI, 1 for HSPI  offset  bit offset into MISO buffer for first data item  bitlen  bit length of a single data item  num  number of data items to retrieve", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/spi/#returns_3", 
            "text": "num  data items or  string", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/spi/#see-also_2", 
            "text": "spi.transaction()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/spi/#spiset_mosi", 
            "text": "Insert data items into MOSI buffer for  spi.transaction() .", 
            "title": "spi.set_mosi()"
        }, 
        {
            "location": "/en/modules/spi/#syntax_4", 
            "text": "spi.set_mosi(id, offset, bitlen, data1[, data2[, ..., datan]])\nspi.set_mosi(id, string)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/spi/#parameters_4", 
            "text": "id  SPI ID number: 0 for SPI, 1 for HSPI  offset  bit offset into MOSI buffer for inserting data1 and subsequent items  bitlen  bit length of data1, data2, ...  data  data items where  bitlen  number of bits are considered for the transaction.  string  send data to be copied into MOSI buffer at offset 0, bit length 8", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/spi/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/spi/#see-also_3", 
            "text": "spi.transaction()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/spi/#spitransaction", 
            "text": "Start an SPI transaction, consisting of up to 5 phases:   Command  Address  MOSI  Dummy  MISO", 
            "title": "spi.transaction()"
        }, 
        {
            "location": "/en/modules/spi/#syntax_5", 
            "text": "spi.transaction(id, cmd_bitlen, cmd_data, addr_bitlen, addr_data, mosi_bitlen, dummy_bitlen, miso_bitlen)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/spi/#parameters_5", 
            "text": "id  SPI ID number: 0 for SPI, 1 for HSPI  cmd_bitlen  bit length of the command phase (0 - 16)  cmd_data  data for command phase  addr_bitlen  bit length for address phase (0 - 32)  addr_data  data for command phase  mosi_bitlen  bit length of the MOSI phase (0 - 512)  dummy_bitlen  bit length of the dummy phase (0 - 256)  miso_bitlen  bit length of the MISO phase (0 - 512) for half-duplex. Full-duplex mode is activated with a negative value.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/spi/#returns_5", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/spi/#see-also_4", 
            "text": "spi.set_mosi()  spi.get_miso()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/struct/", 
            "text": "Struct Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-02-13\n\n\nRoberto Ierusalimschy\n, \nPhilip Gladstone\n\n\nPhilip Gladstone\n\n\nstruct.c\n\n\n\n\n\n\n\n\nThis module offers basic facilities to convert Lua values to and from C structs. Its main functions are \nstruct.pack\n, which packs multiple Lua values into a struct-like string; and \nstruct.unpack\n, which unpacks multiple Lua values from a given struct-like string.\n\n\nThe first argument to both functions is a \nformat string\n, which describes the layout of the structure. The format string is a sequence of conversion elements, which respect the current endianess and the current alignment requirements. Initially, the current endianess is the machine's native endianness and the current alignment requirement is 1 (meaning no alignment at all). You can change these settings with appropriate directives in the format string.\n\n\nNote that the float and double conversions are only available with a floating point NodeMCU build.\n\n\nFormat String\n\n\nThe elements in the format string are as follows:\n\n\n\n\n\" \"\n (empty space) ignored.\n\n\n\"!n\"\n flag to set the current alignment requirement to \nn\n\n    (necessarily a power of 2); an absent \nn\n means the machine's native\n    alignment.\n\n\n\"\n\"\n flag to set mode to big endian.\n\n\n\"\n\"\n flag to set mode to little endian.\n\n\n\"x\"\n a padding zero byte with no corresponding Lua value.\n\n\n\"b\"\n a signed \nchar\n.\n\n\n\"B\"\n an unsigned \nchar\n.\n\n\n\"h\"\n a signed \nshort\n (native size).\n\n\n\"H\"\n an unsigned \nshort\n (native size).\n\n\n\"l\"\n a signed \nlong\n (native size).\n\n\n\"L\"\n an unsigned \nlong\n (native size).\n\n\n\"T\"\n a \nsize_t\n (native size).\n\n\n\"in\"\n a signed integer with \nn\n bytes. An absent \nn\n means the\n    native size of an \nint\n.\n\n\n\"In\"\n like \n\"in\"\n but unsigned.\n\n\n\"f\"\n a \nfloat\n (native size).\n\n\n\"d\"\n a \ndouble\n (native size).\n\n\n\"s\"\n a zero-terminated string.\n\n\n\"cn\"\n a sequence of exactly \nn\n chars corresponding to a single Lua\n    string. An absent \nn\n means 1. When packing, the given string must\n    have at least \nn\n characters (extra characters are discarded).\n\n\n\"c0\"\n this is like \n\"cn\"\n, except that the \nn\n is given by other\n    means: When packing, \nn\n is the length of the given string; when\n    unpacking, \nn\n is the value of the previous unpacked value (which\n    must be a number). In that case, this previous value is not\n    returned.\n\n\n\n\nExamples\n\n\nTo pack and unpack the structure\n\n\n    struct Str {\n      char b;\n      int i[4];\n    };\n\n\n\nyou can use the string \n\"\n!4biiii\"\n.\n\n\nTo pack a string with its length coded in its first byte, use the\nfollowing code:\n\n\n    x = struct.pack(\"Bc0\", string.len(s), s)\n\n\n\nTo unpack that string, do as follows:\n\n\n    s = struct.unpack(\"Bc0\", x)\n\n\n\nNote that the length (read by the element \n\"B\"\n) is not returned.\n\n\nTo pack a string in a fixed-width field of 10 characters padded with\nblanks, do as follows:\n\n\n    x = struct.pack(\"c10\", s .. string.rep(\" \", 10))\n\n\n\nstruct.pack()\n\n\nReturns a string containing the values \nd1\n, \nd2\n, etc. packed\naccording to the format string \nfmt\n.\n\n\nSyntax\n\n\nstruct.pack (fmt, d1, d2, ...)\n\n\nParameters\n\n\n\n\nfmt\n The format string in the format above\n\n\nd1\n The first data item to be packed\n\n\nd2\n The second data item to be packed etc.\n\n\n\n\nReturns\n\n\nThe packed string.\n\n\nExample\n\n\ns = struct.pack(\nI\n, 0x41424344)\nprint(s)\n\n\n\n\nstruct.unpack()\n\n\nReturns the values packed in string \ns\n according to the format\nstring \nfmt\n. An optional \ni\n marks where in \ns\n to start reading\n(default is 1). After the read values, this function also returns\nthe index in \ns\n where it stopped reading, which is also where you\nshould start to read the rest of the string.\n\n\nSyntax\n\n\nstruct.unpack (fmt, s[, offset])\n\n\nParameters\n\n\n\n\nfmt\n The format string in the format above\n\n\ns\n The string holding the data to be unpacked\n\n\noffset\n The position to start in the string (default is 1)\n\n\n\n\nReturns\n\n\nAll the unpacked data.\n\n\nExample\n\n\nSuppose we have to decode a string \ns\n with an unknown number of\ndoubles; the end is marked by a zero value. We can use the following\ncode:\n\n\n    local a = {}\n    local i = 1         -- index where to read\n    while true do\n      local d\n      d, i = struct.unpack(\"d\", s, i)\n      if d == 0 then break end\n      a[#a + 1] = d\n    end\n\n\n\nstruct.size()\n\n\nReturns the size of a string formatted according to the format\nstring \nfmt\n. The format string should contain neither the option\n\ns\n nor the option \nc0\n.\n\n\nSyntax\n\n\nstruct.size (fmt)\n\n\nParameters\n\n\n\n\nfmt\n The format string in the format above\n\n\n\n\nReturns\n\n\nThe size of the string that would be output in a pack operation with this format string.\n\n\nExample\n\n\nprint(struct.size(\ni\n))\n\n\n\n\nThis prints the size of the native integer type.\n\n\nLicense\n\n\nThis package is distributed under the MIT license. See copyright notice\nat the end of file \nstruct.c\n.", 
            "title": "struct"
        }, 
        {
            "location": "/en/modules/struct/#struct-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-02-13  Roberto Ierusalimschy ,  Philip Gladstone  Philip Gladstone  struct.c     This module offers basic facilities to convert Lua values to and from C structs. Its main functions are  struct.pack , which packs multiple Lua values into a struct-like string; and  struct.unpack , which unpacks multiple Lua values from a given struct-like string.  The first argument to both functions is a  format string , which describes the layout of the structure. The format string is a sequence of conversion elements, which respect the current endianess and the current alignment requirements. Initially, the current endianess is the machine's native endianness and the current alignment requirement is 1 (meaning no alignment at all). You can change these settings with appropriate directives in the format string.  Note that the float and double conversions are only available with a floating point NodeMCU build.", 
            "title": "Struct Module"
        }, 
        {
            "location": "/en/modules/struct/#format-string", 
            "text": "The elements in the format string are as follows:   \" \"  (empty space) ignored.  \"!n\"  flag to set the current alignment requirement to  n \n    (necessarily a power of 2); an absent  n  means the machine's native\n    alignment.  \" \"  flag to set mode to big endian.  \" \"  flag to set mode to little endian.  \"x\"  a padding zero byte with no corresponding Lua value.  \"b\"  a signed  char .  \"B\"  an unsigned  char .  \"h\"  a signed  short  (native size).  \"H\"  an unsigned  short  (native size).  \"l\"  a signed  long  (native size).  \"L\"  an unsigned  long  (native size).  \"T\"  a  size_t  (native size).  \"in\"  a signed integer with  n  bytes. An absent  n  means the\n    native size of an  int .  \"In\"  like  \"in\"  but unsigned.  \"f\"  a  float  (native size).  \"d\"  a  double  (native size).  \"s\"  a zero-terminated string.  \"cn\"  a sequence of exactly  n  chars corresponding to a single Lua\n    string. An absent  n  means 1. When packing, the given string must\n    have at least  n  characters (extra characters are discarded).  \"c0\"  this is like  \"cn\" , except that the  n  is given by other\n    means: When packing,  n  is the length of the given string; when\n    unpacking,  n  is the value of the previous unpacked value (which\n    must be a number). In that case, this previous value is not\n    returned.", 
            "title": "Format String"
        }, 
        {
            "location": "/en/modules/struct/#examples", 
            "text": "To pack and unpack the structure      struct Str {\n      char b;\n      int i[4];\n    };  you can use the string  \" !4biiii\" .  To pack a string with its length coded in its first byte, use the\nfollowing code:      x = struct.pack(\"Bc0\", string.len(s), s)  To unpack that string, do as follows:      s = struct.unpack(\"Bc0\", x)  Note that the length (read by the element  \"B\" ) is not returned.  To pack a string in a fixed-width field of 10 characters padded with\nblanks, do as follows:      x = struct.pack(\"c10\", s .. string.rep(\" \", 10))", 
            "title": "Examples"
        }, 
        {
            "location": "/en/modules/struct/#structpack", 
            "text": "Returns a string containing the values  d1 ,  d2 , etc. packed\naccording to the format string  fmt .", 
            "title": "struct.pack()"
        }, 
        {
            "location": "/en/modules/struct/#syntax", 
            "text": "struct.pack (fmt, d1, d2, ...)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/struct/#parameters", 
            "text": "fmt  The format string in the format above  d1  The first data item to be packed  d2  The second data item to be packed etc.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/struct/#returns", 
            "text": "The packed string.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/struct/#example", 
            "text": "s = struct.pack( I , 0x41424344)\nprint(s)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/struct/#structunpack", 
            "text": "Returns the values packed in string  s  according to the format\nstring  fmt . An optional  i  marks where in  s  to start reading\n(default is 1). After the read values, this function also returns\nthe index in  s  where it stopped reading, which is also where you\nshould start to read the rest of the string.", 
            "title": "struct.unpack()"
        }, 
        {
            "location": "/en/modules/struct/#syntax_1", 
            "text": "struct.unpack (fmt, s[, offset])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/struct/#parameters_1", 
            "text": "fmt  The format string in the format above  s  The string holding the data to be unpacked  offset  The position to start in the string (default is 1)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/struct/#returns_1", 
            "text": "All the unpacked data.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/struct/#example_1", 
            "text": "Suppose we have to decode a string  s  with an unknown number of\ndoubles; the end is marked by a zero value. We can use the following\ncode:      local a = {}\n    local i = 1         -- index where to read\n    while true do\n      local d\n      d, i = struct.unpack(\"d\", s, i)\n      if d == 0 then break end\n      a[#a + 1] = d\n    end", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/struct/#structsize", 
            "text": "Returns the size of a string formatted according to the format\nstring  fmt . The format string should contain neither the option s  nor the option  c0 .", 
            "title": "struct.size()"
        }, 
        {
            "location": "/en/modules/struct/#syntax_2", 
            "text": "struct.size (fmt)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/struct/#parameters_2", 
            "text": "fmt  The format string in the format above", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/struct/#returns_2", 
            "text": "The size of the string that would be output in a pack operation with this format string.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/struct/#example_2", 
            "text": "print(struct.size( i ))  This prints the size of the native integer type.", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/struct/#license", 
            "text": "This package is distributed under the MIT license. See copyright notice\nat the end of file  struct.c .", 
            "title": "License"
        }, 
        {
            "location": "/en/modules/switec/", 
            "text": "Switec Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-06-26\n\n\nPhilip Gladstone\n\n\nPhilip Gladstone\n\n\nswitec.c\n\n\n\n\n\n\n\n\nThis module controls a \nSwitec X.27\n (or compatible) instrument stepper motor. These are the \nstepper motors that are used in modern automotive instrument clusters. They are incredibly cheap\nand can be found at your favorite auction site or Chinese shopping site. There are varieties\nwhich are dual axis -- i.e. have two stepper motors driving two concentric shafts so you \ncan mount two needles from the same axis.\n\n\nThese motors run off 5V (some may work off 3.3V). They draw under 20mA and are designed to be\ndriven directly from MCU pins. Since the nodemcu runs at 3.3V, a level translator is required.\nAn octal translator like the \n74LVC4245A\n can perfom this translation. It also includes all the\nprotection diodes required. \n\n\nThese motors can be driven off three pins, with \npin2\n and \npin3\n being the same GPIO pin. \nIf the motor is directly connected to the MCU, then the current load is doubled and may exceed\nthe maximum ratings. If, however, a driver chip is being used, then the load on the MCU is negligible\nand the same MCU pin can be connected to two driver pins. In order to do this, just specify\nthe same pin for \npin2\n and \npin3\n.\n\n\nThese motors do not have absolute positioning, but come with stops at both ends of the range.\nThe startup procedure is to drive the motor anti-clockwise until it is guaranteed that the needle\nis on the step. Then this point can be set as zero. It is important not to let the motor\nrun into the endstops during normal operation as this will make the pointing inaccurate. \nThis module does not enforce any range limiting.\n\n\n\n\nImportant\n\n\nThis module uses the hardware timer interrupt and hence it cannot be used at the same time as the PWM module. Both modules can be compiled into the same firmware image, but an application can only use one. It may be possible for an application to alternate between \nswitec\n and \npwm\n, but care must be taken.\n\n\n\n\nswitec.setup()\n\n\nInitialize the nodemcu to talk to a switec X.27 or compatible instrument stepper motor. The default\nslew rate is set so that it should work for most motors. Some motors can run at 600 degress per second. \n\n\nSyntax\n\n\nswitec.setup(channel, pin1, pin2, pin3, pin4 [, maxDegPerSec])\n\n\nParameters\n\n\n\n\nchannel\n The switec module supports three stepper motors. The channel is either 0, 1 or 2.\n\n\npin1\n This is a GPIO number and connects to pin 1 on the stepper.\n\n\npin2\n This is a GPIO number and connects to pin 2 on the stepper.\n\n\npin3\n This is a GPIO number and connects to pin 3 on the stepper.\n\n\npin4\n This is a GPIO number and connects to pin 4 on the stepper.\n\n\nmaxDegPerSec\n (optional) This can set to limit the maximum slew rate. The default is 400 degrees per second.\n\n\n\n\nReturns\n\n\nNothing. If the arguments are in error, or the operation cannot be completed, then an error is thrown.\n\n\nNote\n\n\nOnce a channel is setup, it cannot be re-setup until the needle has stopped moving. \n\n\nExample\n\n\nswitec.setup(0, 5, 6, 7, 8)\n\n\n\n\nswitec.moveto()\n\n\nStarts the needle moving to the specified position. If the needle is already moving, then the current\nmotion is cancelled, and the needle will move to the new position. It is possible to get a callback\nwhen the needle stops moving. This is not normally required as multiple \nmoveto\n operations can\nbe issued in quick succession. During the initial calibration, it is important. Note that the \ncallback is not guaranteed to be called -- it is possible that the needle never stops at the\ntarget location before another \nmoveto\n operation is triggered.\n\n\nSyntax\n\n\nswitec.moveto(channel, position[, stoppedCallback)\n\n\nParameters\n\n\n\n\nchannel\n The switec module supports three stepper motors. The channel is either 0, 1 or 2.\n\n\nposition\n The position (number of steps clockwise) to move the needle. Typically in the range 0 to around 1000.\n\n\nstoppedCallback\n (optional) callback to be invoked when the needle stops moving.\n\n\n\n\nErrors\n\n\nThe channel must have been setup, otherwise an error is thrown.\n\n\nExample\n\n\nswitec.moveto(0, 1000, function ()\n    switec.moveto(0, 0)\nend)\n\n\n\n\nswitec.reset()\n\n\nThis sets the current position of the needle as being zero. The needle must be stationary.\n\n\nSyntax\n\n\nswitec.reset(channel)\n\n\nParameters\n\n\n\n\nchannel\n The switec module supports three stepper motors. The channel is either 0, 1 or 2.\n\n\n\n\nErrors\n\n\nThe channel must have been setup and the needle must not be moving, otherwise an error is thrown.\n\n\nswitec.getpos()\n\n\nGets the current position of the needle and whether it is moving.\n\n\nSyntax\n\n\nswitec.getpos(channel)\n\n\nParameters\n\n\n\n\nchannel\n The switec module supports three stepper motors. The channel is either 0, 1 or 2.\n\n\n\n\nReturns\n\n\n\n\nposition\n the current position of the needle\n\n\nmoving\n 0 if the needle is stationary. 1 for clockwise, -1 for anti-clockwise.\n\n\n\n\nswitec.close()\n\n\nReleases the resources associated with the stepper.\n\n\nSyntax\n\n\nswitec.close(channel)\n\n\nParameters\n\n\n\n\nchannel\n The switec module supports three stepper motors. The channel is either 0, 1 or 2.\n\n\n\n\nErrors\n\n\nThe needle must not be moving, otherwise an error is thrown.\n\n\nCalibration\n\n\nIn order to set the zero point correctly, the needle should be driven anti-clockwise until\nit runs into the end stop. Then the zero point can be set. The value of -1000 is used as that is\nlarger than the range of the motor -- i.e. it drives anti-clockwise through the entire range and \nonto the end stop.\n\n\nswitec.setup(0, 5,6,7,8)\ncalibration = true\nswitec.moveto(0, -1000, function() \n  switec.reset(0)\n  calibration = false\nend)\n\n\n\nOther \nmoveto\n operations should not be performed while \ncalibration\n is set.", 
            "title": "switec"
        }, 
        {
            "location": "/en/modules/switec/#switec-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-06-26  Philip Gladstone  Philip Gladstone  switec.c     This module controls a  Switec X.27  (or compatible) instrument stepper motor. These are the \nstepper motors that are used in modern automotive instrument clusters. They are incredibly cheap\nand can be found at your favorite auction site or Chinese shopping site. There are varieties\nwhich are dual axis -- i.e. have two stepper motors driving two concentric shafts so you \ncan mount two needles from the same axis.  These motors run off 5V (some may work off 3.3V). They draw under 20mA and are designed to be\ndriven directly from MCU pins. Since the nodemcu runs at 3.3V, a level translator is required.\nAn octal translator like the  74LVC4245A  can perfom this translation. It also includes all the\nprotection diodes required.   These motors can be driven off three pins, with  pin2  and  pin3  being the same GPIO pin. \nIf the motor is directly connected to the MCU, then the current load is doubled and may exceed\nthe maximum ratings. If, however, a driver chip is being used, then the load on the MCU is negligible\nand the same MCU pin can be connected to two driver pins. In order to do this, just specify\nthe same pin for  pin2  and  pin3 .  These motors do not have absolute positioning, but come with stops at both ends of the range.\nThe startup procedure is to drive the motor anti-clockwise until it is guaranteed that the needle\nis on the step. Then this point can be set as zero. It is important not to let the motor\nrun into the endstops during normal operation as this will make the pointing inaccurate. \nThis module does not enforce any range limiting.   Important  This module uses the hardware timer interrupt and hence it cannot be used at the same time as the PWM module. Both modules can be compiled into the same firmware image, but an application can only use one. It may be possible for an application to alternate between  switec  and  pwm , but care must be taken.", 
            "title": "Switec Module"
        }, 
        {
            "location": "/en/modules/switec/#switecsetup", 
            "text": "Initialize the nodemcu to talk to a switec X.27 or compatible instrument stepper motor. The default\nslew rate is set so that it should work for most motors. Some motors can run at 600 degress per second.", 
            "title": "switec.setup()"
        }, 
        {
            "location": "/en/modules/switec/#syntax", 
            "text": "switec.setup(channel, pin1, pin2, pin3, pin4 [, maxDegPerSec])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/switec/#parameters", 
            "text": "channel  The switec module supports three stepper motors. The channel is either 0, 1 or 2.  pin1  This is a GPIO number and connects to pin 1 on the stepper.  pin2  This is a GPIO number and connects to pin 2 on the stepper.  pin3  This is a GPIO number and connects to pin 3 on the stepper.  pin4  This is a GPIO number and connects to pin 4 on the stepper.  maxDegPerSec  (optional) This can set to limit the maximum slew rate. The default is 400 degrees per second.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/switec/#returns", 
            "text": "Nothing. If the arguments are in error, or the operation cannot be completed, then an error is thrown.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/switec/#note", 
            "text": "Once a channel is setup, it cannot be re-setup until the needle has stopped moving.", 
            "title": "Note"
        }, 
        {
            "location": "/en/modules/switec/#example", 
            "text": "switec.setup(0, 5, 6, 7, 8)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/switec/#switecmoveto", 
            "text": "Starts the needle moving to the specified position. If the needle is already moving, then the current\nmotion is cancelled, and the needle will move to the new position. It is possible to get a callback\nwhen the needle stops moving. This is not normally required as multiple  moveto  operations can\nbe issued in quick succession. During the initial calibration, it is important. Note that the \ncallback is not guaranteed to be called -- it is possible that the needle never stops at the\ntarget location before another  moveto  operation is triggered.", 
            "title": "switec.moveto()"
        }, 
        {
            "location": "/en/modules/switec/#syntax_1", 
            "text": "switec.moveto(channel, position[, stoppedCallback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/switec/#parameters_1", 
            "text": "channel  The switec module supports three stepper motors. The channel is either 0, 1 or 2.  position  The position (number of steps clockwise) to move the needle. Typically in the range 0 to around 1000.  stoppedCallback  (optional) callback to be invoked when the needle stops moving.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/switec/#errors", 
            "text": "The channel must have been setup, otherwise an error is thrown.", 
            "title": "Errors"
        }, 
        {
            "location": "/en/modules/switec/#example_1", 
            "text": "switec.moveto(0, 1000, function ()\n    switec.moveto(0, 0)\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/switec/#switecreset", 
            "text": "This sets the current position of the needle as being zero. The needle must be stationary.", 
            "title": "switec.reset()"
        }, 
        {
            "location": "/en/modules/switec/#syntax_2", 
            "text": "switec.reset(channel)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/switec/#parameters_2", 
            "text": "channel  The switec module supports three stepper motors. The channel is either 0, 1 or 2.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/switec/#errors_1", 
            "text": "The channel must have been setup and the needle must not be moving, otherwise an error is thrown.", 
            "title": "Errors"
        }, 
        {
            "location": "/en/modules/switec/#switecgetpos", 
            "text": "Gets the current position of the needle and whether it is moving.", 
            "title": "switec.getpos()"
        }, 
        {
            "location": "/en/modules/switec/#syntax_3", 
            "text": "switec.getpos(channel)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/switec/#parameters_3", 
            "text": "channel  The switec module supports three stepper motors. The channel is either 0, 1 or 2.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/switec/#returns_1", 
            "text": "position  the current position of the needle  moving  0 if the needle is stationary. 1 for clockwise, -1 for anti-clockwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/switec/#switecclose", 
            "text": "Releases the resources associated with the stepper.", 
            "title": "switec.close()"
        }, 
        {
            "location": "/en/modules/switec/#syntax_4", 
            "text": "switec.close(channel)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/switec/#parameters_4", 
            "text": "channel  The switec module supports three stepper motors. The channel is either 0, 1 or 2.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/switec/#errors_2", 
            "text": "The needle must not be moving, otherwise an error is thrown.", 
            "title": "Errors"
        }, 
        {
            "location": "/en/modules/switec/#calibration", 
            "text": "In order to set the zero point correctly, the needle should be driven anti-clockwise until\nit runs into the end stop. Then the zero point can be set. The value of -1000 is used as that is\nlarger than the range of the motor -- i.e. it drives anti-clockwise through the entire range and \nonto the end stop.  switec.setup(0, 5,6,7,8)\ncalibration = true\nswitec.moveto(0, -1000, function() \n  switec.reset(0)\n  calibration = false\nend)  Other  moveto  operations should not be performed while  calibration  is set.", 
            "title": "Calibration"
        }, 
        {
            "location": "/en/modules/tcs34725/", 
            "text": "TCS34725 module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2017-04-02\n\n\ntjhowse\n\n\ntjhowse\n\n\ntcs34725.c\n\n\n\n\n\n\n\n\nThis module provides a simple interface to \nTCS34725 colour/light sensors\n (Adafruit).\n\n\nNote that you must call \nsetup()\n before you can start reading values!\n\n\ntcs34725.setup()\n\n\nsetupializes module. setupialization is mandatory before values can be read.\n\n\nSyntax\n\n\ntcs34725.setup()\n\n\nReturns\n\n\n0\n if setup has failed (no sensor connected?), \n1\n if sensor is TCS34725\n\n\nExample\n\n\ntcs34725.setup()\ntcs34725.enable(function()\n    print(\nTCS34275 Enabled\n)\n    clear,red,green,blue=tcs34725.raw()\nend)\n\n\n\n\ntcs34725.enable(function())\n\n\nEnables the sensor. Can be used to wake up after a disable.\n\n\nSyntax\n\n\ntcs34725.enable(function()\n    print(\nTCS34275 Enabled\n)\n    clear,red,green,blue=tcs34725.raw()\nend)\n\n\n\n\nParameters\n\n\nA function called when the sensor has finished initialising.\n\n\nReturns\n\n\n0\n\n\ntcs34725.disable()\n\n\nDisables the sensor. Enables a low-power sleep mode.\n\n\nSyntax\n\n\ntcs34725.disable()\n\n\nReturns\n\n\n0\n\n\ntcs34725.raw()\n\n\nReads the clear, red, green and blue values from the sensor.\n\n\nSyntax\n\n\nclear,red,green,blue=tcs34725.raw()\n\n\nReturns\n\n\nclear, red, green, blue in uint16_t.\n\n\ntcs34725.setGain()\n\n\nSets the gain of the sensor. Must be called after the sensor is enabled.\n\n\nSyntax\n\n\ntcs34725.setGain(gain)\n\n\nParameters\n\n\n\n\n\n\n\n\ngain\n\n\nGain\n\n\n\n\n\n\n\n\n\n\n0x00\n\n\nTCS34725_GAIN_1X\n\n\n\n\n\n\n0x01\n\n\nTCS34725_GAIN_4X\n\n\n\n\n\n\n0x02\n\n\nTCS34725_GAIN_16X\n\n\n\n\n\n\n0x03\n\n\nTCS34725_GAIN_60X\n\n\n\n\n\n\n\n\nReturns\n\n\n0\n\n\ntcs34725.setIntegrationTime()\n\n\nSets the integration time of the sensor. Must be called after the sensor is enabled.\n\n\nSyntax\n\n\ntcs34725.setIntegrationTime(time)\n\n\nParameters\n\n\n\n\n\n\n\n\ntime\n\n\nGain\n\n\n\n\n\n\n\n\n\n\n0xFF\n\n\nTCS34725_INTEGRATIONTIME_2_4MS\n\n\n\n\n\n\n0xF6\n\n\nTCS34725_INTEGRATIONTIME_24MS\n\n\n\n\n\n\n0xD5\n\n\nTCS34725_INTEGRATIONTIME_101MS\n\n\n\n\n\n\n0xC0\n\n\nTCS34725_INTEGRATIONTIME_154MS\n\n\n\n\n\n\n0x00\n\n\nTCS34725_INTEGRATIONTIME_700MS\n\n\n\n\n\n\n\n\nReturns\n\n\n0", 
            "title": "tcs34725"
        }, 
        {
            "location": "/en/modules/tcs34725/#tcs34725-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2017-04-02  tjhowse  tjhowse  tcs34725.c     This module provides a simple interface to  TCS34725 colour/light sensors  (Adafruit).  Note that you must call  setup()  before you can start reading values!", 
            "title": "TCS34725 module"
        }, 
        {
            "location": "/en/modules/tcs34725/#tcs34725setup", 
            "text": "setupializes module. setupialization is mandatory before values can be read.", 
            "title": "tcs34725.setup()"
        }, 
        {
            "location": "/en/modules/tcs34725/#syntax", 
            "text": "tcs34725.setup()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tcs34725/#returns", 
            "text": "0  if setup has failed (no sensor connected?),  1  if sensor is TCS34725", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tcs34725/#example", 
            "text": "tcs34725.setup()\ntcs34725.enable(function()\n    print( TCS34275 Enabled )\n    clear,red,green,blue=tcs34725.raw()\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tcs34725/#tcs34725enablefunction", 
            "text": "Enables the sensor. Can be used to wake up after a disable.", 
            "title": "tcs34725.enable(function())"
        }, 
        {
            "location": "/en/modules/tcs34725/#syntax_1", 
            "text": "tcs34725.enable(function()\n    print( TCS34275 Enabled )\n    clear,red,green,blue=tcs34725.raw()\nend)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tcs34725/#parameters", 
            "text": "A function called when the sensor has finished initialising.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tcs34725/#returns_1", 
            "text": "0", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tcs34725/#tcs34725disable", 
            "text": "Disables the sensor. Enables a low-power sleep mode.", 
            "title": "tcs34725.disable()"
        }, 
        {
            "location": "/en/modules/tcs34725/#syntax_2", 
            "text": "tcs34725.disable()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tcs34725/#returns_2", 
            "text": "0", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tcs34725/#tcs34725raw", 
            "text": "Reads the clear, red, green and blue values from the sensor.", 
            "title": "tcs34725.raw()"
        }, 
        {
            "location": "/en/modules/tcs34725/#syntax_3", 
            "text": "clear,red,green,blue=tcs34725.raw()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tcs34725/#returns_3", 
            "text": "clear, red, green, blue in uint16_t.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tcs34725/#tcs34725setgain", 
            "text": "Sets the gain of the sensor. Must be called after the sensor is enabled.", 
            "title": "tcs34725.setGain()"
        }, 
        {
            "location": "/en/modules/tcs34725/#syntax_4", 
            "text": "tcs34725.setGain(gain)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tcs34725/#parameters_1", 
            "text": "gain  Gain      0x00  TCS34725_GAIN_1X    0x01  TCS34725_GAIN_4X    0x02  TCS34725_GAIN_16X    0x03  TCS34725_GAIN_60X", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tcs34725/#returns_4", 
            "text": "0", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tcs34725/#tcs34725setintegrationtime", 
            "text": "Sets the integration time of the sensor. Must be called after the sensor is enabled.", 
            "title": "tcs34725.setIntegrationTime()"
        }, 
        {
            "location": "/en/modules/tcs34725/#syntax_5", 
            "text": "tcs34725.setIntegrationTime(time)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tcs34725/#parameters_2", 
            "text": "time  Gain      0xFF  TCS34725_INTEGRATIONTIME_2_4MS    0xF6  TCS34725_INTEGRATIONTIME_24MS    0xD5  TCS34725_INTEGRATIONTIME_101MS    0xC0  TCS34725_INTEGRATIONTIME_154MS    0x00  TCS34725_INTEGRATIONTIME_700MS", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tcs34725/#returns_5", 
            "text": "0", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/", 
            "text": "TLS Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-12-15\n\n\nPhoeniX\n\n\nPhoeniX\n\n\ntls.c\n\n\n\n\n\n\n\n\nSSL/TLS support\n\n\n\n\nAttention\n\n\nThe TLS module depends on the \nnet\n module, it is a required dependency.\n\n\n\n\nNodeMCU includes the open-source version of \nmbed TLS library\n. With the NodeMCU default configuration it supports \nTLS\n 1.0 / 1.1 / 1.2 and the most common cipher suites, including DH/ECDH. ECDSA-based cipher suites are disabled by default.\n\n\n\n\nTip\n\n\nThe complete configuration is stored in \nuser_mbedtls.h\n. This is the file to edit if you build your own firmware and want to change mbed TLS behavior.\n\n\n\n\nFor a list of features have a look at the \nmbed TLS features page\n.\n\n\nThis module handles certificate verification when SSL/TLS is in use.\n\n\ntls.createConnection()\n\n\nCreates TLS connection.\n\n\nSyntax\n\n\ntls.createConnection()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\ntls.socket sub module\n\n\nExample\n\n\ntls.createConnection()\n\n\n\n\ntls.socket Module\n\n\ntls.socket:close()\n\n\nCloses socket.\n\n\nSyntax\n\n\nclose()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\ntls.createConnection()\n\n\ntls.socket:connect()\n\n\nConnect to a remote server.\n\n\nSyntax\n\n\nconnect(port, ip|domain)\n\n\nParameters\n\n\n\n\nport\n port number\n\n\nip\n IP address or domain name string\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\ntls.socket:on()\n\n\ntls.socket:dns()\n\n\nProvides DNS resolution for a hostname.\n\n\nSyntax\n\n\ndns(domain, function(tls.socket, ip))\n\n\nParameters\n\n\n\n\ndomain\n domain name\n\n\nfunction(tls.socket, ip)\n callback function. The first parameter is the socket, the second parameter is the IP address as a string.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nsk = tls.createConnection()\nsk:dns(\ngoogle.com\n, function(conn, ip) print(ip) end)\nsk = nil\n\n\n\n\ntls.socket:getpeer()\n\n\nRetrieve port and ip of peer.\n\n\nSyntax\n\n\ngetpeer()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nip\n of peer\n\n\nport\n of peer\n\n\n\n\ntls.socket:hold()\n\n\nThrottle data reception by placing a request to block the TCP receive function. This request is not effective immediately, Espressif recommends to call it while reserving 5*1460 bytes of memory.\n\n\nSyntax\n\n\nhold()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\ntls.socket:unhold()\n\n\ntls.socket:on()\n\n\nRegister callback functions for specific events.\n\n\nSyntax\n\n\non(event, function())\n\n\nParameters\n\n\n\n\nevent\n string, which can be \"connection\", \"reconnection\", \"disconnection\", \"receive\" or \"sent\"\n\n\nfunction(tls.socket[, string])\n callback function. The first parameter is the socket.\nIf event is \"receive\", the second parameter is the received data as string.\nIf event is \"reconnection\", the second parameter is the reason of connection error (string).\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nsrv = tls.createConnection()\nsrv:on(\nreceive\n, function(sck, c) print(c) end)\nsrv:on(\nconnection\n, function(sck, c)\n  -- Wait for connection before sending.\n  sck:send(\nGET / HTTP/1.1\\r\\nHost: google.com\\r\\nConnection: keep-alive\\r\\nAccept: */*\\r\\n\\r\\n\n)\nend)\nsrv:connect(443,\ngoogle.com\n)\n\n\n\n\n\n\nNote\n\n\nThe \nreceive\n event is fired for every network frame! See details at \nnet.socket:on()\n.\n\n\n\n\nSee also\n\n\n\n\ntls.createConnection()\n\n\ntls.socket:hold()\n\n\n\n\ntls.socket:send()\n\n\nSends data to remote peer.\n\n\nSyntax\n\n\nsend(string)\n\n\nParameters\n\n\n\n\nstring\n data in string which will be sent to server\n\n\n\n\nReturns\n\n\nnil\n\n\nNote\n\n\nMultiple consecutive \nsend()\n calls aren't guaranteed to work (and often don't) as network requests are treated as separate tasks by the SDK. Instead, subscribe to the \"sent\" event on the socket and send additional data (or close) in that callback. See \n#730\n for details.\n\n\nSee also\n\n\ntls.socket:on()\n\n\ntls.socket:unhold()\n\n\nUnblock TCP receiving data by revocation of a preceding \nhold()\n.\n\n\nSyntax\n\n\nunhold()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\ntls.socket:hold()\n\n\ntls.cert Module\n\n\ntls.cert.verify()\n\n\nControls the vertificate verification process when the Nodemcu makes a secure connection.\n\n\nSyntax\n\n\ntls.cert.verify(enable)\n\n\ntls.cert.verify(pemdata)\n\n\nParameters\n\n\n\n\nenable\n A boolean which indicates whether verification should be enabled or not. The default at boot is \nfalse\n.\n\n\npemdata\n A string containing the CA certificate to use for verification.\n\n\n\n\nReturns\n\n\ntrue\n if it worked. \n\n\nCan throw a number of errors if invalid data is supplied.\n\n\nExample\n\n\nMake a secure https connection and verify that the certificate chain is valid.\n\n\ntls.cert.verify(true)\nhttp.get(\nhttps://example.com/info\n, nil, function (code, resp) print(code, resp) end)\n\n\n\n\nLoad a certificate into the flash chip and make a request. This is the \nstartssl\n root certificate. They provide free\ncertificates.\n\n\ntls.cert.verify([[\n-----BEGIN CERTIFICATE-----\nMIIHyTCCBbGgAwIBAgIBATANBgkqhkiG9w0BAQUFADB9MQswCQYDVQQGEwJJTDEW\nMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwg\nQ2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNh\ndGlvbiBBdXRob3JpdHkwHhcNMDYwOTE3MTk0NjM2WhcNMzYwOTE3MTk0NjM2WjB9\nMQswCQYDVQQGEwJJTDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMi\nU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3Rh\ncnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\nA4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul38kMKogZk\npMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf\nOQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/C\nJi/6tRYccjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYT\nKqi5pquDSR3l8u/d5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNi\nHzvEvqBTViVsUQn3qqvKv3b9bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMM\nAv+Z6+hsTXBbKWWc3apdzK8BMewM69KN6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w\n+2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHuEhANxjJ/GP/89PrNbpHoNkm+\nGkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZPV/+Qt+OR0t3vwmC3\nZzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOzEmDyei+B\n26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID\nAQABo4ICUjCCAk4wDAYDVR0TBAUwAwEB/zALBgNVHQ8EBAMCAa4wHQYDVR0OBBYE\nFE4L7xqkQFulF2mHMMo0aEPQQa7yMGQGA1UdHwRdMFswLKAqoCiGJmh0dHA6Ly9j\nZXJ0LnN0YXJ0Y29tLm9yZy9zZnNjYS1jcmwuY3JsMCugKaAnhiVodHRwOi8vY3Js\nLnN0YXJ0Y29tLm9yZy9zZnNjYS1jcmwuY3JsMIIBXQYDVR0gBIIBVDCCAVAwggFM\nBgsrBgEEAYG1NwEBATCCATswLwYIKwYBBQUHAgEWI2h0dHA6Ly9jZXJ0LnN0YXJ0\nY29tLm9yZy9wb2xpY3kucGRmMDUGCCsGAQUFBwIBFilodHRwOi8vY2VydC5zdGFy\ndGNvbS5vcmcvaW50ZXJtZWRpYXRlLnBkZjCB0AYIKwYBBQUHAgIwgcMwJxYgU3Rh\ncnQgQ29tbWVyY2lhbCAoU3RhcnRDb20pIEx0ZC4wAwIBARqBl0xpbWl0ZWQgTGlh\nYmlsaXR5LCByZWFkIHRoZSBzZWN0aW9uICpMZWdhbCBMaW1pdGF0aW9ucyogb2Yg\ndGhlIFN0YXJ0Q29tIENlcnRpZmljYXRpb24gQXV0aG9yaXR5IFBvbGljeSBhdmFp\nbGFibGUgYXQgaHR0cDovL2NlcnQuc3RhcnRjb20ub3JnL3BvbGljeS5wZGYwEQYJ\nYIZIAYb4QgEBBAQDAgAHMDgGCWCGSAGG+EIBDQQrFilTdGFydENvbSBGcmVlIFNT\nTCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTANBgkqhkiG9w0BAQUFAAOCAgEAFmyZ\n9GYMNPXQhV59CuzaEE44HF7fpiUFS5Eyweg78T3dRAlbB0mKKctmArexmvclmAk8\njhvh3TaHK0u7aNM5Zj2gJsfyOZEdUauCe37Vzlrk4gNXcGmXCPleWKYK34wGmkUW\nFjgKXlf2Ysd6AgXmvB618p70qSmD+LIU424oh0TDkBreOKk8rENNZEXO3SipXPJz\newT4F+irsfMuXGRuczE6Eri8sxHkfY+BUZo7jYn0TZNmezwD7dOaHZrzZVD1oNB1\nny+v8OqCQ5j4aZyJecRDjkZy42Q2Eq/3JR44iZB3fsNrarnDy0RLrHiQi+fHLB5L\nEUTINFInzQpdn4XBidUaePKVEFMy3YCEZnXZtWgo+2EuvoSoOMCZEoalHmdkrQYu\nL6lwhceWD3yJZfWOQ1QOq92lgDmUYMA0yZZwLKMS9R9Ie70cfmu3nZD0Ijuu+Pwq\nyvqCUqDvr0tVk+vBtfAii6w0TiYiBKGHLHVKt+V9E9e4DGTANtLJL4YSjCMJwRuC\nO3NJo2pXh5Tl1njFmUNj403gdy3hZZlyaQQaRwnmDwFWJPsfvw55qVguucQJAX6V\num0ABj6y6koQOdjQK/W/7HW/lwLFCRsI3FU34oH7N4RDYiDK51ZLZer+bMEkkySh\nNOsF/5oirpt9P/FlUQqmMGqz9IgcgA38corog14=\n-----END CERTIFICATE-----\n]])\n\nhttp.get(\nhttps://pskreporter.info/gen404\n, nil, function (code, resp) print(code, resp) end)\n\n\n\n\nNotes\n\n\nThe certificate needed for verification is stored in the flash chip. The \ntls.cert.verify\n call with \ntrue\n\nenables verification against the value stored in the flash. \n\n\nThe certificate can be loaded into the flash chip in two ways -- one at firmware build time, and the other at initial boot\nof the firmware. In order to load the certificate at build time, just place a file containing the CA certificate (in PEM format) \nat \nserver-ca.crt\n in the root of the nodemcu-firmware build tree. The build scripts will incorporate this into the resulting\nfirmware image.\n\n\nThe alternative approach is easier for development, and that is to supply the PEM data as a string value to \ntls.cert.verify\n. This\nwill store the certificate into the flash chip and turn on verification for that certificate. Subsequent boots of the nodemcu can then\nuse \ntls.cert.verify(true)\n and use the stored certificate.", 
            "title": "tls"
        }, 
        {
            "location": "/en/modules/tls/#tls-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-12-15  PhoeniX  PhoeniX  tls.c     SSL/TLS support   Attention  The TLS module depends on the  net  module, it is a required dependency.   NodeMCU includes the open-source version of  mbed TLS library . With the NodeMCU default configuration it supports  TLS  1.0 / 1.1 / 1.2 and the most common cipher suites, including DH/ECDH. ECDSA-based cipher suites are disabled by default.   Tip  The complete configuration is stored in  user_mbedtls.h . This is the file to edit if you build your own firmware and want to change mbed TLS behavior.   For a list of features have a look at the  mbed TLS features page .  This module handles certificate verification when SSL/TLS is in use.", 
            "title": "TLS Module"
        }, 
        {
            "location": "/en/modules/tls/#tlscreateconnection", 
            "text": "Creates TLS connection.", 
            "title": "tls.createConnection()"
        }, 
        {
            "location": "/en/modules/tls/#syntax", 
            "text": "tls.createConnection()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns", 
            "text": "tls.socket sub module", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#example", 
            "text": "tls.createConnection()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tls/#tlssocket-module", 
            "text": "", 
            "title": "tls.socket Module"
        }, 
        {
            "location": "/en/modules/tls/#tlssocketclose", 
            "text": "Closes socket.", 
            "title": "tls.socket:close()"
        }, 
        {
            "location": "/en/modules/tls/#syntax_1", 
            "text": "close()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#see-also", 
            "text": "tls.createConnection()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tls/#tlssocketconnect", 
            "text": "Connect to a remote server.", 
            "title": "tls.socket:connect()"
        }, 
        {
            "location": "/en/modules/tls/#syntax_2", 
            "text": "connect(port, ip|domain)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters_2", 
            "text": "port  port number  ip  IP address or domain name string", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#see-also_1", 
            "text": "tls.socket:on()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tls/#tlssocketdns", 
            "text": "Provides DNS resolution for a hostname.", 
            "title": "tls.socket:dns()"
        }, 
        {
            "location": "/en/modules/tls/#syntax_3", 
            "text": "dns(domain, function(tls.socket, ip))", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters_3", 
            "text": "domain  domain name  function(tls.socket, ip)  callback function. The first parameter is the socket, the second parameter is the IP address as a string.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#example_1", 
            "text": "sk = tls.createConnection()\nsk:dns( google.com , function(conn, ip) print(ip) end)\nsk = nil", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tls/#tlssocketgetpeer", 
            "text": "Retrieve port and ip of peer.", 
            "title": "tls.socket:getpeer()"
        }, 
        {
            "location": "/en/modules/tls/#syntax_4", 
            "text": "getpeer()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters_4", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns_4", 
            "text": "ip  of peer  port  of peer", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#tlssockethold", 
            "text": "Throttle data reception by placing a request to block the TCP receive function. This request is not effective immediately, Espressif recommends to call it while reserving 5*1460 bytes of memory.", 
            "title": "tls.socket:hold()"
        }, 
        {
            "location": "/en/modules/tls/#syntax_5", 
            "text": "hold()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters_5", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns_5", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#see-also_2", 
            "text": "tls.socket:unhold()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tls/#tlssocketon", 
            "text": "Register callback functions for specific events.", 
            "title": "tls.socket:on()"
        }, 
        {
            "location": "/en/modules/tls/#syntax_6", 
            "text": "on(event, function())", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters_6", 
            "text": "event  string, which can be \"connection\", \"reconnection\", \"disconnection\", \"receive\" or \"sent\"  function(tls.socket[, string])  callback function. The first parameter is the socket.\nIf event is \"receive\", the second parameter is the received data as string.\nIf event is \"reconnection\", the second parameter is the reason of connection error (string).", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns_6", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#example_2", 
            "text": "srv = tls.createConnection()\nsrv:on( receive , function(sck, c) print(c) end)\nsrv:on( connection , function(sck, c)\n  -- Wait for connection before sending.\n  sck:send( GET / HTTP/1.1\\r\\nHost: google.com\\r\\nConnection: keep-alive\\r\\nAccept: */*\\r\\n\\r\\n )\nend)\nsrv:connect(443, google.com )   Note  The  receive  event is fired for every network frame! See details at  net.socket:on() .", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tls/#see-also_3", 
            "text": "tls.createConnection()  tls.socket:hold()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tls/#tlssocketsend", 
            "text": "Sends data to remote peer.", 
            "title": "tls.socket:send()"
        }, 
        {
            "location": "/en/modules/tls/#syntax_7", 
            "text": "send(string)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters_7", 
            "text": "string  data in string which will be sent to server", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns_7", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#note", 
            "text": "Multiple consecutive  send()  calls aren't guaranteed to work (and often don't) as network requests are treated as separate tasks by the SDK. Instead, subscribe to the \"sent\" event on the socket and send additional data (or close) in that callback. See  #730  for details.", 
            "title": "Note"
        }, 
        {
            "location": "/en/modules/tls/#see-also_4", 
            "text": "tls.socket:on()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tls/#tlssocketunhold", 
            "text": "Unblock TCP receiving data by revocation of a preceding  hold() .", 
            "title": "tls.socket:unhold()"
        }, 
        {
            "location": "/en/modules/tls/#syntax_8", 
            "text": "unhold()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters_8", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns_8", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#see-also_5", 
            "text": "tls.socket:hold()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tls/#tlscert-module", 
            "text": "", 
            "title": "tls.cert Module"
        }, 
        {
            "location": "/en/modules/tls/#tlscertverify", 
            "text": "Controls the vertificate verification process when the Nodemcu makes a secure connection.", 
            "title": "tls.cert.verify()"
        }, 
        {
            "location": "/en/modules/tls/#syntax_9", 
            "text": "tls.cert.verify(enable)  tls.cert.verify(pemdata)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tls/#parameters_9", 
            "text": "enable  A boolean which indicates whether verification should be enabled or not. The default at boot is  false .  pemdata  A string containing the CA certificate to use for verification.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tls/#returns_9", 
            "text": "true  if it worked.   Can throw a number of errors if invalid data is supplied.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tls/#example_3", 
            "text": "Make a secure https connection and verify that the certificate chain is valid.  tls.cert.verify(true)\nhttp.get( https://example.com/info , nil, function (code, resp) print(code, resp) end)  Load a certificate into the flash chip and make a request. This is the  startssl  root certificate. They provide free\ncertificates.  tls.cert.verify([[\n-----BEGIN CERTIFICATE-----\nMIIHyTCCBbGgAwIBAgIBATANBgkqhkiG9w0BAQUFADB9MQswCQYDVQQGEwJJTDEW\nMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwg\nQ2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNh\ndGlvbiBBdXRob3JpdHkwHhcNMDYwOTE3MTk0NjM2WhcNMzYwOTE3MTk0NjM2WjB9\nMQswCQYDVQQGEwJJTDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMi\nU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3Rh\ncnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\nA4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul38kMKogZk\npMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf\nOQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/C\nJi/6tRYccjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYT\nKqi5pquDSR3l8u/d5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNi\nHzvEvqBTViVsUQn3qqvKv3b9bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMM\nAv+Z6+hsTXBbKWWc3apdzK8BMewM69KN6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w\n+2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHuEhANxjJ/GP/89PrNbpHoNkm+\nGkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZPV/+Qt+OR0t3vwmC3\nZzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOzEmDyei+B\n26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID\nAQABo4ICUjCCAk4wDAYDVR0TBAUwAwEB/zALBgNVHQ8EBAMCAa4wHQYDVR0OBBYE\nFE4L7xqkQFulF2mHMMo0aEPQQa7yMGQGA1UdHwRdMFswLKAqoCiGJmh0dHA6Ly9j\nZXJ0LnN0YXJ0Y29tLm9yZy9zZnNjYS1jcmwuY3JsMCugKaAnhiVodHRwOi8vY3Js\nLnN0YXJ0Y29tLm9yZy9zZnNjYS1jcmwuY3JsMIIBXQYDVR0gBIIBVDCCAVAwggFM\nBgsrBgEEAYG1NwEBATCCATswLwYIKwYBBQUHAgEWI2h0dHA6Ly9jZXJ0LnN0YXJ0\nY29tLm9yZy9wb2xpY3kucGRmMDUGCCsGAQUFBwIBFilodHRwOi8vY2VydC5zdGFy\ndGNvbS5vcmcvaW50ZXJtZWRpYXRlLnBkZjCB0AYIKwYBBQUHAgIwgcMwJxYgU3Rh\ncnQgQ29tbWVyY2lhbCAoU3RhcnRDb20pIEx0ZC4wAwIBARqBl0xpbWl0ZWQgTGlh\nYmlsaXR5LCByZWFkIHRoZSBzZWN0aW9uICpMZWdhbCBMaW1pdGF0aW9ucyogb2Yg\ndGhlIFN0YXJ0Q29tIENlcnRpZmljYXRpb24gQXV0aG9yaXR5IFBvbGljeSBhdmFp\nbGFibGUgYXQgaHR0cDovL2NlcnQuc3RhcnRjb20ub3JnL3BvbGljeS5wZGYwEQYJ\nYIZIAYb4QgEBBAQDAgAHMDgGCWCGSAGG+EIBDQQrFilTdGFydENvbSBGcmVlIFNT\nTCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTANBgkqhkiG9w0BAQUFAAOCAgEAFmyZ\n9GYMNPXQhV59CuzaEE44HF7fpiUFS5Eyweg78T3dRAlbB0mKKctmArexmvclmAk8\njhvh3TaHK0u7aNM5Zj2gJsfyOZEdUauCe37Vzlrk4gNXcGmXCPleWKYK34wGmkUW\nFjgKXlf2Ysd6AgXmvB618p70qSmD+LIU424oh0TDkBreOKk8rENNZEXO3SipXPJz\newT4F+irsfMuXGRuczE6Eri8sxHkfY+BUZo7jYn0TZNmezwD7dOaHZrzZVD1oNB1\nny+v8OqCQ5j4aZyJecRDjkZy42Q2Eq/3JR44iZB3fsNrarnDy0RLrHiQi+fHLB5L\nEUTINFInzQpdn4XBidUaePKVEFMy3YCEZnXZtWgo+2EuvoSoOMCZEoalHmdkrQYu\nL6lwhceWD3yJZfWOQ1QOq92lgDmUYMA0yZZwLKMS9R9Ie70cfmu3nZD0Ijuu+Pwq\nyvqCUqDvr0tVk+vBtfAii6w0TiYiBKGHLHVKt+V9E9e4DGTANtLJL4YSjCMJwRuC\nO3NJo2pXh5Tl1njFmUNj403gdy3hZZlyaQQaRwnmDwFWJPsfvw55qVguucQJAX6V\num0ABj6y6koQOdjQK/W/7HW/lwLFCRsI3FU34oH7N4RDYiDK51ZLZer+bMEkkySh\nNOsF/5oirpt9P/FlUQqmMGqz9IgcgA38corog14=\n-----END CERTIFICATE-----\n]])\n\nhttp.get( https://pskreporter.info/gen404 , nil, function (code, resp) print(code, resp) end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tls/#notes", 
            "text": "The certificate needed for verification is stored in the flash chip. The  tls.cert.verify  call with  true \nenables verification against the value stored in the flash.   The certificate can be loaded into the flash chip in two ways -- one at firmware build time, and the other at initial boot\nof the firmware. In order to load the certificate at build time, just place a file containing the CA certificate (in PEM format) \nat  server-ca.crt  in the root of the nodemcu-firmware build tree. The build scripts will incorporate this into the resulting\nfirmware image.  The alternative approach is easier for development, and that is to supply the PEM data as a string value to  tls.cert.verify . This\nwill store the certificate into the flash chip and turn on verification for that certificate. Subsequent boots of the nodemcu can then\nuse  tls.cert.verify(true)  and use the stored certificate.", 
            "title": "Notes"
        }, 
        {
            "location": "/en/modules/tm1829/", 
            "text": "TM1829 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-05-15\n\n\nSebastian Haas\n\n\nSebastian Haas\n\n\ntm1829.c\n\n\n\n\n\n\n\n\ntm1829 is a library to handle led strips using Titan Micro tm1829\nled controller.\n\n\nThe library uses any GPIO to bitstream the led control commands.\n\n\ntm1829.write()\n\n\nSend data to a led strip using native chip format.\n\n\nSyntax\n\n\ntm1829.write(string)\n\n\nParameters\n\n\n\n\nstring\n payload to be sent to one or more TM1829 leds.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\ntm1829.write(5, string.char(255,0,0,255,0,0)) -- turn the two first RGB leds to blue using GPIO 5", 
            "title": "tm1829"
        }, 
        {
            "location": "/en/modules/tm1829/#tm1829-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-05-15  Sebastian Haas  Sebastian Haas  tm1829.c     tm1829 is a library to handle led strips using Titan Micro tm1829\nled controller.  The library uses any GPIO to bitstream the led control commands.", 
            "title": "TM1829 Module"
        }, 
        {
            "location": "/en/modules/tm1829/#tm1829write", 
            "text": "Send data to a led strip using native chip format.", 
            "title": "tm1829.write()"
        }, 
        {
            "location": "/en/modules/tm1829/#syntax", 
            "text": "tm1829.write(string)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tm1829/#parameters", 
            "text": "string  payload to be sent to one or more TM1829 leds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tm1829/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tm1829/#example", 
            "text": "tm1829.write(5, string.char(255,0,0,255,0,0)) -- turn the two first RGB leds to blue using GPIO 5", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/", 
            "text": "Timer Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-12\n\n\nZeroday\n\n\ndnc40085\n\n\ntmr.c\n\n\n\n\n\n\n\n\nThe tmr module allows access to simple timers, the system counter and uptime.\n\n\nIt is aimed at setting up regularly occurring tasks, timing out operations, and provide low-resolution deltas.\n\n\nWhat the tmr module is \nnot\n however, is a time keeping module. While most timeouts are expressed in milliseconds or even microseconds, the accuracy is limited and compounding errors would lead to rather inaccurate time keeping. Consider using the \nrtctime\n module for \"wall clock\" time.\n\n\nNodeMCU provides 7 static timers, numbered 0-6, and dynamic timer creation function \ntmr.create()\n.\n\n\n\n\nAttention\n\n\nStatic timers are deprecated and will be removed later. Use the OO API initiated with \ntmr.create()\n.\n\n\n\n\ntmr.alarm()\n\n\nThis is a convenience function combining \ntmr.register()\n and \ntmr.start()\n into a single call.\n\n\nTo free up the resources with this timer when done using it, call \ntmr.unregister()\n on it. For one-shot timers this is not necessary, unless they were stopped before they expired.\n\n\nSyntax\n\n\ntmr.alarm([id/ref], interval_ms, mode, func())\n\n\nParameters\n\n\n\n\nid\n/\nref\n timer id (0-6) or object, obsolete for OO API (\u2192 \ntmr.create()\n)\n\n\ninterval_ms\n timer interval in milliseconds. Maximum value is 6870947 (1:54:30.947).\n\n\nmode\n timer mode:\n\n\ntmr.ALARM_SINGLE\n a one-shot alarm (and no need to call \ntmr.unregister()\n)\n\n\ntmr.ALARM_SEMI\n manually repeating alarm (call \ntmr.start()\n to restart)\n\n\ntmr.ALARM_AUTO\n automatically repeating alarm\n\n\n\n\n\n\nfunc(timer)\n callback function which is invoked with the timer object as an argument\n\n\n\n\nReturns\n\n\ntrue\n if the timer was started, \nfalse\n on error\n\n\nExample\n\n\nif not tmr.create():alarm(5000, tmr.ALARM_SINGLE, function()\n  print(\nhey there\n)\nend)\nthen\n  print(\nwhoopsie\n)\nend\n\n\n\n\nSee also\n\n\n\n\ntmr.create()\n\n\ntmr.register()\n\n\ntmr.start()\n\n\ntmr.unregister()\n\n\n\n\ntmr.create()\n\n\nCreates a dynamic timer object.\n\n\nDynamic timer can be used instead of numeric ID in control functions. Also can be controlled in object-oriented way.\n\n\nFunctions supported in timer object:\n\n\n\n\nt:alarm()\n\n\nt:interval()\n\n\nt:register()\n\n\nt:resume()\n\n\nt:start()\n\n\nt:state()\n\n\nt:stop()\n\n\nt:suspend()\n\n\nt:unregister()\n\n\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\ntimer\n object\n\n\nExample\n\n\nlocal mytimer = tmr.create()\n\n-- oo calling\nmytimer:register(5000, tmr.ALARM_SINGLE, function (t) print(\nexpired\n); t:unregister() end)\nmytimer:start()\n\n-- with self parameter\ntmr.register(mytimer, 5000, tmr.ALARM_SINGLE, function (t) print(\nexpired\n); tmr.unregister(t) end)\ntmr.start(mytimer)\n\n\n\n\ntmr.delay()\n\n\nBusyloops the processor for a specified number of microseconds.\n\n\nThis is in general a \nbad\n idea, because nothing else gets to run, and the networking stack (and other things) can fall over as a result. The only time \ntmr.delay()\n may be appropriate to use is if dealing with a peripheral device which needs a (very) brief delay between commands, or similar. \nUse with caution!\n\n\nAlso note that the actual amount of time delayed for may be noticeably greater, both as a result of timing inaccuracies as well as interrupts which may run during this time.\n\n\nSyntax\n\n\ntmr.delay(us)\n\n\nParameters\n\n\nus\n microseconds to busyloop for\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\ntmr.delay(100)\n\n\n\n\ntmr.interval()\n\n\nChanges a registered timer's expiry interval.\n\n\nSyntax\n\n\ntmr.interval([id/ref], interval_ms)\n\n\nParameters\n\n\n\n\nid\n/\nref\n timer id (0-6) or object, obsolete for OO API (\u2192 \ntmr.create()\n)\n\n\ninterval_ms\n new timer interval in milliseconds. Maximum value is 6870947 (1:54:30.947).\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nmytimer = tmr.create()\nmytimer:register(10000, tmr.ALARM_AUTO, function() print(\nhey there\n) end)\nmytimer:interval(3000) -- actually, 3 seconds is better!\nmytimer:start()\n\n\n\n\ntmr.now()\n\n\nReturns the system counter, which counts in microseconds. Limited to 31 bits, after that it wraps around back to zero. That is essential if you use this function to \ndebounce or throttle GPIO input\n.\n\n\nSyntax\n\n\ntmr.now()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nthe current value of the system counter\n\n\nExample\n\n\nprint(tmr.now())\nprint(tmr.now())\n\n\n\n\ntmr.register()\n\n\nConfigures a timer and registers the callback function to call on expiry.\n\n\nTo free up the resources with this timer when done using it, call \ntmr.unregister()\n on it. For one-shot timers this is not necessary, unless they were stopped before they expired.\n\n\nSyntax\n\n\ntmr.register([id/ref], interval_ms, mode, func())\n\n\nParameters\n\n\n\n\nid\n/\nref\n timer id (0-6) or object, obsolete for OO API (\u2192 \ntmr.create()\n)\n\n\ninterval_ms\n timer interval in milliseconds. Maximum value is 6870947 (1:54:30.947).\n\n\nmode\n timer mode:\n\n\ntmr.ALARM_SINGLE\n a one-shot alarm (and no need to call \ntmr.unregister()\n)\n\n\ntmr.ALARM_SEMI\n manually repeating alarm (call \ntmr.start()\n to restart)\n\n\ntmr.ALARM_AUTO\n automatically repeating alarm\n\n\n\n\n\n\nfunc(timer)\n callback function which is invoked with the timer object as an argument\n\n\n\n\nNote that registering does \nnot\n start the alarm.\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nmytimer = tmr.create()\nmytimer:register(5000, tmr.ALARM_SINGLE, function() print(\nhey there\n) end)\nmytimer:start()\n\n\n\n\nSee also\n\n\n\n\ntmr.create()\n\n\ntmr.alarm()\n\n\n\n\ntmr.resume()\n\n\nResume an individual timer.\n\n\nResumes a timer that has previously been suspended with either \ntmr.suspend\n or \ntmr.suspend_all\n \n\n\nSyntax\n\n\ntmr.resume(id/ref)\n\n\nParameters\n\n\nid/ref\n timer id (0-6) or object, obsolete for OO API (\u2192 \ntmr.create()\n)\n\n\nReturns\n\n\ntrue\n if timer was resumed successfully \n\n\nExample\n\n\n--resume timer mytimer\nmytimer:resume()\n\n--alternate metod\ntmr.resume(mytimer)\n\n\n\n\n\nSee also\n\n\n\n\ntmr.suspend()\n\n\ntmr.suspend_all()\n\n\ntmr.resume_all()\n\n\n\n\ntmr.resume_all()\n\n\nResume all timers.\n\n\nResumes all timers including those previously been suspended with either \ntmr.suspend\n or \ntmr.suspend_all\n \n\n\nSyntax\n\n\ntmr.resume_all()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\ntrue\n if timers were resumed successfully \n\n\nExample\n\n\n--resume all previously suspended timers\ntmr.resume_all()\n\n\n\n\n\nSee also\n\n\n\n\ntmr.suspend()\n\n\ntmr.suspend_all()\n\n\ntmr.resume()\n\n\n\n\ntmr.softwd()\n\n\nProvides a simple software watchdog, which needs to be re-armed or disabled before it expires, or the system will be restarted.\n\n\nSyntax\n\n\ntmr.softwd(timeout_s)\n\n\nParameters\n\n\ntimeout_s\n watchdog timeout, in seconds. To disable the watchdog, use -1 (or any other negative value).\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nfunction on_success_callback()\n  tmr.softwd(-1)\n  print(\nComplex task done, soft watchdog disabled!\n)\nend\n\ntmr.softwd(5)\n-- go off and attempt to do whatever might need a restart to recover from\ncomplex_stuff_which_might_never_call_the_callback(on_success_callback)\n\n\n\n\ntmr.start()\n\n\nStarts or restarts a previously configured timer.\n\n\nSyntax\n\n\ntmr.start([id/ref])\n\n\nParameters\n\n\nid\n/\nref\n timer id (0-6) or object, obsolete for OO API (\u2192 \ntmr.create()\n)\n\n\nReturns\n\n\ntrue\n if the timer was started, \nfalse\n on error\n\n\nExample\n\n\nmytimer = tmr.create()\nmytimer:register(5000, tmr.ALARM_SINGLE, function() print(\nhey there\n) end)\nif not mytimer:start() then print(\nuh oh\n) end\n\n\n\n\nSee also\n\n\n\n\ntmr.create()\n\n\ntmr.register()\n\n\ntmr.stop()\n\n\ntmr.unregister()\n\n\n\n\ntmr.state()\n\n\nChecks the state of a timer.\n\n\nSyntax\n\n\ntmr.state([id/ref])\n\n\nParameters\n\n\nid\n/\nref\n timer id (0-6) or object, obsolete for OO API (\u2192 \ntmr.create()\n)\n\n\nReturns\n\n\n(bool, int) or \nnil\n\n\nIf the specified timer is registered, returns whether it is currently started and its mode. If the timer is not registered, \nnil\n is returned.\n\n\nExample\n\n\nmytimer = tmr.create()\nprint(mytimer:state()) -- nil\nmytimer:register(5000, tmr.ALARM_SINGLE, function() print(\nhey there\n) end)\nrunning, mode = mytimer:state()\nprint(\nrunning: \n .. tostring(running) .. \n, mode: \n .. mode) -- running: false, mode: 0\n\n\n\n\ntmr.stop()\n\n\nStops a running timer, but does \nnot\n unregister it. A stopped timer can be restarted with \ntmr.start()\n.\n\n\nSyntax\n\n\ntmr.stop([id/ref])\n\n\nParameters\n\n\nid\n/\nref\n timer id (0-6) or object, obsolete for OO API (\u2192 \ntmr.create()\n)\n\n\nReturns\n\n\ntrue\n if the timer was stopped, \nfalse\n on error\n\n\nExample\n\n\nmytimer = tmr.create()\nif not mytimer:stop() then print(\ntimer not stopped, not registered?\n) end\n\n\n\n\nSee also\n\n\n\n\ntmr.register()\n\n\ntmr.stop()\n\n\ntmr.unregister()\n\n\n\n\ntmr.suspend()\n\n\nSuspend an armed timer. \n\n\n\n\nTimers can be suspended at any time after they are armed.\n\n\nIf a timer is rearmed with \ntmr.start\n or \ntmr.alarm\n any matching suspended timers will be discarded.\n\n\n\n\nSyntax\n\n\ntmr.suspend(id/ref)\n\n\nParameters\n\n\nid/ref\n timer id (0-6) or object, obsolete for OO API (\u2192 \ntmr.create()\n)\n\n\nReturns\n\n\ntrue\n if timer was resumed successfully \n\n\nExample\n\n\n--suspend timer mytimer\nmytimer:suspend()\n\n--alternate metod\ntmr.suspend(mytimer)\n\n\n\n\n\nSee also\n\n\n\n\ntmr.suspend_all()\n\n\ntmr.resume()\n\n\ntmr.resume_all()\n\n\n\n\ntmr.suspend_all()\n\n\nSuspend all currently armed timers. \n\n\n\n\nWarning\n\n\nThis function suspends ALL active timers, including any active timers started by the NodeMCU subsystem or other modules. this may cause parts of your program to stop functioning properly. \nUSE THIS FUNCTION AT YOUR OWN RISK!\n\n\n\n\nSyntax\n\n\ntmr.suspend_all()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\ntrue\n if timers were suspended successfully \n\n\nExample\n\n\n--suspend timer mytimer\ntmr.suspend_all()\n\n\n\n\n\nSee also\n\n\n\n\ntmr.suspendl()\n\n\ntmr.resume()\n\n\ntmr.resume_all()\n\n\n\n\ntmr.time()\n\n\nReturns the system uptime, in seconds. Limited to 31 bits, after that it wraps around back to zero.\n\n\nSyntax\n\n\ntmr.time()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nthe system uptime, in seconds, possibly wrapped around\n\n\nExample\n\n\nprint(\nUptime (probably):\n, tmr.time())\n\n\n\n\ntmr.unregister()\n\n\nStops the timer (if running) and unregisters the associated callback.\n\n\nThis isn't necessary for one-shot timers (\ntmr.ALARM_SINGLE\n), as those automatically unregister themselves when fired.\n\n\nSyntax\n\n\ntmr.unregister([id/ref])\n\n\nParameters\n\n\nid\n/\nref\n timer id (0-6) or object, obsolete for OO API (\u2192 \ntmr.create()\n)\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\ntmr.unregister(0)\n\n\n\n\nSee also\n\n\ntmr.register()\n\n\ntmr.wdclr()\n\n\nFeed the system watchdog.\n\n\nIn general, if you ever need to use this function, you are doing it wrong.\n\n\nThe event-driven model of NodeMCU means that there is no need to be sitting in hard loops waiting for things to occur. Rather, simply use the callbacks to get notified when somethings happens. With this approach, there should never be a need to manually feed the system watchdog.\n\n\nSyntax\n\n\ntmr.wdclr()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil", 
            "title": "tmr"
        }, 
        {
            "location": "/en/modules/tmr/#timer-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-12  Zeroday  dnc40085  tmr.c     The tmr module allows access to simple timers, the system counter and uptime.  It is aimed at setting up regularly occurring tasks, timing out operations, and provide low-resolution deltas.  What the tmr module is  not  however, is a time keeping module. While most timeouts are expressed in milliseconds or even microseconds, the accuracy is limited and compounding errors would lead to rather inaccurate time keeping. Consider using the  rtctime  module for \"wall clock\" time.  NodeMCU provides 7 static timers, numbered 0-6, and dynamic timer creation function  tmr.create() .   Attention  Static timers are deprecated and will be removed later. Use the OO API initiated with  tmr.create() .", 
            "title": "Timer Module"
        }, 
        {
            "location": "/en/modules/tmr/#tmralarm", 
            "text": "This is a convenience function combining  tmr.register()  and  tmr.start()  into a single call.  To free up the resources with this timer when done using it, call  tmr.unregister()  on it. For one-shot timers this is not necessary, unless they were stopped before they expired.", 
            "title": "tmr.alarm()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax", 
            "text": "tmr.alarm([id/ref], interval_ms, mode, func())", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters", 
            "text": "id / ref  timer id (0-6) or object, obsolete for OO API (\u2192  tmr.create() )  interval_ms  timer interval in milliseconds. Maximum value is 6870947 (1:54:30.947).  mode  timer mode:  tmr.ALARM_SINGLE  a one-shot alarm (and no need to call  tmr.unregister() )  tmr.ALARM_SEMI  manually repeating alarm (call  tmr.start()  to restart)  tmr.ALARM_AUTO  automatically repeating alarm    func(timer)  callback function which is invoked with the timer object as an argument", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns", 
            "text": "true  if the timer was started,  false  on error", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example", 
            "text": "if not tmr.create():alarm(5000, tmr.ALARM_SINGLE, function()\n  print( hey there )\nend)\nthen\n  print( whoopsie )\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#see-also", 
            "text": "tmr.create()  tmr.register()  tmr.start()  tmr.unregister()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tmr/#tmrcreate", 
            "text": "Creates a dynamic timer object.  Dynamic timer can be used instead of numeric ID in control functions. Also can be controlled in object-oriented way.  Functions supported in timer object:   t:alarm()  t:interval()  t:register()  t:resume()  t:start()  t:state()  t:stop()  t:suspend()  t:unregister()", 
            "title": "tmr.create()"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_1", 
            "text": "timer  object", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_1", 
            "text": "local mytimer = tmr.create()\n\n-- oo calling\nmytimer:register(5000, tmr.ALARM_SINGLE, function (t) print( expired ); t:unregister() end)\nmytimer:start()\n\n-- with self parameter\ntmr.register(mytimer, 5000, tmr.ALARM_SINGLE, function (t) print( expired ); tmr.unregister(t) end)\ntmr.start(mytimer)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#tmrdelay", 
            "text": "Busyloops the processor for a specified number of microseconds.  This is in general a  bad  idea, because nothing else gets to run, and the networking stack (and other things) can fall over as a result. The only time  tmr.delay()  may be appropriate to use is if dealing with a peripheral device which needs a (very) brief delay between commands, or similar.  Use with caution!  Also note that the actual amount of time delayed for may be noticeably greater, both as a result of timing inaccuracies as well as interrupts which may run during this time.", 
            "title": "tmr.delay()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_1", 
            "text": "tmr.delay(us)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_2", 
            "text": "us  microseconds to busyloop for", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_2", 
            "text": "tmr.delay(100)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#tmrinterval", 
            "text": "Changes a registered timer's expiry interval.", 
            "title": "tmr.interval()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_2", 
            "text": "tmr.interval([id/ref], interval_ms)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_3", 
            "text": "id / ref  timer id (0-6) or object, obsolete for OO API (\u2192  tmr.create() )  interval_ms  new timer interval in milliseconds. Maximum value is 6870947 (1:54:30.947).", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_3", 
            "text": "mytimer = tmr.create()\nmytimer:register(10000, tmr.ALARM_AUTO, function() print( hey there ) end)\nmytimer:interval(3000) -- actually, 3 seconds is better!\nmytimer:start()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#tmrnow", 
            "text": "Returns the system counter, which counts in microseconds. Limited to 31 bits, after that it wraps around back to zero. That is essential if you use this function to  debounce or throttle GPIO input .", 
            "title": "tmr.now()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_3", 
            "text": "tmr.now()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_4", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_4", 
            "text": "the current value of the system counter", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_4", 
            "text": "print(tmr.now())\nprint(tmr.now())", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#tmrregister", 
            "text": "Configures a timer and registers the callback function to call on expiry.  To free up the resources with this timer when done using it, call  tmr.unregister()  on it. For one-shot timers this is not necessary, unless they were stopped before they expired.", 
            "title": "tmr.register()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_4", 
            "text": "tmr.register([id/ref], interval_ms, mode, func())", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_5", 
            "text": "id / ref  timer id (0-6) or object, obsolete for OO API (\u2192  tmr.create() )  interval_ms  timer interval in milliseconds. Maximum value is 6870947 (1:54:30.947).  mode  timer mode:  tmr.ALARM_SINGLE  a one-shot alarm (and no need to call  tmr.unregister() )  tmr.ALARM_SEMI  manually repeating alarm (call  tmr.start()  to restart)  tmr.ALARM_AUTO  automatically repeating alarm    func(timer)  callback function which is invoked with the timer object as an argument   Note that registering does  not  start the alarm.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_5", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_5", 
            "text": "mytimer = tmr.create()\nmytimer:register(5000, tmr.ALARM_SINGLE, function() print( hey there ) end)\nmytimer:start()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#see-also_1", 
            "text": "tmr.create()  tmr.alarm()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tmr/#tmrresume", 
            "text": "Resume an individual timer.  Resumes a timer that has previously been suspended with either  tmr.suspend  or  tmr.suspend_all", 
            "title": "tmr.resume()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_5", 
            "text": "tmr.resume(id/ref)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_6", 
            "text": "id/ref  timer id (0-6) or object, obsolete for OO API (\u2192  tmr.create() )", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_6", 
            "text": "true  if timer was resumed successfully", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_6", 
            "text": "--resume timer mytimer\nmytimer:resume()\n\n--alternate metod\ntmr.resume(mytimer)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#see-also_2", 
            "text": "tmr.suspend()  tmr.suspend_all()  tmr.resume_all()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tmr/#tmrresume_all", 
            "text": "Resume all timers.  Resumes all timers including those previously been suspended with either  tmr.suspend  or  tmr.suspend_all", 
            "title": "tmr.resume_all()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_6", 
            "text": "tmr.resume_all()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_7", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_7", 
            "text": "true  if timers were resumed successfully", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_7", 
            "text": "--resume all previously suspended timers\ntmr.resume_all()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#see-also_3", 
            "text": "tmr.suspend()  tmr.suspend_all()  tmr.resume()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tmr/#tmrsoftwd", 
            "text": "Provides a simple software watchdog, which needs to be re-armed or disabled before it expires, or the system will be restarted.", 
            "title": "tmr.softwd()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_7", 
            "text": "tmr.softwd(timeout_s)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_8", 
            "text": "timeout_s  watchdog timeout, in seconds. To disable the watchdog, use -1 (or any other negative value).", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_8", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_8", 
            "text": "function on_success_callback()\n  tmr.softwd(-1)\n  print( Complex task done, soft watchdog disabled! )\nend\n\ntmr.softwd(5)\n-- go off and attempt to do whatever might need a restart to recover from\ncomplex_stuff_which_might_never_call_the_callback(on_success_callback)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#tmrstart", 
            "text": "Starts or restarts a previously configured timer.", 
            "title": "tmr.start()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_8", 
            "text": "tmr.start([id/ref])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_9", 
            "text": "id / ref  timer id (0-6) or object, obsolete for OO API (\u2192  tmr.create() )", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_9", 
            "text": "true  if the timer was started,  false  on error", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_9", 
            "text": "mytimer = tmr.create()\nmytimer:register(5000, tmr.ALARM_SINGLE, function() print( hey there ) end)\nif not mytimer:start() then print( uh oh ) end", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#see-also_4", 
            "text": "tmr.create()  tmr.register()  tmr.stop()  tmr.unregister()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tmr/#tmrstate", 
            "text": "Checks the state of a timer.", 
            "title": "tmr.state()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_9", 
            "text": "tmr.state([id/ref])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_10", 
            "text": "id / ref  timer id (0-6) or object, obsolete for OO API (\u2192  tmr.create() )", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_10", 
            "text": "(bool, int) or  nil  If the specified timer is registered, returns whether it is currently started and its mode. If the timer is not registered,  nil  is returned.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_10", 
            "text": "mytimer = tmr.create()\nprint(mytimer:state()) -- nil\nmytimer:register(5000, tmr.ALARM_SINGLE, function() print( hey there ) end)\nrunning, mode = mytimer:state()\nprint( running:   .. tostring(running) ..  , mode:   .. mode) -- running: false, mode: 0", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#tmrstop", 
            "text": "Stops a running timer, but does  not  unregister it. A stopped timer can be restarted with  tmr.start() .", 
            "title": "tmr.stop()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_10", 
            "text": "tmr.stop([id/ref])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_11", 
            "text": "id / ref  timer id (0-6) or object, obsolete for OO API (\u2192  tmr.create() )", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_11", 
            "text": "true  if the timer was stopped,  false  on error", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_11", 
            "text": "mytimer = tmr.create()\nif not mytimer:stop() then print( timer not stopped, not registered? ) end", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#see-also_5", 
            "text": "tmr.register()  tmr.stop()  tmr.unregister()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tmr/#tmrsuspend", 
            "text": "Suspend an armed timer.    Timers can be suspended at any time after they are armed.  If a timer is rearmed with  tmr.start  or  tmr.alarm  any matching suspended timers will be discarded.", 
            "title": "tmr.suspend()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_11", 
            "text": "tmr.suspend(id/ref)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_12", 
            "text": "id/ref  timer id (0-6) or object, obsolete for OO API (\u2192  tmr.create() )", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_12", 
            "text": "true  if timer was resumed successfully", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_12", 
            "text": "--suspend timer mytimer\nmytimer:suspend()\n\n--alternate metod\ntmr.suspend(mytimer)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#see-also_6", 
            "text": "tmr.suspend_all()  tmr.resume()  tmr.resume_all()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tmr/#tmrsuspend_all", 
            "text": "Suspend all currently armed timers.    Warning  This function suspends ALL active timers, including any active timers started by the NodeMCU subsystem or other modules. this may cause parts of your program to stop functioning properly. \nUSE THIS FUNCTION AT YOUR OWN RISK!", 
            "title": "tmr.suspend_all()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_12", 
            "text": "tmr.suspend_all()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_13", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_13", 
            "text": "true  if timers were suspended successfully", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_13", 
            "text": "--suspend timer mytimer\ntmr.suspend_all()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#see-also_7", 
            "text": "tmr.suspendl()  tmr.resume()  tmr.resume_all()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tmr/#tmrtime", 
            "text": "Returns the system uptime, in seconds. Limited to 31 bits, after that it wraps around back to zero.", 
            "title": "tmr.time()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_13", 
            "text": "tmr.time()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_14", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_14", 
            "text": "the system uptime, in seconds, possibly wrapped around", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_14", 
            "text": "print( Uptime (probably): , tmr.time())", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#tmrunregister", 
            "text": "Stops the timer (if running) and unregisters the associated callback.  This isn't necessary for one-shot timers ( tmr.ALARM_SINGLE ), as those automatically unregister themselves when fired.", 
            "title": "tmr.unregister()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_14", 
            "text": "tmr.unregister([id/ref])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_15", 
            "text": "id / ref  timer id (0-6) or object, obsolete for OO API (\u2192  tmr.create() )", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_15", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tmr/#example_15", 
            "text": "tmr.unregister(0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tmr/#see-also_8", 
            "text": "tmr.register()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/tmr/#tmrwdclr", 
            "text": "Feed the system watchdog.  In general, if you ever need to use this function, you are doing it wrong.  The event-driven model of NodeMCU means that there is no need to be sitting in hard loops waiting for things to occur. Rather, simply use the callbacks to get notified when somethings happens. With this approach, there should never be a need to manually feed the system watchdog.", 
            "title": "tmr.wdclr()"
        }, 
        {
            "location": "/en/modules/tmr/#syntax_15", 
            "text": "tmr.wdclr()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tmr/#parameters_16", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tmr/#returns_16", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tsl2561/", 
            "text": "TSL2561 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-08-22\n\n\nMichael Lucas\n\n\nMichael Lucas\n\n\ntsl2561.c\n\n\n\n\n\n\n\n\ntsl2561.getlux()\n\n\nReads sensor values from the device and returns calculated lux value.\n\n\nSyntax\n\n\ntsl2561.getlux()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nlux\n the calculated illuminance in lux (lx)\n\n\nstatus\n value indicating success or failure as explained below:\n\n\ntsl2561.TSL2561_OK\n\n\ntsl2561.TSL2561_ERROR_I2CINIT\n can't initialize I\u00b2C bus\n\n\ntsl2561.TSL2561_ERROR_I2CBUSY\n I\u00b2C bus busy\n\n\ntsl2561.TSL2561_ERROR_NOINIT\n initialize I\u00b2C bus before calling function\n\n\ntsl2561.TSL2561_ERROR_LAST\n\n\n\n\n\n\n\n\nExample\n\n\nstatus = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL)\n\nif status == tsl2561.TSL2561_OK then\n    lux = tsl2561.getlux()\n    print(\nIlluminance: \n..lux..\n lx\n) \nend\n\n\n\n\ntsl2561.getrawchannels()\n\n\nReads the device's 2 sensors and returns their values.\n\n\nSyntax\n\n\ntsl2561.getrawchannels()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nch0\n value of the broad spectrum sensor\n\n\nch1\n value of the IR sensor\n\n\nstatus\n value indicating success or failure as explained below:\n\n\ntsl2561.TSL2561_OK\n\n\ntsl2561.TSL2561_ERROR_I2CINIT\n can't initialize I\u00b2C bus\n\n\ntsl2561.TSL2561_ERROR_I2CBUSY\n I\u00b2C bus busy\n\n\ntsl2561.TSL2561_ERROR_NOINIT\n initialize I\u00b2C bus before calling function\n\n\ntsl2561.TSL2561_ERROR_LAST\n\n\n\n\n\n\n\n\nExample\n\n\nstatus = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL)\n\nif status == tsl2561.TSL2561_OK then\n    ch0, ch1 = tsl2561.getrawchannels()\n    print(\nRaw values: \n..ch0, ch1)\n    lux = tsl2561.getlux()\n    print(\nIlluminance: \n..lux..\n lx\n) \nend\n\n\n\n\ntsl2561.init()\n\n\nInitializes the device on pins sdapin \n sclpin. Optionally also configures the devices address and package. Default: address pin floating (0x39) and FN package.\n\n\nSyntax\n\n\ntsl2561.init(sdapin, sclpin[, address[, package]])\n\n\nParameters\n\n\n\n\nsdapin\n pin number of the device's I\u00b2C sda connection\n\n\nsclpin\n pin number of the device's I\u00b2C scl connection\n\n\naddress\n optional address of the device on the I\u00b2C bus\n\n\ntsl2561.ADDRESS_GND\n\n\ntsl2561.ADDRESS_FLOAT\n (default when omitted)\n\n\ntsl2561.ADDRESS_VDD\n\n\n\n\n\n\npackage\n optional device's package type (slight difference in lux calculation)\n\n\ntsl2561.PACKAGE_CS\n\n\ntsl2561.PACKAGE_T_FN_CL\n (default when omitted)\n\n\n\n\n\n\n\n\nReturns\n\n\nstatus\n value indicating success or failure as explained below:\n\n\n\n\ntsl2561.TSL2561_OK\n\n\ntsl2561.TSL2561_ERROR_I2CINIT\n can't initialize I\u00b2C bus\n\n\ntsl2561.TSL2561_ERROR_I2CBUSY\n I\u00b2C bus busy\n\n\ntsl2561.TSL2561_ERROR_NOINIT\n Initialize I\u00b2C bus before calling function\n\n\ntsl2561.TSL2561_ERROR_LAST\n\n\n\n\nExample\n\n\nstatus = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL)\nif status == tsl2561.TSL2561_OK then\n    lux = tsl2561.getlux()\n    print(\nIlluminance: \n..lux..\n lx\n) \nend\n\n\n\n\ntsl2561.settiming()\n\n\nSets the integration time and gain settings of the device. When \ntls2561.init()\n is called, these values default to 402 ms and no gain.\n\n\nSyntax\n\n\ntsl2561.settiming(integration, gain)\n\n\nParameters\n\n\n\n\nintegration\n sets the device's integration period. Valid options are:\n\n\ntsl2561.INTEGRATIONTIME_13MS\n\n\ntsl2561.INTEGRATIONTIME_101MS\n\n\ntsl2561.INTEGRATIONTIME_402MS\n (default when omitted)\n\n\n\n\n\n\ngain\n sets the device's gain. Valid options are:\n\n\ntsl2561.GAIN_1X\n (default when omitted)\n\n\ntsl2561.GAIN_16X\n\n\n\n\n\n\n\n\nReturns\n\n\nstatus\n value indicating success or failure as explained below:\n\n\n\n\ntsl2561.TSL2561_OK\n\n\ntsl2561.TSL2561_ERROR_I2CINIT\n can't initialize I\u00b2C bus\n\n\ntsl2561.TSL2561_ERROR_I2CBUSY\n I\u00b2C bus busy\n\n\ntsl2561.TSL2561_ERROR_NOINIT\n initialize I\u00b2C bus before calling function\n\n\ntsl2561.TSL2561_ERROR_LAST\n\n\n\n\nExample\n\n\nstatus = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL)\nif status == tsl2561.TSL2561_OK then\n    status = tsl2561.settiming(tsl2561.INTEGRATIONTIME_101MS, tsl2561.GAIN_16X)\nend\nif status == tsl2561.TSL2561_OK then\n    lux = tsl2561.getlux()\n    print(\nIlluminance: \n..lux..\n lx\n) \nend", 
            "title": "tsl2561"
        }, 
        {
            "location": "/en/modules/tsl2561/#tsl2561-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-08-22  Michael Lucas  Michael Lucas  tsl2561.c", 
            "title": "TSL2561 Module"
        }, 
        {
            "location": "/en/modules/tsl2561/#tsl2561getlux", 
            "text": "Reads sensor values from the device and returns calculated lux value.", 
            "title": "tsl2561.getlux()"
        }, 
        {
            "location": "/en/modules/tsl2561/#syntax", 
            "text": "tsl2561.getlux()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tsl2561/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tsl2561/#returns", 
            "text": "lux  the calculated illuminance in lux (lx)  status  value indicating success or failure as explained below:  tsl2561.TSL2561_OK  tsl2561.TSL2561_ERROR_I2CINIT  can't initialize I\u00b2C bus  tsl2561.TSL2561_ERROR_I2CBUSY  I\u00b2C bus busy  tsl2561.TSL2561_ERROR_NOINIT  initialize I\u00b2C bus before calling function  tsl2561.TSL2561_ERROR_LAST", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tsl2561/#example", 
            "text": "status = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL)\n\nif status == tsl2561.TSL2561_OK then\n    lux = tsl2561.getlux()\n    print( Illuminance:  ..lux..  lx ) \nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tsl2561/#tsl2561getrawchannels", 
            "text": "Reads the device's 2 sensors and returns their values.", 
            "title": "tsl2561.getrawchannels()"
        }, 
        {
            "location": "/en/modules/tsl2561/#syntax_1", 
            "text": "tsl2561.getrawchannels()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tsl2561/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tsl2561/#returns_1", 
            "text": "ch0  value of the broad spectrum sensor  ch1  value of the IR sensor  status  value indicating success or failure as explained below:  tsl2561.TSL2561_OK  tsl2561.TSL2561_ERROR_I2CINIT  can't initialize I\u00b2C bus  tsl2561.TSL2561_ERROR_I2CBUSY  I\u00b2C bus busy  tsl2561.TSL2561_ERROR_NOINIT  initialize I\u00b2C bus before calling function  tsl2561.TSL2561_ERROR_LAST", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tsl2561/#example_1", 
            "text": "status = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL)\n\nif status == tsl2561.TSL2561_OK then\n    ch0, ch1 = tsl2561.getrawchannels()\n    print( Raw values:  ..ch0, ch1)\n    lux = tsl2561.getlux()\n    print( Illuminance:  ..lux..  lx ) \nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tsl2561/#tsl2561init", 
            "text": "Initializes the device on pins sdapin   sclpin. Optionally also configures the devices address and package. Default: address pin floating (0x39) and FN package.", 
            "title": "tsl2561.init()"
        }, 
        {
            "location": "/en/modules/tsl2561/#syntax_2", 
            "text": "tsl2561.init(sdapin, sclpin[, address[, package]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tsl2561/#parameters_2", 
            "text": "sdapin  pin number of the device's I\u00b2C sda connection  sclpin  pin number of the device's I\u00b2C scl connection  address  optional address of the device on the I\u00b2C bus  tsl2561.ADDRESS_GND  tsl2561.ADDRESS_FLOAT  (default when omitted)  tsl2561.ADDRESS_VDD    package  optional device's package type (slight difference in lux calculation)  tsl2561.PACKAGE_CS  tsl2561.PACKAGE_T_FN_CL  (default when omitted)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tsl2561/#returns_2", 
            "text": "status  value indicating success or failure as explained below:   tsl2561.TSL2561_OK  tsl2561.TSL2561_ERROR_I2CINIT  can't initialize I\u00b2C bus  tsl2561.TSL2561_ERROR_I2CBUSY  I\u00b2C bus busy  tsl2561.TSL2561_ERROR_NOINIT  Initialize I\u00b2C bus before calling function  tsl2561.TSL2561_ERROR_LAST", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tsl2561/#example_2", 
            "text": "status = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL)\nif status == tsl2561.TSL2561_OK then\n    lux = tsl2561.getlux()\n    print( Illuminance:  ..lux..  lx ) \nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/tsl2561/#tsl2561settiming", 
            "text": "Sets the integration time and gain settings of the device. When  tls2561.init()  is called, these values default to 402 ms and no gain.", 
            "title": "tsl2561.settiming()"
        }, 
        {
            "location": "/en/modules/tsl2561/#syntax_3", 
            "text": "tsl2561.settiming(integration, gain)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/tsl2561/#parameters_3", 
            "text": "integration  sets the device's integration period. Valid options are:  tsl2561.INTEGRATIONTIME_13MS  tsl2561.INTEGRATIONTIME_101MS  tsl2561.INTEGRATIONTIME_402MS  (default when omitted)    gain  sets the device's gain. Valid options are:  tsl2561.GAIN_1X  (default when omitted)  tsl2561.GAIN_16X", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/tsl2561/#returns_3", 
            "text": "status  value indicating success or failure as explained below:   tsl2561.TSL2561_OK  tsl2561.TSL2561_ERROR_I2CINIT  can't initialize I\u00b2C bus  tsl2561.TSL2561_ERROR_I2CBUSY  I\u00b2C bus busy  tsl2561.TSL2561_ERROR_NOINIT  initialize I\u00b2C bus before calling function  tsl2561.TSL2561_ERROR_LAST", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/tsl2561/#example_3", 
            "text": "status = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL)\nif status == tsl2561.TSL2561_OK then\n    status = tsl2561.settiming(tsl2561.INTEGRATIONTIME_101MS, tsl2561.GAIN_16X)\nend\nif status == tsl2561.TSL2561_OK then\n    lux = tsl2561.getlux()\n    print( Illuminance:  ..lux..  lx ) \nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/u8g/", 
            "text": "u8g Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-01-30\n\n\nOli Kraus\n, \nArnim L\u00e4uger\n\n\nArnim L\u00e4uger\n\n\nu8glib\n\n\n\n\n\n\n\n\nU8glib is a graphics library developed at \nolikraus/u8glib\n with support for many different displays. The NodeMCU firmware supports a subset of these.\n\n\nI\u00b2C and SPI mode:\n\n\n\n\nsh1106_128x64\n\n\nssd1306 - 128x32, 128x64, and 64x48 variants\n\n\nssd1309_128x64\n\n\nssd1327_96x96_gr\n\n\nuc1611 - dogm240 and dogxl240 variants\n\n\n\n\nSPI only:\n\n\n\n\nld7032_60x32\n\n\npcd8544_84x48\n\n\npcf8812_96x65\n\n\nssd1322_nhd31oled - bw and gr variants\n\n\nssd1325_nhd27oled - bw and gr variants\n\n\nssd1351_128x128 - gh and hicolor variants\n\n\nst7565_64128n - variants 64128n, dogm128/132, lm6059/lm6063, c12832/c12864\n\n\nuc1601_c128032\n\n\nuc1608 - 240x128 and 240x64 variants\n\n\nuc1610_dogxl160 - bw and gr variants\n\n\nuc1611 - dogm240 and dogxl240 variants\n\n\nuc1701 - dogs102 and mini12864 variants\n\n\n\n\nThis integration is based on \nv1.19.1\n.\n\n\nOverview\n\n\nI\u00b2C Connection\n\n\nHook up SDA and SCL to any free GPIOs. Eg. \nu8g_graphics_test.lua\n expects SDA=5 (GPIO14) and SCL=6 (GPIO12). They are used to set up nodemcu's I\u00b2C driver before accessing the display:\n\n\nsda = 5\nscl = 6\ni2c.setup(0, sda, scl, i2c.SLOW)\n\n\n\n\nSPI connection\n\n\nThe HSPI module is used (\nmore information\n), so certain pins are fixed:\n\n\n\n\nHSPI CLK = GPIO14\n\n\nHSPI MOSI = GPIO13\n\n\nHSPI MISO = GPIO12 (not used)\n\n\n\n\nAll other pins can be assigned to any available GPIO:\n\n\n\n\nCS\n\n\nD/C\n\n\nRES (optional for some displays)\n\n\n\n\nAlso refer to the initialization sequence eg in \nu8g_graphics_test.lua\n:\n\n\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)\n\n\n\n\nLibrary Usage\n\n\nThe Lua bindings for this library closely follow u8glib's object oriented C++ API. Based on the u8g class, you create an object for your display type.\n\n\nSSD1306 via I\u00b2C:\n\n\nsla = 0x3c\ndisp = u8g.ssd1306_128x64_i2c(sla)\n\n\n\n\nSSD1306 via SPI:\n\n\ncs  = 8 -- GPIO15, pull-down 10k to GND\ndc  = 4 -- GPIO2\nres = 0 -- GPIO16, RES is optional YMMV\ndisp = u8g.ssd1306_128x64_hw_spi(cs, dc, res)\n\n\n\n\nThis object provides all of u8glib's methods to control the display. Again, refer to \nu8g_graphics_test.lua\n to get an impression how this is achieved with Lua code. Visit the \nu8glib homepage\n for technical details.\n\n\nDisplays\n\n\nI\u00b2C and HW SPI based displays with support in u8glib can be enabled. To get access to the respective constructors, add the desired entries to the I\u00b2C or SPI display tables in \napp/include/u8g_config.h\n:\n\n\n#define U8G_DISPLAY_TABLE_I2C                   \\\n    U8G_DISPLAY_TABLE_ENTRY(ssd1306_128x64_i2c) \\\n\n#define U8G_DISPLAY_TABLE_SPI                      \\\n    U8G_DISPLAY_TABLE_ENTRY(ssd1306_128x64_hw_spi) \\\n    U8G_DISPLAY_TABLE_ENTRY(pcd8544_84x48_hw_spi)  \\\n    U8G_DISPLAY_TABLE_ENTRY(pcf8812_96x65_hw_spi)  \\\n\n\n\n\nFonts\n\n\nu8glib comes with a wide range of fonts for small displays. Since they need to be compiled into the firmware image, you'd need to include them in \napp/include/u8g_config.h\n and recompile. Simply add the desired fonts to the font table:\n\n\n#define U8G_FONT_TABLE \\\n    U8G_FONT_TABLE_ENTRY(font_6x10)  \\\n    U8G_FONT_TABLE_ENTRY(font_chikita)\n\n\n\n\nThey'll become available as \nu8g.\nfont_name\n in Lua.\n\n\nBitmaps\n\n\nBitmaps and XBMs are supplied as strings to \ndrawBitmap()\n and \ndrawXBM()\n. This off-loads all data handling from the u8g module to generic methods for binary files. See \nu8g_bitmaps.lua\n.\nIn contrast to the source code based inclusion of XBMs into u8glib, it's required to provide precompiled binary files. This can be performed online with \nOnline-Utility's Image Converter\n: Convert from XBM to MONO format and upload the binary result with \nnodemcu-uploader.py\n.\n\n\nI\u00b2C Display Drivers\n\n\nInitialize a display via I\u00b2C.\n\n\nThe init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver.\n\n\n\n\nu8g.sh1106_128x64_i2c()\n\n\nu8g.ssd1306_128x32_i2c()\n\n\nu8g.ssd1306_128x64_i2c()\n\n\nu8g.ssd1306_64x48_i2c()\n\n\nu8g.ssd1309_128x64_i2c()\n\n\nu8g.ssd1327_96x96_gr_i2c()\n\n\nu8g.uc1611_dogm240_i2c()\n\n\nu8g.uc1611_dogxl240_i2c()\n\n\n\n\nSyntax\n\n\nu8g.ssd1306_128x64_i2c(address[, use_delay])\n\n\nParameters\n\n\n\n\naddress\n I\u00b2C slave address of display\n\n\nuse_delay\n '1': use delays in init sequence, '0' if omitted\n\n\n\n\nReturns\n\n\nu8g display object\n\n\nExample\n\n\nsda = 5\nscl = 6\ni2c.setup(0, sda, scl, i2c.SLOW)\n\nsla = 0x3c\ndisp = u8g.ssd1306_128x64_i2c(sla)\n\n\n\n\nSee also\n\n\nSPI Display Drivers\n\n\nSPI Display Drivers\n\n\nInitialize a display via Hardware SPI.\n\n\nThe init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver.\n\n\n\n\nu8g.ld7032_60x32_hw_spi()\n\n\nu8g.pcd8544_84x48_hw_spi()\n\n\nu8g.pcf8812_96x65_hw_spi()\n\n\nu8g.sh1106_128x64_hw_spi()\n\n\nu8g.ssd1306_128x32_hw_spi()\n\n\nu8g.ssd1306_128x64_hw_spi()\n\n\nu8g.ssd1306_64x48_hw_spi()\n\n\nu8g.ssd1309_128x64_hw_spi()\n\n\nu8g.ssd1322_nhd31oled_bw_hw_spi()\n\n\nu8g.ssd1322_nhd31oled_gr_hw_spi()\n\n\nu8g.ssd1325_nhd27oled_bw_hw_spi()\n\n\nu8g.ssd1325_nhd27oled_gr_hw_spi()\n\n\nu8g.ssd1327_96x96_gr_hw_spi()\n\n\nu8g.ssd1351_128x128_332_hw_spi()\n\n\nu8g.ssd1351_128x128gh_332_hw_spi()\n\n\nu8g.ssd1351_128x128_hicolor_hw_spi()\n\n\nu8g.ssd1351_128x128gh_hicolor_hw_spi()\n\n\nu8g.ssd1353_160x128_332_hw_spi()\n\n\nu8g.ssd1353_160x128_hicolor_hw_spi()\n\n\nu8g.st7565_64128n_hw_spi()\n\n\nu8g.st7565_dogm128_hw_spi()\n\n\nu8g.st7565_dogm132_hw_spi()\n\n\nu8g.st7565_lm6059_hw_spi()\n\n\nu8g.st7565_lm6063_hw_spi()\n\n\nu8g.st7565_nhd_c12832_hw_spi()\n\n\nu8g.st7565_nhd_c12864_hw_spi()\n\n\nu8g.uc1601_c128032_hw_spi()\n\n\nu8g.uc1608_240x128_hw_spi()\n\n\nu8g.uc1608_240x64_hw_spi()\n\n\nu8g.uc1610_dogxl160_bw_hw_spi()\n\n\nu8g.uc1610_dogxl160_gr_hw_spi()\n\n\nu8g.uc1611_dogm240_hw_spi()\n\n\nu8g.uc1611_dogxl240_hw_spi()\n\n\nu8g.uc1701_dogs102_hw_spi()\n\n\nu8g.uc1701_mini12864_hw_spi()\n\n\n\n\nSyntax\n\n\nu8g.ssd1306_128x64_spi(cs, dc[, res[, use_delay]])\n\n\nParameters\n\n\n\n\ncs\n GPIO pin for /CS\n\n\ndc\n GPIO pin for DC\n\n\nres\n GPIO pin for /RES, none if omitted\n\n\nuse_delay\n '1': use delays in init sequence, '0' if omitted\n\n\n\n\nReturns\n\n\nu8g display object\n\n\nExample\n\n\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)\n\ncs  = 8 -- GPIO15, pull-down 10k to GND\ndc  = 4 -- GPIO2\nres = 0 -- GPIO16, RES is optional YMMV\ndisp = u8g.ssd1306_128x64_hw_spi(cs, dc, res)\n\n\n\n\nSee also\n\n\nI\u00b2C Display Drivers\n\n\nu8g.fb_rle\n\n\nInitialize a virtual display that provides run-length encoded framebuffer contents to a Lua callback.\n\n\nThe callback function can be used to process the framebuffer line by line. It's called with either \nnil\n as parameter to indicate the start of a new frame or with a string containing a line of the framebuffer with run-length encoding. First byte in the string specifies how many pairs of (x, len) follow, while each pair defines the start (leftmost x-coordinate) and length of a sequence of lit pixels. All other pixels in the line are dark.\n\n\nn = struct.unpack(\nB\n, rle_line)\nprint(n..\n pairs\n)\nfor i = 0,n-1 do\n  print(string.format(\n  x: %d len: %d\n, struct.unpack(\nBB\n, rle_line, 1+1 + i*2)))\nend\n\n\n\n\nSyntax\n\n\nu8g.fb_rle(cb_fn, width, height)\n\n\nParameters\n\n\n\n\ncb_fn([rle_line])\n callback function. \nrle_line\n is a string containing a run-length encoded framebuffer line, or \nnil\n to indicate start of frame.\n\n\nwidth\n of display. Must be a multiple of 8, less than or equal to 248.\n\n\nheight\n of display. Must be a multiple of 8, less than or equal to 248.\n\n\n\n\nReturns\n\n\nu8g display object\n\n\n\n\nConstants\n\n\nConstants for various functions.\n\n\nu8g.DRAW_UPPER_RIGHT\n, \nu8g.DRAW_UPPER_LEFT\n, \nu8g.DRAW_LOWER_RIGHT\n, \nu8g.DRAW_LOWER_LEFT\n, \nu8g.DRAW_ALL\n,\n\nu8g.MODE_BW\n, \nu8g.MODE_GRAY2BIT\n\n\nu8g.font_6x10\n, ...\n\n\nu8g.disp Sub-Module\n\n\nu8g.disp:begin()\n\n\nSee \nu8glib begin()\n.\n\n\nu8g.disp:drawBitmap()\n\n\nDraw a bitmap at the specified x/y position (upper left corner of the bitmap).\nParts of the bitmap may be outside the display boundaries. The bitmap is specified by the array bitmap. A cleared bit means: Do not draw a pixel. A set bit inside the array means: Write pixel with the current color index. For a monochrome display, the color index 0 will usually clear a pixel and the color index 1 will set a pixel.\n\n\nSyntax\n\n\ndisp:drawBitmap(x, y, cnt, h, bitmap)\n\n\nParameters\n\n\n\n\nx\n X-position (left position of the bitmap)\n\n\ny\n Y-position (upper position of the bitmap)\n\n\ncnt\n number of bytes of the bitmap in horizontal direction. The width of the bitmap is cnt*8.\n\n\nh\n height of the bitmap\n\n\nbitmap\n bitmap data supplied as string\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\n\n\nu8glib drawBitmap()\n\n\nlua_examples/u8glib/u8g_bitmaps.lua\n\n\nu8g.disp:drawXBM()\n\n\n\n\nu8g.disp:drawBox()\n\n\nSee \nu8glib drawBox()\n.\n\n\nu8g.disp:drawCircle()\n\n\nSee \nu8glib drawCircle()\n.\n\n\nu8g.disp:drawDisc()\n\n\nSee \nu8glib drawDisc()\n.\n\n\nu8g.disp:drawEllipse()\n\n\nSee \nu8glib drawEllipse()\n.\n\n\nu8g.disp:drawFilledEllipse()\n\n\nSee \nu8glib drawFilledEllipse\n.\n\n\nu8g.disp:drawFrame()\n\n\nSee \nu8glib drawFrame()\n.\n\n\nu8g.disp:drawHLine()\n\n\nSee \nu8glib drawHLine()\n.\n\n\nu8g.disp:drawLine()\n\n\nSee \nu8glib drawLine()\n.\n\n\nu8g.disp:drawPixel()\n\n\nSee \nu8glib drawPixel()\n.\n\n\nu8g.disp:drawRBox()\n\n\nSee \nu8glib drawRBox()\n.\n\n\nu8g.disp:drawRFrame()\n\n\nSee \nu8glib drawRFrame()\n.\n\n\nu8g.disp:drawStr()\n\n\nSee \nu8glib drawStr()\n.\n\n\nu8g.disp:drawStr90()\n\n\nSee \nu8glib drawStr90\n.\n\n\nu8g.disp:drawStr180()\n\n\nSee \nu8glib drawStr180()\n.\n\n\nu8g.disp:drawStr270()\n\n\nSee \nu8glib drawStr270()\n.\n\n\nu8g.disp:drawTriangle()\n\n\nSee \nu8glib drawTriangle()\n.\n\n\nu8g.disp:drawVLine()\n\n\nSee \nu8glib drawVLine()\n.\n\n\nu8g.disp:drawXBM()\n\n\nDraw a XBM Bitmap. Position (x,y) is the upper left corner of the bitmap.\nXBM contains monochrome, 1-bit bitmaps. This procedure only draws pixel values 1. The current color index is used for drawing (see setColorIndex). Pixel with value 0 are not drawn (transparent).\n\n\nBitmaps and XBMs are supplied as strings to \ndrawBitmap()\n and \ndrawXBM()\n. This off-loads all data handling from the u8g module to generic methods for binary files. In contrast to the source code based inclusion of XBMs into u8glib, it's required to provide precompiled binary files. This can be performed online with \nOnline-Utility's Image Converter\n: Convert from XBM to MONO format and upload the binary result with \nnodemcu-uploader.py\n or \nESPlorer\n.\n\n\nSyntax\n\n\ndisp:drawXBM(x, y, w, h, bitmap)\n\n\nParameters\n\n\n\n\nx\n X-position (left position of the bitmap)\n\n\ny\n Y-position (upper position of the bitmap)\n\n\nw\n width of the bitmap\n\n\nh\n height of the bitmap\n\n\nbitmap\n XBM data supplied as string\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\n\n\nu8glib drawXBM()\n\n\nlua_examples/u8glib/u8g_bitmaps.lua\n\n\nu8g.disp:drawBitmap()\n\n\n\n\nu8g.disp:firstPage()\n\n\nSee \nu8glib firstPage()\n.\n\n\nu8g.disp:getColorIndex()\n\n\nSee \nu8glib getColorIndex()\n.\n\n\nu8g.disp:getFontAscent()\n\n\nSee \nu8glib getFontAscent()\n.\n\n\nu8g.disp:getFontDescent()\n\n\nSee \nu8glib getFontDescent()\n.\n\n\nu8g.disp:getFontLineSpacing()\n\n\nSee \nu8glib getFontLineSpacing()\n.\n\n\nu8g.disp:getHeight()\n\n\nSee \nu8glib getHeight()\n.\n\n\nu8g.disp:getMode()\n\n\nSee \nu8glib getMode()\n.\n\n\nu8g.disp:getWidth()\n\n\nSee \nu8glib getWidth()\n.\n\n\nu8g.disp:getStrWidth()\n\n\nSee \nu8glib getStrWidth\n.\n\n\nu8g.disp:nextPage()\n\n\nSee \nu8glib nextPage()\n.\n\n\nu8g.disp:setColorIndex()\n\n\nSee \nu8glib setColorIndex()\n.\n\n\nu8g.disp:setContrast()\n\n\nSee \nu8glib setContrast()\n.\n\n\nu8g.disp:setDefaultBackgroundColor()\n\n\nSee \nu8glib setDefaultBackgroundColor()\n.\n\n\nu8g.disp:setDefaultForegroundColor()\n\n\nSee \nu8glib setDefaultForegroundColor()\n.\n\n\nu8g.disp:setFont()\n\n\nu8glib comes with a wide range of fonts for small displays.\nSince they need to be compiled into the firmware image, you'd need to include them in \napp/include/u8g_config.h\n and recompile. Simply add the desired fonts to the font table:\n\n\n#define U8G_FONT_TABLE \\\n    U8G_FONT_TABLE_ENTRY(font_6x10)  \\\n    U8G_FONT_TABLE_ENTRY(font_chikita)\n\n\n\n\nThey'll be available as \nu8g.\nfont_name\n in Lua.\n\n\nSyntax\n\n\ndisp:setFont(font)\n\n\nParameters\n\n\nfont\n Constant to indentify pre-compiled font\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\ndisp:setFont(u8g.font_6x10)\n\n\n\n\nSee also\n\n\n\n\nu8glib setFont()\n\n\n\n\nu8g.disp:setFontLineSpacingFactor()\n\n\nSee \nu8glib setFontLineSpacingFactor()\n.\n\n\nu8g.disp:setFontPosBaseline()\n\n\nSee \nu8glib setFontPosBaseline()\n.\n\n\nu8g.disp:setFontPosBottom()\n\n\nSee \nu8glib setFontPosBottom()\n.\n\n\nu8g.disp:setFontPosCenter()\n\n\nSee \nu8glib setFontPosCenter()\n.\n\n\nu8g.disp:setFontPosTop()\n\n\nSee \nu8glib setFontPosTop()\n.\n\n\nu8g.disp:setFontRefHeightAll()\n\n\nSee \nu8glib setFontRefHeightAll()\n.\n\n\nu8g.disp:setFontRefHeightExtendedText()\n\n\nSee \nu8glib setFontRefHeightExtendedText()\n.\n\n\nu8g.disp:setFontRefHeightText()\n\n\nSee \nu8glib setFontRefHeightText()\n.\n\n\nu8g.disp:setRot90()\n\n\nSee \nu8glib setRot90()\n.\n\n\nu8g.disp:setRot180()\n\n\nSee \nu8glib setRot180()\n.\n\n\nu8g.disp:setRot270()\n\n\nSee \nu8glib setRot270()\n.\n\n\nu8g.disp:setScale2x2()\n\n\nSee \nu8glib setScale2x2()\n.\n\n\nu8g.disp:sleepOn()\n\n\nSee \nu8glib sleepOn()\n.\n\n\nu8g.disp:sleepOff()\n\n\nSee \nu8glib sleepOff()\n.\n\n\nu8g.disp:undoRotation()\n\n\nSee \nu8glib undoRotation()\n.\n\n\nu8g.disp:undoScale()\n\n\nSee \nu8glib undoScale()\n.\n\n\nUnimplemented Functions\n\n\n\n\nCursor handling\n\n\ndisableCursor()\n\n\nenableCursor()\n\n\nsetCursorColor()\n\n\nsetCursorFont()\n\n\nsetCursorPos()\n\n\nsetCursorStyle()\n\n\n\n\n\n\nGeneral functions\n\n\nsetPrintPos()\n\n\nsetHardwareBackup()\n\n\nsetRGB()\n\n\nsetDefaultMidColor()", 
            "title": "u8g"
        }, 
        {
            "location": "/en/modules/u8g/#u8g-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-01-30  Oli Kraus ,  Arnim L\u00e4uger  Arnim L\u00e4uger  u8glib     U8glib is a graphics library developed at  olikraus/u8glib  with support for many different displays. The NodeMCU firmware supports a subset of these.  I\u00b2C and SPI mode:   sh1106_128x64  ssd1306 - 128x32, 128x64, and 64x48 variants  ssd1309_128x64  ssd1327_96x96_gr  uc1611 - dogm240 and dogxl240 variants   SPI only:   ld7032_60x32  pcd8544_84x48  pcf8812_96x65  ssd1322_nhd31oled - bw and gr variants  ssd1325_nhd27oled - bw and gr variants  ssd1351_128x128 - gh and hicolor variants  st7565_64128n - variants 64128n, dogm128/132, lm6059/lm6063, c12832/c12864  uc1601_c128032  uc1608 - 240x128 and 240x64 variants  uc1610_dogxl160 - bw and gr variants  uc1611 - dogm240 and dogxl240 variants  uc1701 - dogs102 and mini12864 variants   This integration is based on  v1.19.1 .", 
            "title": "u8g Module"
        }, 
        {
            "location": "/en/modules/u8g/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/en/modules/u8g/#i2c-connection", 
            "text": "Hook up SDA and SCL to any free GPIOs. Eg.  u8g_graphics_test.lua  expects SDA=5 (GPIO14) and SCL=6 (GPIO12). They are used to set up nodemcu's I\u00b2C driver before accessing the display:  sda = 5\nscl = 6\ni2c.setup(0, sda, scl, i2c.SLOW)", 
            "title": "I\u00b2C Connection"
        }, 
        {
            "location": "/en/modules/u8g/#spi-connection", 
            "text": "The HSPI module is used ( more information ), so certain pins are fixed:   HSPI CLK = GPIO14  HSPI MOSI = GPIO13  HSPI MISO = GPIO12 (not used)   All other pins can be assigned to any available GPIO:   CS  D/C  RES (optional for some displays)   Also refer to the initialization sequence eg in  u8g_graphics_test.lua :  spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)", 
            "title": "SPI connection"
        }, 
        {
            "location": "/en/modules/u8g/#library-usage", 
            "text": "The Lua bindings for this library closely follow u8glib's object oriented C++ API. Based on the u8g class, you create an object for your display type.  SSD1306 via I\u00b2C:  sla = 0x3c\ndisp = u8g.ssd1306_128x64_i2c(sla)  SSD1306 via SPI:  cs  = 8 -- GPIO15, pull-down 10k to GND\ndc  = 4 -- GPIO2\nres = 0 -- GPIO16, RES is optional YMMV\ndisp = u8g.ssd1306_128x64_hw_spi(cs, dc, res)  This object provides all of u8glib's methods to control the display. Again, refer to  u8g_graphics_test.lua  to get an impression how this is achieved with Lua code. Visit the  u8glib homepage  for technical details.", 
            "title": "Library Usage"
        }, 
        {
            "location": "/en/modules/u8g/#displays", 
            "text": "I\u00b2C and HW SPI based displays with support in u8glib can be enabled. To get access to the respective constructors, add the desired entries to the I\u00b2C or SPI display tables in  app/include/u8g_config.h :  #define U8G_DISPLAY_TABLE_I2C                   \\\n    U8G_DISPLAY_TABLE_ENTRY(ssd1306_128x64_i2c) \\\n\n#define U8G_DISPLAY_TABLE_SPI                      \\\n    U8G_DISPLAY_TABLE_ENTRY(ssd1306_128x64_hw_spi) \\\n    U8G_DISPLAY_TABLE_ENTRY(pcd8544_84x48_hw_spi)  \\\n    U8G_DISPLAY_TABLE_ENTRY(pcf8812_96x65_hw_spi)  \\", 
            "title": "Displays"
        }, 
        {
            "location": "/en/modules/u8g/#fonts", 
            "text": "u8glib comes with a wide range of fonts for small displays. Since they need to be compiled into the firmware image, you'd need to include them in  app/include/u8g_config.h  and recompile. Simply add the desired fonts to the font table:  #define U8G_FONT_TABLE \\\n    U8G_FONT_TABLE_ENTRY(font_6x10)  \\\n    U8G_FONT_TABLE_ENTRY(font_chikita)  They'll become available as  u8g. font_name  in Lua.", 
            "title": "Fonts"
        }, 
        {
            "location": "/en/modules/u8g/#bitmaps", 
            "text": "Bitmaps and XBMs are supplied as strings to  drawBitmap()  and  drawXBM() . This off-loads all data handling from the u8g module to generic methods for binary files. See  u8g_bitmaps.lua .\nIn contrast to the source code based inclusion of XBMs into u8glib, it's required to provide precompiled binary files. This can be performed online with  Online-Utility's Image Converter : Convert from XBM to MONO format and upload the binary result with  nodemcu-uploader.py .", 
            "title": "Bitmaps"
        }, 
        {
            "location": "/en/modules/u8g/#i2c-display-drivers", 
            "text": "Initialize a display via I\u00b2C.  The init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver.   u8g.sh1106_128x64_i2c()  u8g.ssd1306_128x32_i2c()  u8g.ssd1306_128x64_i2c()  u8g.ssd1306_64x48_i2c()  u8g.ssd1309_128x64_i2c()  u8g.ssd1327_96x96_gr_i2c()  u8g.uc1611_dogm240_i2c()  u8g.uc1611_dogxl240_i2c()", 
            "title": "I\u00b2C Display Drivers"
        }, 
        {
            "location": "/en/modules/u8g/#syntax", 
            "text": "u8g.ssd1306_128x64_i2c(address[, use_delay])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/u8g/#parameters", 
            "text": "address  I\u00b2C slave address of display  use_delay  '1': use delays in init sequence, '0' if omitted", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/u8g/#returns", 
            "text": "u8g display object", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/u8g/#example", 
            "text": "sda = 5\nscl = 6\ni2c.setup(0, sda, scl, i2c.SLOW)\n\nsla = 0x3c\ndisp = u8g.ssd1306_128x64_i2c(sla)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/u8g/#see-also", 
            "text": "SPI Display Drivers", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/u8g/#spi-display-drivers", 
            "text": "Initialize a display via Hardware SPI.  The init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver.   u8g.ld7032_60x32_hw_spi()  u8g.pcd8544_84x48_hw_spi()  u8g.pcf8812_96x65_hw_spi()  u8g.sh1106_128x64_hw_spi()  u8g.ssd1306_128x32_hw_spi()  u8g.ssd1306_128x64_hw_spi()  u8g.ssd1306_64x48_hw_spi()  u8g.ssd1309_128x64_hw_spi()  u8g.ssd1322_nhd31oled_bw_hw_spi()  u8g.ssd1322_nhd31oled_gr_hw_spi()  u8g.ssd1325_nhd27oled_bw_hw_spi()  u8g.ssd1325_nhd27oled_gr_hw_spi()  u8g.ssd1327_96x96_gr_hw_spi()  u8g.ssd1351_128x128_332_hw_spi()  u8g.ssd1351_128x128gh_332_hw_spi()  u8g.ssd1351_128x128_hicolor_hw_spi()  u8g.ssd1351_128x128gh_hicolor_hw_spi()  u8g.ssd1353_160x128_332_hw_spi()  u8g.ssd1353_160x128_hicolor_hw_spi()  u8g.st7565_64128n_hw_spi()  u8g.st7565_dogm128_hw_spi()  u8g.st7565_dogm132_hw_spi()  u8g.st7565_lm6059_hw_spi()  u8g.st7565_lm6063_hw_spi()  u8g.st7565_nhd_c12832_hw_spi()  u8g.st7565_nhd_c12864_hw_spi()  u8g.uc1601_c128032_hw_spi()  u8g.uc1608_240x128_hw_spi()  u8g.uc1608_240x64_hw_spi()  u8g.uc1610_dogxl160_bw_hw_spi()  u8g.uc1610_dogxl160_gr_hw_spi()  u8g.uc1611_dogm240_hw_spi()  u8g.uc1611_dogxl240_hw_spi()  u8g.uc1701_dogs102_hw_spi()  u8g.uc1701_mini12864_hw_spi()", 
            "title": "SPI Display Drivers"
        }, 
        {
            "location": "/en/modules/u8g/#syntax_1", 
            "text": "u8g.ssd1306_128x64_spi(cs, dc[, res[, use_delay]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/u8g/#parameters_1", 
            "text": "cs  GPIO pin for /CS  dc  GPIO pin for DC  res  GPIO pin for /RES, none if omitted  use_delay  '1': use delays in init sequence, '0' if omitted", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/u8g/#returns_1", 
            "text": "u8g display object", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/u8g/#example_1", 
            "text": "spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)\n\ncs  = 8 -- GPIO15, pull-down 10k to GND\ndc  = 4 -- GPIO2\nres = 0 -- GPIO16, RES is optional YMMV\ndisp = u8g.ssd1306_128x64_hw_spi(cs, dc, res)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/u8g/#see-also_1", 
            "text": "I\u00b2C Display Drivers", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/u8g/#u8gfb_rle", 
            "text": "Initialize a virtual display that provides run-length encoded framebuffer contents to a Lua callback.  The callback function can be used to process the framebuffer line by line. It's called with either  nil  as parameter to indicate the start of a new frame or with a string containing a line of the framebuffer with run-length encoding. First byte in the string specifies how many pairs of (x, len) follow, while each pair defines the start (leftmost x-coordinate) and length of a sequence of lit pixels. All other pixels in the line are dark.  n = struct.unpack( B , rle_line)\nprint(n..  pairs )\nfor i = 0,n-1 do\n  print(string.format(   x: %d len: %d , struct.unpack( BB , rle_line, 1+1 + i*2)))\nend", 
            "title": "u8g.fb_rle"
        }, 
        {
            "location": "/en/modules/u8g/#syntax_2", 
            "text": "u8g.fb_rle(cb_fn, width, height)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/u8g/#parameters_2", 
            "text": "cb_fn([rle_line])  callback function.  rle_line  is a string containing a run-length encoded framebuffer line, or  nil  to indicate start of frame.  width  of display. Must be a multiple of 8, less than or equal to 248.  height  of display. Must be a multiple of 8, less than or equal to 248.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/u8g/#returns_2", 
            "text": "u8g display object", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/u8g/#constants", 
            "text": "Constants for various functions.  u8g.DRAW_UPPER_RIGHT ,  u8g.DRAW_UPPER_LEFT ,  u8g.DRAW_LOWER_RIGHT ,  u8g.DRAW_LOWER_LEFT ,  u8g.DRAW_ALL , u8g.MODE_BW ,  u8g.MODE_GRAY2BIT  u8g.font_6x10 , ...", 
            "title": "Constants"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdisp-sub-module", 
            "text": "", 
            "title": "u8g.disp Sub-Module"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispbegin", 
            "text": "See  u8glib begin() .", 
            "title": "u8g.disp:begin()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawbitmap", 
            "text": "Draw a bitmap at the specified x/y position (upper left corner of the bitmap).\nParts of the bitmap may be outside the display boundaries. The bitmap is specified by the array bitmap. A cleared bit means: Do not draw a pixel. A set bit inside the array means: Write pixel with the current color index. For a monochrome display, the color index 0 will usually clear a pixel and the color index 1 will set a pixel.", 
            "title": "u8g.disp:drawBitmap()"
        }, 
        {
            "location": "/en/modules/u8g/#syntax_3", 
            "text": "disp:drawBitmap(x, y, cnt, h, bitmap)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/u8g/#parameters_3", 
            "text": "x  X-position (left position of the bitmap)  y  Y-position (upper position of the bitmap)  cnt  number of bytes of the bitmap in horizontal direction. The width of the bitmap is cnt*8.  h  height of the bitmap  bitmap  bitmap data supplied as string", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/u8g/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/u8g/#see-also_2", 
            "text": "u8glib drawBitmap()  lua_examples/u8glib/u8g_bitmaps.lua  u8g.disp:drawXBM()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawbox", 
            "text": "See  u8glib drawBox() .", 
            "title": "u8g.disp:drawBox()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawcircle", 
            "text": "See  u8glib drawCircle() .", 
            "title": "u8g.disp:drawCircle()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawdisc", 
            "text": "See  u8glib drawDisc() .", 
            "title": "u8g.disp:drawDisc()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawellipse", 
            "text": "See  u8glib drawEllipse() .", 
            "title": "u8g.disp:drawEllipse()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawfilledellipse", 
            "text": "See  u8glib drawFilledEllipse .", 
            "title": "u8g.disp:drawFilledEllipse()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawframe", 
            "text": "See  u8glib drawFrame() .", 
            "title": "u8g.disp:drawFrame()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawhline", 
            "text": "See  u8glib drawHLine() .", 
            "title": "u8g.disp:drawHLine()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawline", 
            "text": "See  u8glib drawLine() .", 
            "title": "u8g.disp:drawLine()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawpixel", 
            "text": "See  u8glib drawPixel() .", 
            "title": "u8g.disp:drawPixel()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawrbox", 
            "text": "See  u8glib drawRBox() .", 
            "title": "u8g.disp:drawRBox()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawrframe", 
            "text": "See  u8glib drawRFrame() .", 
            "title": "u8g.disp:drawRFrame()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawstr", 
            "text": "See  u8glib drawStr() .", 
            "title": "u8g.disp:drawStr()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawstr90", 
            "text": "See  u8glib drawStr90 .", 
            "title": "u8g.disp:drawStr90()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawstr180", 
            "text": "See  u8glib drawStr180() .", 
            "title": "u8g.disp:drawStr180()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawstr270", 
            "text": "See  u8glib drawStr270() .", 
            "title": "u8g.disp:drawStr270()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawtriangle", 
            "text": "See  u8glib drawTriangle() .", 
            "title": "u8g.disp:drawTriangle()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawvline", 
            "text": "See  u8glib drawVLine() .", 
            "title": "u8g.disp:drawVLine()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispdrawxbm", 
            "text": "Draw a XBM Bitmap. Position (x,y) is the upper left corner of the bitmap.\nXBM contains monochrome, 1-bit bitmaps. This procedure only draws pixel values 1. The current color index is used for drawing (see setColorIndex). Pixel with value 0 are not drawn (transparent).  Bitmaps and XBMs are supplied as strings to  drawBitmap()  and  drawXBM() . This off-loads all data handling from the u8g module to generic methods for binary files. In contrast to the source code based inclusion of XBMs into u8glib, it's required to provide precompiled binary files. This can be performed online with  Online-Utility's Image Converter : Convert from XBM to MONO format and upload the binary result with  nodemcu-uploader.py  or  ESPlorer .", 
            "title": "u8g.disp:drawXBM()"
        }, 
        {
            "location": "/en/modules/u8g/#syntax_4", 
            "text": "disp:drawXBM(x, y, w, h, bitmap)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/u8g/#parameters_4", 
            "text": "x  X-position (left position of the bitmap)  y  Y-position (upper position of the bitmap)  w  width of the bitmap  h  height of the bitmap  bitmap  XBM data supplied as string", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/u8g/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/u8g/#see-also_3", 
            "text": "u8glib drawXBM()  lua_examples/u8glib/u8g_bitmaps.lua  u8g.disp:drawBitmap()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispfirstpage", 
            "text": "See  u8glib firstPage() .", 
            "title": "u8g.disp:firstPage()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispgetcolorindex", 
            "text": "See  u8glib getColorIndex() .", 
            "title": "u8g.disp:getColorIndex()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispgetfontascent", 
            "text": "See  u8glib getFontAscent() .", 
            "title": "u8g.disp:getFontAscent()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispgetfontdescent", 
            "text": "See  u8glib getFontDescent() .", 
            "title": "u8g.disp:getFontDescent()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispgetfontlinespacing", 
            "text": "See  u8glib getFontLineSpacing() .", 
            "title": "u8g.disp:getFontLineSpacing()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispgetheight", 
            "text": "See  u8glib getHeight() .", 
            "title": "u8g.disp:getHeight()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispgetmode", 
            "text": "See  u8glib getMode() .", 
            "title": "u8g.disp:getMode()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispgetwidth", 
            "text": "See  u8glib getWidth() .", 
            "title": "u8g.disp:getWidth()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispgetstrwidth", 
            "text": "See  u8glib getStrWidth .", 
            "title": "u8g.disp:getStrWidth()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispnextpage", 
            "text": "See  u8glib nextPage() .", 
            "title": "u8g.disp:nextPage()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetcolorindex", 
            "text": "See  u8glib setColorIndex() .", 
            "title": "u8g.disp:setColorIndex()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetcontrast", 
            "text": "See  u8glib setContrast() .", 
            "title": "u8g.disp:setContrast()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetdefaultbackgroundcolor", 
            "text": "See  u8glib setDefaultBackgroundColor() .", 
            "title": "u8g.disp:setDefaultBackgroundColor()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetdefaultforegroundcolor", 
            "text": "See  u8glib setDefaultForegroundColor() .", 
            "title": "u8g.disp:setDefaultForegroundColor()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetfont", 
            "text": "u8glib comes with a wide range of fonts for small displays.\nSince they need to be compiled into the firmware image, you'd need to include them in  app/include/u8g_config.h  and recompile. Simply add the desired fonts to the font table:  #define U8G_FONT_TABLE \\\n    U8G_FONT_TABLE_ENTRY(font_6x10)  \\\n    U8G_FONT_TABLE_ENTRY(font_chikita)  They'll be available as  u8g. font_name  in Lua.", 
            "title": "u8g.disp:setFont()"
        }, 
        {
            "location": "/en/modules/u8g/#syntax_5", 
            "text": "disp:setFont(font)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/u8g/#parameters_5", 
            "text": "font  Constant to indentify pre-compiled font", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/u8g/#returns_5", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/u8g/#example_2", 
            "text": "disp:setFont(u8g.font_6x10)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/u8g/#see-also_4", 
            "text": "u8glib setFont()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetfontlinespacingfactor", 
            "text": "See  u8glib setFontLineSpacingFactor() .", 
            "title": "u8g.disp:setFontLineSpacingFactor()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetfontposbaseline", 
            "text": "See  u8glib setFontPosBaseline() .", 
            "title": "u8g.disp:setFontPosBaseline()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetfontposbottom", 
            "text": "See  u8glib setFontPosBottom() .", 
            "title": "u8g.disp:setFontPosBottom()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetfontposcenter", 
            "text": "See  u8glib setFontPosCenter() .", 
            "title": "u8g.disp:setFontPosCenter()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetfontpostop", 
            "text": "See  u8glib setFontPosTop() .", 
            "title": "u8g.disp:setFontPosTop()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetfontrefheightall", 
            "text": "See  u8glib setFontRefHeightAll() .", 
            "title": "u8g.disp:setFontRefHeightAll()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetfontrefheightextendedtext", 
            "text": "See  u8glib setFontRefHeightExtendedText() .", 
            "title": "u8g.disp:setFontRefHeightExtendedText()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetfontrefheighttext", 
            "text": "See  u8glib setFontRefHeightText() .", 
            "title": "u8g.disp:setFontRefHeightText()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetrot90", 
            "text": "See  u8glib setRot90() .", 
            "title": "u8g.disp:setRot90()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetrot180", 
            "text": "See  u8glib setRot180() .", 
            "title": "u8g.disp:setRot180()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetrot270", 
            "text": "See  u8glib setRot270() .", 
            "title": "u8g.disp:setRot270()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsetscale2x2", 
            "text": "See  u8glib setScale2x2() .", 
            "title": "u8g.disp:setScale2x2()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsleepon", 
            "text": "See  u8glib sleepOn() .", 
            "title": "u8g.disp:sleepOn()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispsleepoff", 
            "text": "See  u8glib sleepOff() .", 
            "title": "u8g.disp:sleepOff()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispundorotation", 
            "text": "See  u8glib undoRotation() .", 
            "title": "u8g.disp:undoRotation()"
        }, 
        {
            "location": "/en/modules/u8g/#u8gdispundoscale", 
            "text": "See  u8glib undoScale() .", 
            "title": "u8g.disp:undoScale()"
        }, 
        {
            "location": "/en/modules/u8g/#unimplemented-functions", 
            "text": "Cursor handling  disableCursor()  enableCursor()  setCursorColor()  setCursorFont()  setCursorPos()  setCursorStyle()    General functions  setPrintPos()  setHardwareBackup()  setRGB()  setDefaultMidColor()", 
            "title": "Unimplemented Functions"
        }, 
        {
            "location": "/en/modules/uart/", 
            "text": "UART Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2014-12-22\n\n\nZeroday\n\n\nZeroday\n\n\nuart.c\n\n\n\n\n\n\n\n\nThe \nUART\n (Universal asynchronous receiver/transmitter) module allows configuration of and communication over the UART serial port.\n\n\nThe default setup for the uart is controlled by build-time settings. The default rate is 115,200 bps. In addition, auto-baudrate detection is enabled for the first two minutes\nafter platform boot. This will cause a switch to the correct baud rate once a few characters are received. Auto-baudrate detection is disabled when \nuart.setup\n is called.\n\n\n\n\nImportant\n\n\nAlthough there are two UARTs(0 and 1) available to NodeMCU, \nUART 1 is not capable of receiving data and is therefore transmit only\n.\n\n\n\n\nuart.alt()\n\n\nChange UART pin assignment.\n\n\nSyntax\n\n\nuart.alt(on)\n\n\nParameters\n\n\non\n\n\n\n\n0 for standard pins\n\n\n1 to use alternate pins GPIO13 and GPIO15\n\n\n\n\nReturns\n\n\nnil\n\n\nuart.on()\n\n\nSets the callback function to handle UART events.\n\n\nCurrently only the \"data\" event is supported.\n\n\n\n\nNote\n\n\nDue to limitations of the ESP8266, only UART 0 is capable of receiving data.  \n\n\n\n\nSyntax\n\n\nuart.on(method, [number/end_char], [function], [run_input])\n\n\nParameters\n\n\n\n\nmethod\n \"data\", data has been received on the UART\n\n\nnumber/end_char\n\n\nif n=0, will receive every char in buffer\n\n\nif n\n255, the callback is called when n chars are received\n\n\nif one char \"c\", the callback will be called when \"c\" is encountered, or max n=255 received\n\n\n\n\n\n\nfunction\n callback function, event \"data\" has a callback like this: \nfunction(data) end\n\n\nrun_input\n 0 or 1. If 0, input from UART will not go into Lua interpreter, can accept binary data. If 1, input from UART will go into Lua interpreter, and run.\n\n\n\n\nTo unregister the callback, provide only the \"data\" parameter.\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- when 4 chars is received.\nuart.on(\ndata\n, 4,\n  function(data)\n    print(\nreceive from uart:\n, data)\n    if data==\nquit\n then\n      uart.on(\ndata\n) -- unregister callback function\n    end\nend, 0)\n-- when '\\r' is received.\nuart.on(\ndata\n, \n\\r\n,\n  function(data)\n    print(\nreceive from uart:\n, data)\n    if data==\nquit\\r\n then\n      uart.on(\ndata\n) -- unregister callback function\n    end\nend, 0)\n\n\n\n\nuart.setup()\n\n\n(Re-)configures the communication parameters of the UART.\n\n\n\n\nNote\n\n\nBytes sent to the UART can get lost if this function re-configures the UART while reception is in progress.\n\n\n\n\nSyntax\n\n\nuart.setup(id, baud, databits, parity, stopbits[, echo])\n\n\nParameters\n\n\n\n\nid\n UART id (0 or 1).\n\n\nbaud\n one of 300, 600, 1200, 2400, 4800, 9600, 19200, 31250, 38400, 57600, 74880, 115200, 230400, 256000, 460800, 921600, 1843200, 3686400\n\n\ndatabits\n one of 5, 6, 7, 8\n\n\nparity\n \nuart.PARITY_NONE\n, \nuart.PARITY_ODD\n, or \nuart.PARITY_EVEN\n\n\nstopbits\n \nuart.STOPBITS_1\n, \nuart.STOPBITS_1_5\n, or \nuart.STOPBITS_2\n\n\necho\n if 0, disable echo, otherwise enable echo (default if omitted)\n\n\n\n\nReturns\n\n\nconfigured baud rate (number)\n\n\nExample\n\n\n-- configure for 9600, 8N1, with echo\nuart.setup(0, 9600, 8, uart.PARITY_NONE, uart.STOPBITS_1, 1)\n\n\n\n\nuart.getconfig()\n\n\nReturns the current configuration parameters of the UART. \n\n\nSyntax\n\n\nuart.getconfig(id)\n\n\nParameters\n\n\n\n\nid\n UART id (0 or 1).\n\n\n\n\nReturns\n\n\nFour values as follows:\n\n\n\n\nbaud\n one of 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 74880, 115200, 230400, 256000, 460800, 921600, 1843200, 3686400\n\n\ndatabits\n one of 5, 6, 7, 8\n\n\nparity\n \nuart.PARITY_NONE\n, \nuart.PARITY_ODD\n, or \nuart.PARITY_EVEN\n\n\nstopbits\n \nuart.STOPBITS_1\n, \nuart.STOPBITS_1_5\n, or \nuart.STOPBITS_2\n\n\n\n\nExample\n\n\nprint (uart.getconfig(0))\n-- prints 9600 8 0 1   for 9600, 8N1\n\n\n\n\nuart.write()\n\n\nWrite string or byte to the UART.\n\n\nSyntax\n\n\nuart.write(id, data1 [, data2, ...])\n\n\nParameters\n\n\n\n\nid\n UART id (0 or 1).\n\n\ndata1\n... string or byte to send via UART\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nuart.write(0, \nHello, world\\n\n)", 
            "title": "uart"
        }, 
        {
            "location": "/en/modules/uart/#uart-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2014-12-22  Zeroday  Zeroday  uart.c     The  UART  (Universal asynchronous receiver/transmitter) module allows configuration of and communication over the UART serial port.  The default setup for the uart is controlled by build-time settings. The default rate is 115,200 bps. In addition, auto-baudrate detection is enabled for the first two minutes\nafter platform boot. This will cause a switch to the correct baud rate once a few characters are received. Auto-baudrate detection is disabled when  uart.setup  is called.   Important  Although there are two UARTs(0 and 1) available to NodeMCU,  UART 1 is not capable of receiving data and is therefore transmit only .", 
            "title": "UART Module"
        }, 
        {
            "location": "/en/modules/uart/#uartalt", 
            "text": "Change UART pin assignment.", 
            "title": "uart.alt()"
        }, 
        {
            "location": "/en/modules/uart/#syntax", 
            "text": "uart.alt(on)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/uart/#parameters", 
            "text": "on   0 for standard pins  1 to use alternate pins GPIO13 and GPIO15", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/uart/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/uart/#uarton", 
            "text": "Sets the callback function to handle UART events.  Currently only the \"data\" event is supported.   Note  Due to limitations of the ESP8266, only UART 0 is capable of receiving data.", 
            "title": "uart.on()"
        }, 
        {
            "location": "/en/modules/uart/#syntax_1", 
            "text": "uart.on(method, [number/end_char], [function], [run_input])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/uart/#parameters_1", 
            "text": "method  \"data\", data has been received on the UART  number/end_char  if n=0, will receive every char in buffer  if n 255, the callback is called when n chars are received  if one char \"c\", the callback will be called when \"c\" is encountered, or max n=255 received    function  callback function, event \"data\" has a callback like this:  function(data) end  run_input  0 or 1. If 0, input from UART will not go into Lua interpreter, can accept binary data. If 1, input from UART will go into Lua interpreter, and run.   To unregister the callback, provide only the \"data\" parameter.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/uart/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/uart/#example", 
            "text": "-- when 4 chars is received.\nuart.on( data , 4,\n  function(data)\n    print( receive from uart: , data)\n    if data== quit  then\n      uart.on( data ) -- unregister callback function\n    end\nend, 0)\n-- when '\\r' is received.\nuart.on( data ,  \\r ,\n  function(data)\n    print( receive from uart: , data)\n    if data== quit\\r  then\n      uart.on( data ) -- unregister callback function\n    end\nend, 0)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/uart/#uartsetup", 
            "text": "(Re-)configures the communication parameters of the UART.   Note  Bytes sent to the UART can get lost if this function re-configures the UART while reception is in progress.", 
            "title": "uart.setup()"
        }, 
        {
            "location": "/en/modules/uart/#syntax_2", 
            "text": "uart.setup(id, baud, databits, parity, stopbits[, echo])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/uart/#parameters_2", 
            "text": "id  UART id (0 or 1).  baud  one of 300, 600, 1200, 2400, 4800, 9600, 19200, 31250, 38400, 57600, 74880, 115200, 230400, 256000, 460800, 921600, 1843200, 3686400  databits  one of 5, 6, 7, 8  parity   uart.PARITY_NONE ,  uart.PARITY_ODD , or  uart.PARITY_EVEN  stopbits   uart.STOPBITS_1 ,  uart.STOPBITS_1_5 , or  uart.STOPBITS_2  echo  if 0, disable echo, otherwise enable echo (default if omitted)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/uart/#returns_2", 
            "text": "configured baud rate (number)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/uart/#example_1", 
            "text": "-- configure for 9600, 8N1, with echo\nuart.setup(0, 9600, 8, uart.PARITY_NONE, uart.STOPBITS_1, 1)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/uart/#uartgetconfig", 
            "text": "Returns the current configuration parameters of the UART.", 
            "title": "uart.getconfig()"
        }, 
        {
            "location": "/en/modules/uart/#syntax_3", 
            "text": "uart.getconfig(id)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/uart/#parameters_3", 
            "text": "id  UART id (0 or 1).", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/uart/#returns_3", 
            "text": "Four values as follows:   baud  one of 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 74880, 115200, 230400, 256000, 460800, 921600, 1843200, 3686400  databits  one of 5, 6, 7, 8  parity   uart.PARITY_NONE ,  uart.PARITY_ODD , or  uart.PARITY_EVEN  stopbits   uart.STOPBITS_1 ,  uart.STOPBITS_1_5 , or  uart.STOPBITS_2", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/uart/#example_2", 
            "text": "print (uart.getconfig(0))\n-- prints 9600 8 0 1   for 9600, 8N1", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/uart/#uartwrite", 
            "text": "Write string or byte to the UART.", 
            "title": "uart.write()"
        }, 
        {
            "location": "/en/modules/uart/#syntax_4", 
            "text": "uart.write(id, data1 [, data2, ...])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/uart/#parameters_4", 
            "text": "id  UART id (0 or 1).  data1 ... string or byte to send via UART", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/uart/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/uart/#example_3", 
            "text": "uart.write(0,  Hello, world\\n )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ucg/", 
            "text": "ucg Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-08-05\n\n\nOli Kraus\n, \nArnim L\u00e4uger\n\n\nArnim L\u00e4uger\n\n\nucglib\n\n\n\n\n\n\n\n\nUcglib is a graphics library developed at \nolikraus/ucglib\n with support for color TFT displays. The NodeMCU firmware supports a subset of these:\n\n\n\n\nILI9163\n\n\nILI9341\n\n\nPCF8833\n\n\nSEPS225\n\n\nSSD1331\n\n\nSSD1351\n\n\nST7735\n\n\n\n\nThis integration is based on \nv1.3.3\n.\n\n\nOverview\n\n\nSPI Connection\n\n\nThe HSPI module is used (\nmore information\n), so certain pins are fixed:\n\n\n\n\nHSPI CLK  = GPIO14\n\n\nHSPI MOSI = GPIO13\n\n\nHSPI MISO = GPIO12 (not used)\n\n\n\n\nAll other pins can be assigned to any available GPIO:\n\n\n\n\nCS\n\n\nD/C\n\n\nRES (optional for some displays)\n\n\n\n\nAlso refer to the initialization sequence eg in \nGraphicsTest.lua\n:\n\n\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)\n\n\n\n\nLibrary Usage\n\n\nThe Lua bindings for this library closely follow ucglib's object oriented C++ API. Based on the ucg class, you create an object for your display type.\n\n\nILI9341 via SPI:\n\n\ncs  = 8 -- GPIO15, pull-down 10k to GND\ndc  = 4 -- GPIO2\nres = 0 -- GPIO16, RES is optional YMMV\ndisp = ucg.ili9341_18x240x320_hw_spi(cs, dc, res)\n\n\n\n\nThis object provides all of ucglib's methods to control the display.\nAgain, refer to \nGraphicsTest.lua\n to get an impression how this is achieved with Lua code. Visit the \nucglib homepage\n for technical details.\n\n\nDisplays\n\n\nTo get access to the display constructors, add the desired entries to the display table in \napp/include/ucg_config.h\n:\n\n\n#define UCG_DISPLAY_TABLE                          \\\n    UCG_DISPLAY_TABLE_ENTRY(ili9341_18x240x320_hw_spi, ucg_dev_ili9341_18x240x320, ucg_ext_ili9341_18) \\\n    UCG_DISPLAY_TABLE_ENTRY(st7735_18x128x160_hw_spi, ucg_dev_st7735_18x128x160, ucg_ext_st7735_18) \\\n\n\n\n\nFonts\n\n\nucglib comes with a wide range of fonts for small displays. Since they need to be compiled into the firmware image, you'd need to include them in \napp/include/ucg_config.h\n and recompile. Simply add the desired fonts to the font table:\n\n\n#define UCG_FONT_TABLE                              \\\n    UCG_FONT_TABLE_ENTRY(font_7x13B_tr)             \\\n    UCG_FONT_TABLE_ENTRY(font_helvB12_hr)           \\\n    UCG_FONT_TABLE_ENTRY(font_helvB18_hr)           \\\n    UCG_FONT_TABLE_ENTRY(font_ncenR12_tr)           \\\n    UCG_FONT_TABLE_ENTRY(font_ncenR14_hr)\n\n\n\n\nThey'll be available as \nucg.\nfont_name\n in Lua.\n\n\nDisplay Drivers\n\n\nInitialize a display via Hardware SPI.\n\n\n\n\nili9163_18x128x128_hw_spi()\n\n\nili9341_18x240x320_hw_spi()\n\n\npcf8833_16x132x132_hw_spi()\n\n\nseps225_16x128x128_uvis_hw_spi()\n\n\nssd1351_18x128x128_hw_spi()\n\n\nssd1351_18x128x128_ft_hw_spi()\n\n\nssd1331_18x96x64_uvis_hw_spi()\n\n\nst7735_18x128x160_hw_spi()\n\n\n\n\nSyntax\n\n\nucg.st7735_18x128x160_hw_spi(cs, dc[, res])\n\n\nParameters\n\n\n\n\ncs\n GPIO pin for /CS\n\n\ndc\n GPIO pin for DC\n\n\nres\n GPIO pin for /RES (optional)\n\n\n\n\nReturns\n\n\nucg display object\n\n\nExample\n\n\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0)\n\ncs  = 8 -- GPIO15, pull-down 10k to GND\ndc  = 4 -- GPIO2\nres = 0 -- GPIO16, RES is optional YMMV\ndisp = ucg.st7735_18x128x160_hw_spi(cs, dc, res)\n\n\n\n\nConstants\n\n\nConstants for various functions.\n\n\nucg.FONT_MODE_TRANSPARENT\n, \nucg.FONT_MODE_SOLID\n, \nucg.DRAW_UPPER_RIGHT\n,\n\nucg.DRAW_UPPER_LEFT\n, \nucg.DRAW_LOWER_RIGHT\n, \nucg.DRAW_LOWER_LEFT\n, \nucg.DRAW_ALL\n\n\nucg.font_7x13B_tr\n, ...\n\n\nucg.disp Sub-Module\n\n\nucg.disp:begin()\n\n\nSee \nucglib begin()\n.\n\n\nucg.disp:clearScreen()\n\n\nSee \nucglib clearScreen()\n.\n\n\nucg.disp:draw90Line()\n\n\nSee \nucglib draw90Line()\n.\n\n\nucg.disp:drawBox()\n\n\nSee \nucglib drawBox()\n.\n\n\nucg.disp:drawCircle()\n\n\nSee \nucglib drawCircle()\n.\n\n\nucg.disp:drawDisc()\n\n\nSee \nucglib drawDisc()\n.\n\n\nucg.disp:drawFrame()\n\n\nSee \nucglib drawFrame()\n.\n\n\nucg.disp:drawGlyph()\n\n\nSee \nucglib drawGlyph()\n.\n\n\nucg.disp:drawGradientBox()\n\n\nSee \nucglib drawGradientBox()\n.\n\n\nucg.disp:drawGradientLine()\n\n\nSee \nucglib drawGradientLine()\n.\n\n\nucg.disp:drawHLine()\n\n\nSee \nucglib drawHLine()\n.\n\n\nucg.disp:drawLine()\n\n\nSee \nucglib drawLine()\n.\n\n\nucg.disp:drawPixel()\n\n\nSee \nucglib drawPixel()\n.\n\n\nucg.disp:drawRBox()\n\n\nSee \nucglib drawRBox()\n.\n\n\nucg.disp:drawRFrame()\n\n\nSee \nucglib drawRFrame()\n.\n\n\nucg.disp:drawString()\n\n\nSee \nucglib drawString()\n.\n\n\nucg.disp:drawTetragon()\n\n\nSee \nucglib drawTetragon()\n.\n\n\nucg.disp:drawTriangle()\n\n\nSee \nucglib drawTriangle()\n.\n\n\nucg.disp:drawVLine()\n\n\nSee \nucglib drawVline()\n.\n\n\nucg.disp:getFontAscent()\n\n\nSee \nucglib getFontAscent()\n.\n\n\nucg.disp:getFontDescent()\n\n\nSee \nucglib getFontDescent()\n.\n\n\nucg.disp:getHeight()\n\n\nSee \nucglib getHeight()\n.\n\n\nucg.disp:getStrWidth()\n\n\nSee \nucglib getStrWidth()\n.\n\n\nucg.disp:getWidth()\n\n\nSee \nucglib getWidth()\n.\n\n\nucg.disp:print()\n\n\nSee \nucglib print()\n.\n\n\nucg.disp:setClipRange()\n\n\nSee \nucglib setClipRange()\n.\n\n\nucg.disp:setColor()\n\n\nSee \nucglib setColor()\n.\n\n\nucg.disp:setFont()\n\n\nucglib comes with a wide range of fonts for small displays. Since they need to be compiled into the firmware image, you'd need to include them in \napp/include/ucg_config.h\n and recompile. Simply add the desired fonts to the font table:\n\n\n#define UCG_FONT_TABLE                              \\\n    UCG_FONT_TABLE_ENTRY(font_7x13B_tr)             \\\n    UCG_FONT_TABLE_ENTRY(font_helvB12_hr)           \\\n    UCG_FONT_TABLE_ENTRY(font_helvB18_hr)           \\\n    UCG_FONT_TABLE_ENTRY(font_ncenR12_tr)           \\\n    UCG_FONT_TABLE_ENTRY(font_ncenR14_hr)\n\n\n\n\nThey'll be available as \nucg.\nfont_name\n in Lua.\n\n\nSyntax\n\n\ndisp:setFont(font)\n\n\nParameters\n\n\nfont\n constant to identify pre-compiled font\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\ndisp:setFont(ucg.font_7x13B_tr)\n\n\n\n\nSee also\n\n\nucglib setFont()\n\n\nucg.disp:setFontMode()\n\n\nSee \nucglib setFontMode()\n.\n\n\nucg.disp:setFontPosBaseline()\n\n\nSee \nucglib setFontPosBaseline()\n.\n\n\nucg.disp:setFontPosBottom()\n\n\nSee \nucglib setFontPosBottom()\n.\n\n\nucg.disp:setFontPosCenter()\n\n\nSee \nucglib setFontPosCenter()\n.\n\n\nucg.disp:setFontPosTop()\n\n\nSee \nucglib setFontPosTop()\n.\n\n\nucg.disp:setMaxClipRange()\n\n\nSee \nucglib setMaxClipRange()\n.\n\n\nucg.disp:setPrintDir()\n\n\nSee \nucglib setPrintDir()\n.\n\n\nucg.disp:setPrintPos()\n\n\nSee \nucglib setPrintPos()\n.\n\n\nucg.disp:setRotate90()\n\n\nSee \nucglib setRotate90()\n.\n\n\nucg.disp:setRotate180()\n\n\nSee \nucglib setRotate180()\n.\n\n\nucg.disp:setRotate270()\n\n\nSee \nucglib setRotate270()\n.\n\n\nucg.disp:setScale2x2()\n\n\nSee \nucglib setScale2x2()\n.\n\n\nucg.disp:undoClipRange()\n\n\nSee \nucglib undoClipRange()\n.\n\n\nucg.disp:undoRotate()\n\n\nSee \nucglib undoRotate()\n.\n\n\nucg.disp:undoScale()\n\n\nSee \nucglib undoScale()\n.", 
            "title": "ucg"
        }, 
        {
            "location": "/en/modules/ucg/#ucg-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-08-05  Oli Kraus ,  Arnim L\u00e4uger  Arnim L\u00e4uger  ucglib     Ucglib is a graphics library developed at  olikraus/ucglib  with support for color TFT displays. The NodeMCU firmware supports a subset of these:   ILI9163  ILI9341  PCF8833  SEPS225  SSD1331  SSD1351  ST7735   This integration is based on  v1.3.3 .", 
            "title": "ucg Module"
        }, 
        {
            "location": "/en/modules/ucg/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/en/modules/ucg/#spi-connection", 
            "text": "The HSPI module is used ( more information ), so certain pins are fixed:   HSPI CLK  = GPIO14  HSPI MOSI = GPIO13  HSPI MISO = GPIO12 (not used)   All other pins can be assigned to any available GPIO:   CS  D/C  RES (optional for some displays)   Also refer to the initialization sequence eg in  GraphicsTest.lua :  spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8)", 
            "title": "SPI Connection"
        }, 
        {
            "location": "/en/modules/ucg/#library-usage", 
            "text": "The Lua bindings for this library closely follow ucglib's object oriented C++ API. Based on the ucg class, you create an object for your display type.  ILI9341 via SPI:  cs  = 8 -- GPIO15, pull-down 10k to GND\ndc  = 4 -- GPIO2\nres = 0 -- GPIO16, RES is optional YMMV\ndisp = ucg.ili9341_18x240x320_hw_spi(cs, dc, res)  This object provides all of ucglib's methods to control the display.\nAgain, refer to  GraphicsTest.lua  to get an impression how this is achieved with Lua code. Visit the  ucglib homepage  for technical details.", 
            "title": "Library Usage"
        }, 
        {
            "location": "/en/modules/ucg/#displays", 
            "text": "To get access to the display constructors, add the desired entries to the display table in  app/include/ucg_config.h :  #define UCG_DISPLAY_TABLE                          \\\n    UCG_DISPLAY_TABLE_ENTRY(ili9341_18x240x320_hw_spi, ucg_dev_ili9341_18x240x320, ucg_ext_ili9341_18) \\\n    UCG_DISPLAY_TABLE_ENTRY(st7735_18x128x160_hw_spi, ucg_dev_st7735_18x128x160, ucg_ext_st7735_18) \\", 
            "title": "Displays"
        }, 
        {
            "location": "/en/modules/ucg/#fonts", 
            "text": "ucglib comes with a wide range of fonts for small displays. Since they need to be compiled into the firmware image, you'd need to include them in  app/include/ucg_config.h  and recompile. Simply add the desired fonts to the font table:  #define UCG_FONT_TABLE                              \\\n    UCG_FONT_TABLE_ENTRY(font_7x13B_tr)             \\\n    UCG_FONT_TABLE_ENTRY(font_helvB12_hr)           \\\n    UCG_FONT_TABLE_ENTRY(font_helvB18_hr)           \\\n    UCG_FONT_TABLE_ENTRY(font_ncenR12_tr)           \\\n    UCG_FONT_TABLE_ENTRY(font_ncenR14_hr)  They'll be available as  ucg. font_name  in Lua.", 
            "title": "Fonts"
        }, 
        {
            "location": "/en/modules/ucg/#display-drivers", 
            "text": "Initialize a display via Hardware SPI.   ili9163_18x128x128_hw_spi()  ili9341_18x240x320_hw_spi()  pcf8833_16x132x132_hw_spi()  seps225_16x128x128_uvis_hw_spi()  ssd1351_18x128x128_hw_spi()  ssd1351_18x128x128_ft_hw_spi()  ssd1331_18x96x64_uvis_hw_spi()  st7735_18x128x160_hw_spi()", 
            "title": "Display Drivers"
        }, 
        {
            "location": "/en/modules/ucg/#syntax", 
            "text": "ucg.st7735_18x128x160_hw_spi(cs, dc[, res])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ucg/#parameters", 
            "text": "cs  GPIO pin for /CS  dc  GPIO pin for DC  res  GPIO pin for /RES (optional)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ucg/#returns", 
            "text": "ucg display object", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ucg/#example", 
            "text": "spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0)\n\ncs  = 8 -- GPIO15, pull-down 10k to GND\ndc  = 4 -- GPIO2\nres = 0 -- GPIO16, RES is optional YMMV\ndisp = ucg.st7735_18x128x160_hw_spi(cs, dc, res)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ucg/#constants", 
            "text": "Constants for various functions.  ucg.FONT_MODE_TRANSPARENT ,  ucg.FONT_MODE_SOLID ,  ucg.DRAW_UPPER_RIGHT , ucg.DRAW_UPPER_LEFT ,  ucg.DRAW_LOWER_RIGHT ,  ucg.DRAW_LOWER_LEFT ,  ucg.DRAW_ALL  ucg.font_7x13B_tr , ...", 
            "title": "Constants"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdisp-sub-module", 
            "text": "", 
            "title": "ucg.disp Sub-Module"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispbegin", 
            "text": "See  ucglib begin() .", 
            "title": "ucg.disp:begin()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispclearscreen", 
            "text": "See  ucglib clearScreen() .", 
            "title": "ucg.disp:clearScreen()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdraw90line", 
            "text": "See  ucglib draw90Line() .", 
            "title": "ucg.disp:draw90Line()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawbox", 
            "text": "See  ucglib drawBox() .", 
            "title": "ucg.disp:drawBox()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawcircle", 
            "text": "See  ucglib drawCircle() .", 
            "title": "ucg.disp:drawCircle()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawdisc", 
            "text": "See  ucglib drawDisc() .", 
            "title": "ucg.disp:drawDisc()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawframe", 
            "text": "See  ucglib drawFrame() .", 
            "title": "ucg.disp:drawFrame()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawglyph", 
            "text": "See  ucglib drawGlyph() .", 
            "title": "ucg.disp:drawGlyph()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawgradientbox", 
            "text": "See  ucglib drawGradientBox() .", 
            "title": "ucg.disp:drawGradientBox()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawgradientline", 
            "text": "See  ucglib drawGradientLine() .", 
            "title": "ucg.disp:drawGradientLine()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawhline", 
            "text": "See  ucglib drawHLine() .", 
            "title": "ucg.disp:drawHLine()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawline", 
            "text": "See  ucglib drawLine() .", 
            "title": "ucg.disp:drawLine()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawpixel", 
            "text": "See  ucglib drawPixel() .", 
            "title": "ucg.disp:drawPixel()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawrbox", 
            "text": "See  ucglib drawRBox() .", 
            "title": "ucg.disp:drawRBox()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawrframe", 
            "text": "See  ucglib drawRFrame() .", 
            "title": "ucg.disp:drawRFrame()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawstring", 
            "text": "See  ucglib drawString() .", 
            "title": "ucg.disp:drawString()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawtetragon", 
            "text": "See  ucglib drawTetragon() .", 
            "title": "ucg.disp:drawTetragon()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawtriangle", 
            "text": "See  ucglib drawTriangle() .", 
            "title": "ucg.disp:drawTriangle()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispdrawvline", 
            "text": "See  ucglib drawVline() .", 
            "title": "ucg.disp:drawVLine()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispgetfontascent", 
            "text": "See  ucglib getFontAscent() .", 
            "title": "ucg.disp:getFontAscent()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispgetfontdescent", 
            "text": "See  ucglib getFontDescent() .", 
            "title": "ucg.disp:getFontDescent()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispgetheight", 
            "text": "See  ucglib getHeight() .", 
            "title": "ucg.disp:getHeight()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispgetstrwidth", 
            "text": "See  ucglib getStrWidth() .", 
            "title": "ucg.disp:getStrWidth()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispgetwidth", 
            "text": "See  ucglib getWidth() .", 
            "title": "ucg.disp:getWidth()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispprint", 
            "text": "See  ucglib print() .", 
            "title": "ucg.disp:print()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetcliprange", 
            "text": "See  ucglib setClipRange() .", 
            "title": "ucg.disp:setClipRange()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetcolor", 
            "text": "See  ucglib setColor() .", 
            "title": "ucg.disp:setColor()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetfont", 
            "text": "ucglib comes with a wide range of fonts for small displays. Since they need to be compiled into the firmware image, you'd need to include them in  app/include/ucg_config.h  and recompile. Simply add the desired fonts to the font table:  #define UCG_FONT_TABLE                              \\\n    UCG_FONT_TABLE_ENTRY(font_7x13B_tr)             \\\n    UCG_FONT_TABLE_ENTRY(font_helvB12_hr)           \\\n    UCG_FONT_TABLE_ENTRY(font_helvB18_hr)           \\\n    UCG_FONT_TABLE_ENTRY(font_ncenR12_tr)           \\\n    UCG_FONT_TABLE_ENTRY(font_ncenR14_hr)  They'll be available as  ucg. font_name  in Lua.", 
            "title": "ucg.disp:setFont()"
        }, 
        {
            "location": "/en/modules/ucg/#syntax_1", 
            "text": "disp:setFont(font)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ucg/#parameters_1", 
            "text": "font  constant to identify pre-compiled font", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ucg/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ucg/#example_1", 
            "text": "disp:setFont(ucg.font_7x13B_tr)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ucg/#see-also", 
            "text": "ucglib setFont()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetfontmode", 
            "text": "See  ucglib setFontMode() .", 
            "title": "ucg.disp:setFontMode()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetfontposbaseline", 
            "text": "See  ucglib setFontPosBaseline() .", 
            "title": "ucg.disp:setFontPosBaseline()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetfontposbottom", 
            "text": "See  ucglib setFontPosBottom() .", 
            "title": "ucg.disp:setFontPosBottom()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetfontposcenter", 
            "text": "See  ucglib setFontPosCenter() .", 
            "title": "ucg.disp:setFontPosCenter()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetfontpostop", 
            "text": "See  ucglib setFontPosTop() .", 
            "title": "ucg.disp:setFontPosTop()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetmaxcliprange", 
            "text": "See  ucglib setMaxClipRange() .", 
            "title": "ucg.disp:setMaxClipRange()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetprintdir", 
            "text": "See  ucglib setPrintDir() .", 
            "title": "ucg.disp:setPrintDir()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetprintpos", 
            "text": "See  ucglib setPrintPos() .", 
            "title": "ucg.disp:setPrintPos()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetrotate90", 
            "text": "See  ucglib setRotate90() .", 
            "title": "ucg.disp:setRotate90()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetrotate180", 
            "text": "See  ucglib setRotate180() .", 
            "title": "ucg.disp:setRotate180()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetrotate270", 
            "text": "See  ucglib setRotate270() .", 
            "title": "ucg.disp:setRotate270()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispsetscale2x2", 
            "text": "See  ucglib setScale2x2() .", 
            "title": "ucg.disp:setScale2x2()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispundocliprange", 
            "text": "See  ucglib undoClipRange() .", 
            "title": "ucg.disp:undoClipRange()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispundorotate", 
            "text": "See  ucglib undoRotate() .", 
            "title": "ucg.disp:undoRotate()"
        }, 
        {
            "location": "/en/modules/ucg/#ucgdispundoscale", 
            "text": "See  ucglib undoScale() .", 
            "title": "ucg.disp:undoScale()"
        }, 
        {
            "location": "/en/modules/websocket/", 
            "text": "Websocket Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2016-08-02\n\n\nLu\u00eds Fonseca\n\n\nLu\u00eds Fonseca\n\n\nwebsocket.c\n\n\n\n\n\n\n\n\nA websocket \nclient\n module that implements \nRFC6455\n (version 13) and provides a simple interface to send and receive messages.\n\n\nThe implementation supports fragmented messages, automatically respondes to ping requests and periodically pings if the server isn't communicating.\n\n\nSSL/TLS support\n\n\nTake note of constraints documented in the \nnet module\n. \n\n\nwebsocket.createClient()\n\n\nCreates a new websocket client. This client should be stored in a variable and will provide all the functions to handle a connection.\n\n\nWhen the connection becomes closed, the same client can still be reused - the callback functions are kept - and you can connect again to any server.\n\n\nBefore disposing the client, make sure to call \nws:close()\n.\n\n\nSyntax\n\n\nwebsocket.createClient()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nwebsocketclient\n\n\nExample\n\n\nlocal ws = websocket.createClient()\n-- ...\nws:close()\nws = nil\n\n\n\n\nwebsocket.client:close()\n\n\nCloses a websocket connection. The client issues a close frame and attemtps to gracefully close the websocket.\nIf server doesn't reply, the connection is terminated after a small timeout.\n\n\nThis function can be called even if the websocket isn't connected.\n\n\nThis function must \nalways\n be called before disposing the reference to the websocket client.\n\n\nSyntax\n\n\nwebsocket:close()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nws = websocket.createClient()\nws:close()\nws:close() -- nothing will happen\n\nws = nil -- fully dispose the client as lua will now gc it\n\n\n\n\nwebsocket.client:config(params)\n\n\nConfigures websocket client instance.\n\n\nSyntax\n\n\nwebsocket:config(params)\n\n\nParameters\n\n\n\n\nparams\n table with configuration parameters. Following keys are recognized:\n\n\nheaders\n table of extra request headers affecting every request\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nws = websocket.createClient()\nws:config({headers={['User-Agent']='NodeMCU'}})\n\n\n\n\nwebsocket.client:connect()\n\n\nAttempts to estabilish a websocket connection to the given URL.\n\n\nSyntax\n\n\nwebsocket:connect(url)\n\n\nParameters\n\n\n\n\nurl\n the URL for the websocket.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nws = websocket.createClient()\nws:connect('ws://echo.websocket.org')\n\n\n\n\nIf it fails, an error will be delivered via \nwebsocket:on(\"close\", handler)\n.\n\n\nwebsocket.client:on()\n\n\nRegisters the callback function to handle websockets events (there can be only one handler function registered per event type).\n\n\nSyntax\n\n\nwebsocket:on(eventName, function(ws, ...))\n\n\nParameters\n\n\n\n\neventName\n the type of websocket event to register the callback function. Those events are: \nconnection\n, \nreceive\n and \nclose\n.\n\n\nfunction(ws, ...)\n callback function.\nThe function first parameter is always the websocketclient.\nOther arguments are required depending on the event type. See example for more details.\nIf \nnil\n, any previously configured callback is unregistered.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nlocal ws = websocket.createClient()\nws:on(\nconnection\n, function(ws)\n  print('got ws connection')\nend)\nws:on(\nreceive\n, function(_, msg, opcode)\n  print('got message:', msg, opcode) -- opcode is 1 for text message, 2 for binary\nend)\nws:on(\nclose\n, function(_, status)\n  print('connection closed', status)\n  ws = nil -- required to lua gc the websocket client\nend)\n\nws:connect('ws://echo.websocket.org')\n\n\n\n\nNote that the close callback is also triggered if any error occurs.\n\n\nThe status code for the close, if not 0 then it represents an error, as described in the following table.\n\n\n\n\n\n\n\n\nStatus Code\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\n0\n\n\nUser requested close or the connection was terminated gracefully\n\n\n\n\n\n\n-1\n\n\nFailed to extract protocol from URL\n\n\n\n\n\n\n-2\n\n\nHostname is too large (\n256 chars)\n\n\n\n\n\n\n-3\n\n\nInvalid port number (must be \n0 and \n= 65535)\n\n\n\n\n\n\n-4\n\n\nFailed to extract hostname\n\n\n\n\n\n\n-5\n\n\nDNS failed to lookup hostname\n\n\n\n\n\n\n-6\n\n\nServer requested termination\n\n\n\n\n\n\n-7\n\n\nServer sent invalid handshake HTTP response (i.e. server sent a bad key)\n\n\n\n\n\n\n-8 to -14\n\n\nFailed to allocate memory to receive message\n\n\n\n\n\n\n-15\n\n\nServer not following FIN bit protocol correctly\n\n\n\n\n\n\n-16\n\n\nFailed to allocate memory to send message\n\n\n\n\n\n\n-17\n\n\nServer is not switching protocols\n\n\n\n\n\n\n-18\n\n\nConnect timeout\n\n\n\n\n\n\n-19\n\n\nServer is not responding to health checks nor communicating\n\n\n\n\n\n\n-99 to -999\n\n\nWell, something bad has happenned\n\n\n\n\n\n\n\n\nwebsocket.client:send()\n\n\nSends a message through the websocket connection.\n\n\nSyntax\n\n\nwebsocket:send(message, opcode)\n\n\nParameters\n\n\n\n\nmessage\n the data to send.\n\n\nopcode\n optionally set the opcode (default: 1, text message)\n\n\n\n\nReturns\n\n\nnil\n or an error if socket is not connected\n\n\nExample\n\n\nws = websocket.createClient()\nws:on(\nconnection\n, function()\n  ws:send('hello!')\nend)\nws:connect('ws://echo.websocket.org')", 
            "title": "websocket"
        }, 
        {
            "location": "/en/modules/websocket/#websocket-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2016-08-02  Lu\u00eds Fonseca  Lu\u00eds Fonseca  websocket.c     A websocket  client  module that implements  RFC6455  (version 13) and provides a simple interface to send and receive messages.  The implementation supports fragmented messages, automatically respondes to ping requests and periodically pings if the server isn't communicating.  SSL/TLS support  Take note of constraints documented in the  net module .", 
            "title": "Websocket Module"
        }, 
        {
            "location": "/en/modules/websocket/#websocketcreateclient", 
            "text": "Creates a new websocket client. This client should be stored in a variable and will provide all the functions to handle a connection.  When the connection becomes closed, the same client can still be reused - the callback functions are kept - and you can connect again to any server.  Before disposing the client, make sure to call  ws:close() .", 
            "title": "websocket.createClient()"
        }, 
        {
            "location": "/en/modules/websocket/#syntax", 
            "text": "websocket.createClient()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/websocket/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/websocket/#returns", 
            "text": "websocketclient", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/websocket/#example", 
            "text": "local ws = websocket.createClient()\n-- ...\nws:close()\nws = nil", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/websocket/#websocketclientclose", 
            "text": "Closes a websocket connection. The client issues a close frame and attemtps to gracefully close the websocket.\nIf server doesn't reply, the connection is terminated after a small timeout.  This function can be called even if the websocket isn't connected.  This function must  always  be called before disposing the reference to the websocket client.", 
            "title": "websocket.client:close()"
        }, 
        {
            "location": "/en/modules/websocket/#syntax_1", 
            "text": "websocket:close()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/websocket/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/websocket/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/websocket/#example_1", 
            "text": "ws = websocket.createClient()\nws:close()\nws:close() -- nothing will happen\n\nws = nil -- fully dispose the client as lua will now gc it", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/websocket/#websocketclientconfigparams", 
            "text": "Configures websocket client instance.", 
            "title": "websocket.client:config(params)"
        }, 
        {
            "location": "/en/modules/websocket/#syntax_2", 
            "text": "websocket:config(params)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/websocket/#parameters_2", 
            "text": "params  table with configuration parameters. Following keys are recognized:  headers  table of extra request headers affecting every request", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/websocket/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/websocket/#example_2", 
            "text": "ws = websocket.createClient()\nws:config({headers={['User-Agent']='NodeMCU'}})", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/websocket/#websocketclientconnect", 
            "text": "Attempts to estabilish a websocket connection to the given URL.", 
            "title": "websocket.client:connect()"
        }, 
        {
            "location": "/en/modules/websocket/#syntax_3", 
            "text": "websocket:connect(url)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/websocket/#parameters_3", 
            "text": "url  the URL for the websocket.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/websocket/#returns_3", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/websocket/#example_3", 
            "text": "ws = websocket.createClient()\nws:connect('ws://echo.websocket.org')  If it fails, an error will be delivered via  websocket:on(\"close\", handler) .", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/websocket/#websocketclienton", 
            "text": "Registers the callback function to handle websockets events (there can be only one handler function registered per event type).", 
            "title": "websocket.client:on()"
        }, 
        {
            "location": "/en/modules/websocket/#syntax_4", 
            "text": "websocket:on(eventName, function(ws, ...))", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/websocket/#parameters_4", 
            "text": "eventName  the type of websocket event to register the callback function. Those events are:  connection ,  receive  and  close .  function(ws, ...)  callback function.\nThe function first parameter is always the websocketclient.\nOther arguments are required depending on the event type. See example for more details.\nIf  nil , any previously configured callback is unregistered.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/websocket/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/websocket/#example_4", 
            "text": "local ws = websocket.createClient()\nws:on( connection , function(ws)\n  print('got ws connection')\nend)\nws:on( receive , function(_, msg, opcode)\n  print('got message:', msg, opcode) -- opcode is 1 for text message, 2 for binary\nend)\nws:on( close , function(_, status)\n  print('connection closed', status)\n  ws = nil -- required to lua gc the websocket client\nend)\n\nws:connect('ws://echo.websocket.org')  Note that the close callback is also triggered if any error occurs.  The status code for the close, if not 0 then it represents an error, as described in the following table.     Status Code  Explanation      0  User requested close or the connection was terminated gracefully    -1  Failed to extract protocol from URL    -2  Hostname is too large ( 256 chars)    -3  Invalid port number (must be  0 and  = 65535)    -4  Failed to extract hostname    -5  DNS failed to lookup hostname    -6  Server requested termination    -7  Server sent invalid handshake HTTP response (i.e. server sent a bad key)    -8 to -14  Failed to allocate memory to receive message    -15  Server not following FIN bit protocol correctly    -16  Failed to allocate memory to send message    -17  Server is not switching protocols    -18  Connect timeout    -19  Server is not responding to health checks nor communicating    -99 to -999  Well, something bad has happenned", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/websocket/#websocketclientsend", 
            "text": "Sends a message through the websocket connection.", 
            "title": "websocket.client:send()"
        }, 
        {
            "location": "/en/modules/websocket/#syntax_5", 
            "text": "websocket:send(message, opcode)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/websocket/#parameters_5", 
            "text": "message  the data to send.  opcode  optionally set the opcode (default: 1, text message)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/websocket/#returns_5", 
            "text": "nil  or an error if socket is not connected", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/websocket/#example_5", 
            "text": "ws = websocket.createClient()\nws:on( connection , function()\n  ws:send('hello!')\nend)\nws:connect('ws://echo.websocket.org')", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/", 
            "text": "WiFi Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-05-12\n\n\nZeroday\n\n\ndnc40085\n\n\nwifi.c\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\nThe WiFi subsystem is maintained by background tasks that must run periodically. Any function or task that takes longer than 15ms (milliseconds) may cause the WiFi subsystem to crash. To avoid these potential crashes, it is advised that the WiFi subsystem be suspended with \nwifi.suspend()\n prior to the execution of any tasks or functions that exceed this 15ms guideline.\n\n\n\n\nThe NodeMCU WiFi control is spread across several tables:\n\n\n\n\nwifi\n for overall WiFi configuration\n\n\nwifi.sta\n for station mode functions\n\n\nwifi.ap\n for wireless access point (WAP or simply AP) functions\n\n\nwifi.ap.dhcp\n for DHCP server control\n\n\nwifi.eventmon\n for wifi event monitor\n\n\n\n\nwifi.getchannel()\n\n\nGets the current WiFi channel.\n\n\nSyntax\n\n\nwifi.getchannel()\n\n\nParameters\n\n\nnil\n\n\nReturns\n\n\ncurrent WiFi channel\n\n\nwifi.getdefaultmode()\n\n\nGets default WiFi operation mode.\n\n\nSyntax\n\n\nwifi.getdefaultmode()\n\n\nParameters\n\n\nnil\n\n\nReturns\n\n\nThe WiFi mode, as one of the \nwifi.STATION\n, \nwifi.SOFTAP\n, \nwifi.STATIONAP\n or \nwifi.NULLMODE\n constants.\n\n\nSee also\n\n\nwifi.getmode()\n\n\nwifi.setmode()\n\n\nwifi.getmode()\n\n\nGets WiFi operation mode.\n\n\nSyntax\n\n\nwifi.getmode()\n\n\nParameters\n\n\nnil\n\n\nReturns\n\n\nThe WiFi mode, as one of the \nwifi.STATION\n, \nwifi.SOFTAP\n, \nwifi.STATIONAP\n or \nwifi.NULLMODE\n constants.\n\n\nSee also\n\n\nwifi.getdefaultmode()\n\n\nwifi.setmode()\n\n\nwifi.getphymode()\n\n\nGets WiFi physical mode.\n\n\nSyntax\n\n\nwifi.getphymode()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nThe current physical mode as one of \nwifi.PHYMODE_B\n, \nwifi.PHYMODE_G\n or \nwifi.PHYMODE_N\n.\n\n\nSee also\n\n\nwifi.setphymode()\n\n\nwifi.nullmodesleep()\n\n\nConfigures whether or not WiFi automatically goes to sleep in NULL_MODE. Enabled by default.\n\n\n\n\nNote\n\n\nThis function \ndoes not\n store it's setting in flash, if auto sleep in NULL_MODE is not desired, \nwifi.nullmodesleep(false)\n must be called after power-up, restart, or wake from deep sleep.\n\n\n\n\nSyntax\n\n\nwifi.nullmodesleep([enable])\n\n\nParameters\n\n\n\n\nenable\n\n\ntrue\n Enable WiFi auto sleep in NULL_MODE. (Default setting)\n\n\nfalse\n Disable WiFi auto sleep in NULL_MODE.\n\n\n\n\nReturns\n\n\n\n\nsleep_enabled\n Current/New NULL_MODE sleep setting\n\n\nIf \nwifi.nullmodesleep()\n is called with no arguments, current setting is returned.\n\n\nIf \nwifi.nullmodesleep()\n is called with \nenable\n argument, confirmation of new setting is returned.\n\n\n\n\n\n\n\n\nwifi.resume()\n\n\nWake up WiFi from suspended state or cancel pending wifi suspension.\n\n\n\n\nNote\n\n\nWifi resume occurs asynchronously, this means that the resume request will only be processed when control of the processor is passed back to the SDK (after MyResumeFunction() has completed). The resume callback also executes asynchronously and will only execute after wifi has resumed normal operation. \n\n\n\n\nSyntax\n\n\nwifi.resume([resume_cb])\n\n\nParameters\n\n\n\n\n\n\nresume_cb\n Callback to execute when WiFi wakes from suspension. \n !!! note \"Note:\"\n\n\nAny previously provided callbacks will be replaced!\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n--Resume wifi from timed or indefinite sleep\nwifi.resume()\n\n--Resume wifi from timed or indefinite sleep w/ resume callback\nwifi.resume(function() print(\nWiFi resume\n) end)\n\n\n\n\nSee also\n\n\n\n\nwifi.suspend()\n\n\nnode.sleep()\n\n\nnode.dsleep()\n\n\n\n\nwifi.setmode()\n\n\nConfigures the WiFi mode to use. NodeMCU can run in one of four WiFi modes:\n\n\n\n\nStation mode, where the NodeMCU device joins an existing network\n\n\nAccess point (AP) mode, where it creates its own network that others can join\n\n\nStation + AP mode, where it both creates its own network while at the same time being joined to another existing network\n\n\nWiFi off\n\n\n\n\nWhen using the combined Station + AP mode, the same channel will be used for both networks as the radio can only listen on a single channel.\n\n\n\n\nNote\n\n\nWiFi configuration will be retained until changed even if device is turned off.\n\n\n\n\nSyntax\n\n\nwifi.setmode(mode[, save])\n\n\nParameters\n\n\n\n\nmode\n value should be one of\n\n\nwifi.STATION\n for when the device is connected to a WiFi router. This is often done to give the device access to the Internet.\n\n\nwifi.SOFTAP\n for when the device is acting \nonly\n as an access point. This will allow you to see the device in the list of WiFi networks (unless you hide the SSID, of course). In this mode your computer can connect to the device, creating a local area network. Unless you change the value, the NodeMCU device will be given a local IP address of 192.168.4.1 and assign your computer the next available IP address, such as 192.168.4.2.\n\n\nwifi.STATIONAP\n is the combination of \nwifi.STATION\n and \nwifi.SOFTAP\n. It allows you to create a local WiFi connection \nand\n connect to another WiFi router.\n\n\nwifi.NULLMODE\n changing WiFi mode to NULL_MODE will put wifi into a low power state similar to MODEM_SLEEP, provided \nwifi.nullmodesleep(false)\n has not been called.\n\n\n\n\n\n\nsave\n choose whether or not to save wifi mode to flash\n\n\ntrue\n WiFi mode configuration \nwill\n be retained through power cycle. (Default)\n\n\nfalse\n WiFi mode configuration \nwill not\n be retained through power cycle.\n\n\n\n\n\n\n\n\nReturns\n\n\ncurrent mode after setup\n\n\nExample\n\n\nwifi.setmode(wifi.STATION)\n\n\n\n\nSee also\n\n\nwifi.getmode()\n\n\nwifi.getdefaultmode()\n\n\nwifi.setphymode()\n\n\nSets WiFi physical mode.\n\n\n\n\nwifi.PHYMODE_B\n\n    802.11b, more range, low Transfer rate, more current draw\n\n\nwifi.PHYMODE_G\n\n    802.11g, medium range, medium transfer rate, medium current draw\n\n\nwifi.PHYMODE_N\n\n    802.11n, least range, fast transfer rate, least current draw (STATION ONLY)\nInformation from the Espressif datasheet v4.3\n\n\n\n\n\n\n\n\n\n\nParameters\n\n\nTypical Power Usage\n\n\n\n\n\n\n\n\n\n\nTx 802.11b, CCK 11Mbps, P OUT=+17dBm\n\n\n170 mA\n\n\n\n\n\n\nTx 802.11g, OFDM 54Mbps, P OUT =+15dBm\n\n\n140 mA\n\n\n\n\n\n\nTx 802.11n, MCS7 65Mbps, P OUT =+13dBm\n\n\n120 mA\n\n\n\n\n\n\nRx 802.11b, 1024 bytes packet length, -80dBm\n\n\n50 mA\n\n\n\n\n\n\nRx 802.11g, 1024 bytes packet length, -70dBm\n\n\n56 mA\n\n\n\n\n\n\nRx 802.11n, 1024 bytes packet length, -65dBm\n\n\n56 mA\n\n\n\n\n\n\n\n\nSyntax\n\n\nwifi.setphymode(mode)\n\n\nParameters\n\n\nmode\n one of the following\n\n\n\n\nwifi.PHYMODE_B\n\n\nwifi.PHYMODE_G\n\n\nwifi.PHYMODE_N\n\n\n\n\nReturns\n\n\nphysical mode after setup\n\n\nSee also\n\n\nwifi.getphymode()\n\n\nwifi.startsmart()\n\n\nStarts to auto configuration, if success set up SSID and password automatically.\n\n\nIntended for use with SmartConfig apps, such as Espressif's \nAndroid \n iOS app\n.\n\n\nOnly usable in \nwifi.STATION\n mode.\n\n\n\n\nImportant\n\n\nSmartConfig is disabled by default and can be enabled by setting \nWIFI_SMART_ENABLE\n in \nuser_config.h\n before you build the firmware.\n\n\n\n\nSyntax\n\n\nwifi.startsmart(type, callback)\n\n\nParameters\n\n\n\n\ntype\n 0 for ESP_TOUCH, or 1 for AIR_KISS.\n\n\ncallback\n a callback function of the form \nfunction(ssid, password) end\n which gets called after configuration.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nwifi.setmode(wifi.STATION)\nwifi.startsmart(0,\n    function(ssid, password)\n        print(string.format(\nSuccess. SSID:%s ; PASSWORD:%s\n, ssid, password))\n    end\n)\n\n\n\n\nSee also\n\n\nwifi.stopsmart()\n\n\nwifi.stopsmart()\n\n\nStops the smart configuring process.\n\n\nSyntax\n\n\nwifi.stopsmart()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\nwifi.startsmart()\n\n\nwifi.suspend()\n\n\nSuspend Wifi to reduce current consumption. \n\n\n\n\nNote\n\n\nWifi suspension occurs asynchronously, this means that the suspend request will only be processed when control of the processor is passed back to the SDK (after MySuspendFunction() has completed). The suspend callback also executes asynchronously and will only execute after wifi has been successfully been suspended. \n\n\n\n\nSyntax\n\n\nwifi.suspend({duration[, suspend_cb, resume_cb, preserve_mode]})\n\n\nParameters\n\n\n\n\nduration\n Suspend duration in microseconds(\u03bcs). If a suspend duration of \n0\n is specified, suspension will be indefinite (Range: 0 or 50000 - 268435454 \u03bcs (0:4:28.000454))\n\n\nsuspend_cb\n Callback to execute when WiFi is suspended. (Optional)\n\n\nresume_cb\n Callback to execute when WiFi wakes from suspension. (Optional)\n\n\npreserve_mode\n preserve current WiFi mode through node sleep. (Optional, Default: true)  \n\n\nIf true, Station and StationAP modes will automatically reconnect to previously configured Access Point when NodeMCU resumes.\n\n\nIf false, discard WiFi mode and leave NodeMCU in \nwifi.NULL_MODE\n. WiFi mode will be restored to original mode on restart.\n\n\n\n\nReturns\n\n\n\n\nsuspend_state\n if no parameters are provided, current WiFi suspension state will be returned\n\n\nStates:\n\n\n0\n WiFi is awake.\n\n\n1\n WiFi suspension is pending. (Waiting for idle task)\n\n\n2\n WiFi is suspended.\n\n\n\n\nExample\n\n\n--get current wifi suspension state\nprint(wifi.suspend())\n\n--Suspend WiFi for 10 seconds with suspend/resume callbacks\n cfg={}\n cfg.duration=10*1000*1000\n cfg.resume_cb=function() print(\nWiFi resume\n) end\n cfg.suspend_cb=function() print(\nWiFi suspended\n) end\n\n wifi.suspend(cfg)\n\n--Suspend WiFi for 10 seconds with suspend/resume callbacks and discard WiFi mode\n cfg={}\n cfg.duration=10*1000*1000\n cfg.resume_cb=function() print(\nWiFi resume\n) end\n cfg.suspend_cb=function() print(\nWiFfi suspended\n) end\n cfg.preserve_mode=false\n\n wifi.suspend(cfg)\n\n\n\n\n\nSee also\n\n\n\n\nwifi.resume()\n\n\nnode.sleep()\n\n\nnode.dsleep()\n\n\n\n\nwifi.sta Module\n\n\nwifi.sta.autoconnect()\n\n\nAuto connects to AP in station mode.\n\n\nSyntax\n\n\nwifi.sta.autoconnect(auto)\n\n\nParameters\n\n\nauto\n 0 to disable auto connecting, 1 to enable auto connecting\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nwifi.sta.autoconnect(1)\n\n\n\n\nSee also\n\n\n\n\nwifi.sta.config()\n\n\nwifi.sta.connect()\n\n\nwifi.sta.disconnect()\n\n\n\n\nwifi.sta.changeap()\n\n\nSelect Access Point from list returned by \nwifi.sta.getapinfo()\n\n\nSyntax\n\n\nwifi.sta.changeap(ap_index)\n\n\nParameters\n\n\nap_index\n Index of Access Point you would like to change to. (Range:1-5)\n - Corresponds to index used by \nwifi.sta.getapinfo()\n and \nwifi.sta.getapindex()\n\n\nReturns\n\n\n\n\ntrue\n  Success\n\n\nfalse\n Failure\n\n\n\n\nExample\n\n\nwifi.sta.changeap(4)\n\n\n\n\nSee also\n\n\n\n\nwifi.sta.getapinfo()\n\n\nwifi.sta.getapindex()\n\n\n\n\nwifi.sta.clearconfig()\n\n\nClears the currently saved WiFi station configuration, erasing it from the flash. May be useful for certain factory-reset \nscenarios when a full \nnode.restore()\n is not desired, or to prepare for using\n\nEnd-User Setup\n so that the SoftAP is able to lock onto a single hardware radio channel.\n\n\nSyntax\n\n\nwifi.sta.clearconfig()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\ntrue\n  Success\n\n\nfalse\n Failure\n\n\n\n\nSee also\n\n\n\n\nwifi.sta.config()\n\n\nnode.restore()\n\n\n\n\nwifi.sta.config()\n\n\nSets the WiFi station configuration.\n\n\n\n\nNote\n\n\nIt is not advised to assume that the WiFi is connected at any time during initialization start-up. WiFi connection status should be validated either by using a WiFi event callback or by polling the status on a timer.\n\n\n\n\nSyntax\n\n\nwifi.sta.config(station_config)\n\n\nParameters\n\n\n\n\nstation_config\n table containing configuration data for station\n\n\nssid\n string which is less than 32 bytes.\n\n\npwd\n string which is 0-64. Empty string indicates an open WiFi access point. \nNote: WPA requires a minimum of 8-characters, but the ESP8266 can also connect to a WEP access point (a 40-bit WEP key can be provided as its corresponding 5-character ASCII string).\n\n\nauto\n defaults to true\n\n\ntrue\n to enable auto connect and connect to access point, hence with \nauto=true\n there's no need to call \nwifi.sta.connect()\n\n\nfalse\n to disable auto connect and remain disconnected from access point\n\n\n\n\n\n\nbssid\n string that contains the MAC address of the access point (optional)\n\n\nYou can set BSSID if you have multiple access points with the same SSID.\n\n\nIf you set BSSID for a specific SSID and would like to configure station to connect to the same SSID only without the BSSID requirement, you MUST first configure to station to a different SSID first, then connect to the desired SSID\n\n\nThe following formats are valid:\n\n\n\"DE:C1:A5:51:F1:ED\"\n\n\n\"AC-1D-1C-B1-0B-22\"\n\n\n\"DE AD BE EF 7A C0\"\n\n\n\n\n\n\n\n\n\n\nsave\n Save station configuration to flash. \n\n\ntrue\n configuration \nwill\n be retained through power cycle.  (Default).\n\n\nfalse\n configuration \nwill not\n be retained through power cycle.\n\n\n\n\n\n\nEvent callbacks will only be available if \nWIFI_SDK_EVENT_MONITOR_ENABLE\n is uncommented in \nuser_config.h\n\n\nPlease note: To ensure all station events are handled at boot time, all relevant callbacks must be registered as early as possible in \ninit.lua\n with either \nwifi.sta.config()\n or \nwifi.eventmon.register()\n.     \n\n\nconnected_cb\n: Callback to execute when station is connected to an access point. (Optional)\n\n\nItems returned in table :\n\n\nSSID\n: SSID of access point.  (format: string)\n\n\nBSSID\n: BSSID of access point.  (format: string)\n\n\nchannel\n: The channel the access point is on.  (format: number)\n\n\n\n\n\n\n\n\n\n\ndisconnected_cb\n: Callback to execute when station is disconnected from an access point. (Optional)\n\n\nItems returned in table :\n\n\nSSID\n: SSID of access point.   (format: string)\n\n\nBSSID\n: BSSID of access point. (format: string) \n\n\nREASON\n: See \nwifi.eventmon.reason\n below. (format: number)  \n\n\n\n\n\n\n\n\n\n\nauthmode_change_cb\n: Callback to execute when the access point has changed authorization mode. (Optional)    \n\n\nItems returned in table :\n\n\nold_auth_mode\n: Old wifi authorization mode. (format: number)  \n\n\nnew_auth_mode\n: New wifi authorization mode. (format: number)\n\n\n\n\n\n\ngot_ip_cb\n: Callback to execute when the station received an IP address from the access point. (Optional)\n\n\nItems returned in table :\n\n\nIP\n: The IP address assigned to the station.  (format: string)\n\n\nnetmask\n: Subnet mask.  (format: string)\n\n\ngateway\n: The IP address of the access point the station is connected to. (format: string)  \n\n\n\n\n\n\n\n\n\n\ndhcp_timeout_cb\n: Station DHCP request has timed out. (Optional)\n\n\nBlank table is returned.  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\ntrue\n  Success\n\n\nfalse\n Failure\n\n\n\n\nExample\n\n\n--connect to Access Point (DO NOT save config to flash)\nstation_cfg={}\nstation_cfg.ssid=\nNODE-AABBCC\n\nstation_cfg.pwd=\npassword\n\nwifi.sta.config(station_cfg)\n\n--connect to Access Point (DO save config to flash)\nstation_cfg={}\nstation_cfg.ssid=\nNODE-AABBCC\n\nstation_cfg.pwd=\npassword\n\nstation_cfg.save=true\nwifi.sta.config(station_cfg)\n\n--connect to Access Point with specific MAC address  \nstation_cfg={}\nstation_cfg.ssid=\nNODE-AABBCC\n\nstation_cfg.pwd=\npassword\n\nstation_cfg.bssid=\nAA:BB:CC:DD:EE:FF\n\nwifi.sta.config(station_cfg)\n\n--configure station but don't connect to Access point\nstation_cfg={}\nstation_cfg.ssid=\nNODE-AABBCC\n\nstation_cfg.pwd=\npassword\n\nstation_cfg.auto=false\nwifi.sta.config(station_cfg)\n\n\n\n\n\nSee also\n\n\n\n\nwifi.sta.clearconfig()\n\n\nwifi.sta.connect()\n\n\nwifi.sta.disconnect()\n\n\nwifi.sta.apinfo()\n\n\n\n\nwifi.sta.connect()\n\n\nConnects to the configured AP in station mode. You only ever need to call this if auto-connect was disabled in \nwifi.sta.config()\n.\n\n\nSyntax\n\n\nwifi.sta.connect([connected_cb])\n\n\nParameters\n\n\n\n\nconnected_cb\n: Callback to execute when station is connected to an access point. (Optional)\n\n\nItems returned in table :\n\n\nSSID\n: SSID of access point.  (format: string)\n\n\nBSSID\n: BSSID of access point.  (format: string)\n\n\nchannel\n: The channel the access point is on.  (format: number)\n\n\n\n\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\n\n\nwifi.sta.disconnect()\n\n\nwifi.sta.config()\n\n\n\n\nwifi.sta.disconnect()\n\n\nDisconnects from AP in station mode.\n\n\n\n\nNote\n\n\nPlease note that disconnecting from Access Point does not reduce power consumption. If power saving is your goal, please refer to the description for \nwifi.NULLMODE\n in the function \nwifi.setmode()\n for more details.\n\n\n\n\nSyntax\n\n\nwifi.sta.disconnect([disconnected_cb])\n\n\nParameters\n\n\n\n\ndisconnected_cb\n: Callback to execute when station is disconnected from an access point. (Optional)\n\n\nItems returned in table :\n\n\nSSID\n: SSID of access point.   (format: string)\n\n\nBSSID\n: BSSID of access point. (format: string) \n\n\nREASON\n: See \nwifi.eventmon.reason\n below. (format: number)  \n\n\n\n\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nSee also\n\n\n\n\nwifi.sta.config()\n\n\nwifi.sta.connect()\n\n\n\n\nwifi.sta.getap()\n\n\nScans AP list as a Lua table into callback function.\n\n\nSyntax\n\n\nwifi.sta.getap([[cfg], format,] callback(table))\n\n\nParameters\n\n\n\n\ncfg\n table that contains scan configuration\n\n\nssid\n SSID == nil, don't filter SSID\n\n\nbssid\n BSSID == nil, don't filter BSSID\n\n\nchannel\n channel == 0, scan all channels, otherwise scan set channel (default is 0)\n\n\nshow_hidden\n show_hidden == 1, get info for router with hidden SSID (default is 0)\n\n\n\n\n\n\nformat\n select output table format, defaults to 0\n\n\n0: old format (SSID : Authmode, RSSI, BSSID, Channel), any duplicate SSIDs will be discarded\n\n\n1: new format (BSSID : SSID, RSSI, auth mode, Channel)\n\n\n\n\n\n\ncallback(table)\n a callback function to receive the AP table when the scan is done. This function receives a table, the key is the BSSID, the value is other info in format: SSID, RSSID, auth mode, channel.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- print AP list in old format (format not defined)\nfunction listap(t)\n    for k,v in pairs(t) do\n        print(k..\n : \n..v)\n    end\nend\nwifi.sta.getap(listap)\n\n-- Print AP list that is easier to read\nfunction listap(t) -- (SSID : Authmode, RSSI, BSSID, Channel)\n    print(\n\\n\n..string.format(\n%32s\n,\nSSID\n)..\n\\tBSSID\\t\\t\\t\\t  RSSI\\t\\tAUTHMODE\\tCHANNEL\n)\n    for ssid,v in pairs(t) do\n        local authmode, rssi, bssid, channel = string.match(v, \n([^,]+),([^,]+),([^,]+),([^,]+)\n)\n        print(string.format(\n%32s\n,ssid)..\n\\t\n..bssid..\n\\t  \n..rssi..\n\\t\\t\n..authmode..\n\\t\\t\\t\n..channel)\n    end\nend\nwifi.sta.getap(listap)\n\n-- print AP list in new format\nfunction listap(t)\n    for k,v in pairs(t) do\n        print(k..\n : \n..v)\n    end\nend\nwifi.sta.getap(1, listap)\n\n-- Print AP list that is easier to read\nfunction listap(t) -- (SSID : Authmode, RSSI, BSSID, Channel)\n    print(\n\\n\\t\\t\\tSSID\\t\\t\\t\\t\\tBSSID\\t\\t\\t  RSSI\\t\\tAUTHMODE\\t\\tCHANNEL\n)\n    for bssid,v in pairs(t) do\n        local ssid, rssi, authmode, channel = string.match(v, \n([^,]+),([^,]+),([^,]+),([^,]*)\n)\n        print(string.format(\n%32s\n,ssid)..\n\\t\n..bssid..\n\\t  \n..rssi..\n\\t\\t\n..authmode..\n\\t\\t\\t\n..channel)\n    end\nend\nwifi.sta.getap(1, listap)\n\n--check for specific AP\nfunction listap(t)\n    print(\n\\n\\t\\t\\tSSID\\t\\t\\t\\t\\tBSSID\\t\\t\\t  RSSI\\t\\tAUTHMODE\\t\\tCHANNEL\n)\n    for bssid,v in pairs(t) do\n        local ssid, rssi, authmode, channel = string.match(v, \n([^,]+),([^,]+),([^,]+),([^,]*)\n)\n        print(string.format(\n%32s\n,ssid)..\n\\t\n..bssid..\n\\t  \n..rssi..\n\\t\\t\n..authmode..\n\\t\\t\\t\n..channel)\n    end\nend\nscan_cfg = {}\nscan_cfg.ssid = \nmyssid\n\nscan_cfg.bssid = \nAA:AA:AA:AA:AA:AA\n\nscan_cfg.channel = 0\nscan_cfg.show_hidden = 1\nwifi.sta.getap(scan_cfg, 1, listap)\n\n--get RSSI for currently configured AP\nfunction listap(t)\n    for bssid,v in pairs(t) do\n        local ssid, rssi, authmode, channel = string.match(v, \n([^,]+),([^,]+),([^,]+),([^,]*)\n)\n        print(\nCURRENT RSSI IS: \n..rssi)\n    end\nend\nssid, tmp, bssid_set, bssid=wifi.sta.getconfig()\n\nscan_cfg = {}\nscan_cfg.ssid = ssid\nif bssid_set == 1 then scan_cfg.bssid = bssid else scan_cfg.bssid = nil end\nscan_cfg.channel = wifi.getchannel()\nscan_cfg.show_hidden = 0\nssid, tmp, bssid_set, bssid=nil, nil, nil, nil\nwifi.sta.getap(scan_cfg, 1, listap)\n\n\n\n\n\nSee also\n\n\nwifi.sta.getip()\n\n\nwifi.sta.getapindex()\n\n\nGet index of current Access Point stored in AP cache.\n\n\nSyntax\n\n\nwifi.sta.getapindex()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\ncurrent_index\n index of currently selected Access Point. (Range:1-5)\n\n\nExample\n\n\nprint(\nthe index of the currently selected AP is: \n..wifi.sta.getapindex())\n\n\n\n\nSee also\n\n\n\n\nwifi.sta.getapindex()\n\n\nwifi.sta.apinfo()\n\n\nwifi.sta.apchange()\n\n\n\n\nwifi.sta.getapinfo()\n\n\nGet information of APs cached by ESP8266 station.\n\n\n\n\nNote\nAny Access Points configured with save disabled \nwifi.sta.config({save=false})\n will populate this list (appearing to overwrite APs stored in flash) until restart.\n\n\n\n\n\n\nSyntax\n\n\nwifi.sta.getapinfo()\n\n\nParameters\n\n\nnil\n\n\nReturns\n\n\n\n\nap_info\n\n\nqty\n quantity of APs returned\n\n\n1-5\n index of AP. (the index corresponds to index used by \nwifi.sta.changeap()\n and \nwifi.sta.getapindex()\n)\n\n\nssid\n  ssid of Access Point\n\n\npwd\n password for Access Point, \nnil\n if no password was configured \n\n\nbssid\n MAC address of Access Point\n\n\nnil\n will be returned if no MAC address was configured during station configuration.\n\n\n\n\n\n\n\n\nExample\n\n\n--print stored access point info\ndo\n  for k,v in pairs(wifi.sta.getapinfo()) do\n    if (type(v)==\ntable\n) then\n      print(\n \n..k..\n : \n..type(v))\n      for k,v in pairs(v) do\n        print(\n\\t\\t\n..k..\n : \n..v)\n      end\n    else\n      print(\n \n..k..\n : \n..v)\n    end\n  end\nend\n\n--print stored access point info(formatted)\ndo\n  local x=wifi.sta.getapinfo()\n  local y=wifi.sta.getapindex()\n  print(\n\\n Number of APs stored in flash:\n, x.qty)\n  print(string.format(\n  %-6s %-32s %-64s %-18s\n, \nindex:\n, \nSSID:\n, \nPassword:\n, \nBSSID:\n)) \n  for i=1, (x.qty), 1 do\n    print(string.format(\n %s%-6d %-32s %-64s %-18s\n,(i==y and \n or \n \n), i, x[i].ssid, x[i].pwd and x[i].pwd or type(nil), x[i].bssid and x[i].bssid or type(nil)))\n  end\nend\n\n\n\n\nSee also\n\n\n\n\nwifi.sta.getapindex()\n\n\nwifi.sta.setaplimit()\n\n\nwifi.sta.changeap()\n\n\nwifi.sta.config()\n\n\n\n\nwifi.sta.getbroadcast()\n\n\nGets the broadcast address in station mode.\n\n\nSyntax\n\n\nwifi.sta.getbroadcast()\n\n\nParameters\n\n\nnil\n\n\nReturns\n\n\nbroadcast address as string, for example \"192.168.0.255\",\nreturns \nnil\n if IP address = \"0.0.0.0\".\n\n\nSee also\n\n\nwifi.sta.getip()\n\n\nwifi.sta.getconfig()\n\n\nGets the WiFi station configuration.\n\n\nSyntax\n\n\nwifi.sta.getconfig()\n\n\nParameters\n\n\n\n\nreturn_table\n\n\ntrue\n returns data in a table\n\n\nfalse\n returns data in the old format (default)\n\n\n\n\n\n\n\n\nReturns\n\n\nIf \nreturn_table\n is \ntrue\n:\n\n\n\n\nconfig_table\n\n\nssid\n ssid of Access Point.\n\n\npwd\n password to Access Point, \nnil\n if no password was configured \n\n\nbssid_set\n will return \ntrue\n if the station was configured specifically to connect to the AP with the matching \nbssid\n. \n\n\nbssid\n If a connection has been made to the configured AP this field will contain the AP's MAC address. Otherwise \"ff:ff:ff:ff:ff:ff\" will be returned.\n\n\n\n\n\n\n\n\nIf \nreturn_table\n is \nfalse\n:\n\n\n\n\nssid, password, bssid_set, bssid, if \nbssid_set\n is equal to \n0\n then \nbssid\n is irrelevant\n\n\n\n\nExample\n\n\n--Get current Station configuration (NEW FORMAT)\ndo\nlocal sta_config=wifi.sta.getconfig(true)\nprint(string.format(\n\\tCurrent station config\\n\\tssid:\\\n%s\\\n\\tpassword:\\\n%s\\\n\\n\\tbssid:\\\n%s\\\n\\tbssid_set:%s\n, sta_config.ssid, sta_config.pwd, sta_config.bssid, (sta_config.bssid_set and \ntrue\n or \nfalse\n)))\nend\n\n--Get current Station configuration (OLD FORMAT)\nssid, password, bssid_set, bssid=wifi.sta.getconfig()\nprint(\n\\nCurrent Station configuration:\\nSSID : \n..ssid\n..\n\\nPassword  : \n..password\n..\n\\nBSSID_set  : \n..bssid_set\n..\n\\nBSSID: \n..bssid..\n\\n\n)\nssid, password, bssid_set, bssid=nil, nil, nil, nil\n\n\n\n\nSee also\n\n\n\n\nwifi.sta.getdefaultconfig()\n\n\nwifi.sta.connect()\n\n\nwifi.sta.disconnect()\n\n\n\n\nwifi.sta.getdefaultconfig()\n\n\nGets the default WiFi station configuration stored in flash.\n\n\nSyntax\n\n\nwifi.sta.getdefaultconfig(return_table)\n\n\nParameters\n\n\n\n\nreturn_table\n\n\ntrue\n returns data in a table\n\n\nfalse\n returns data in the old format (default)\n\n\n\n\n\n\n\n\nReturns\n\n\nIf \nreturn_table\n is \ntrue\n:\n\n\n\n\nconfig_table\n\n\nssid\n ssid of Access Point.\n\n\npwd\n password to Access Point, \nnil\n if no password was configured\n\n\nbssid_set\n will return \ntrue\n if the station was configured specifically to connect to the AP with the matching \nbssid\n. \n\n\nbssid\n If a connection has been made to the configured AP this field will contain the AP's MAC address. Otherwise \"ff:ff:ff:ff:ff:ff\" will be returned.\n\n\n\n\n\n\n\n\nIf \nreturn_table\n is \nfalse\n:\n\n\n\n\nssid, password, bssid_set, bssid, if \nbssid_set\n is equal to \n0\n then \nbssid\n is irrelevant\n\n\n\n\nExample\n\n\n--Get default Station configuration (NEW FORMAT)\ndo\nlocal def_sta_config=wifi.sta.getdefaultconfig(true)\nprint(string.format(\n\\tDefault station config\\n\\tssid:\\\n%s\\\n\\tpassword:\\\n%s\\\n\\n\\tbssid:\\\n%s\\\n\\tbssid_set:%s\n, def_sta_config.ssid, def_sta_config.pwd, def_sta_config.bssid, (def_sta_config.bssid_set and \ntrue\n or \nfalse\n)))\nend\n\n--Get default Station configuration (OLD FORMAT)\nssid, password, bssid_set, bssid=wifi.sta.getdefaultconfig()\nprint(\n\\nCurrent Station configuration:\\nSSID : \n..ssid\n..\n\\nPassword  : \n..password\n..\n\\nBSSID_set  : \n..bssid_set\n..\n\\nBSSID: \n..bssid..\n\\n\n)\nssid, password, bssid_set, bssid=nil, nil, nil, nil\n\n\n\n\nSee also\n\n\n\n\nwifi.sta.getconfig()\n\n\nwifi.sta.connect()\n\n\nwifi.sta.disconnect()\n\n\n\n\nwifi.sta.gethostname()\n\n\nGets current station hostname.\n\n\nSyntax\n\n\nwifi.sta.gethostname()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\ncurrently configured hostname\n\n\nExample\n\n\nprint(\nCurrent hostname is: \\\n..wifi.sta.gethostname()..\n\\\n)\n\n\n\n\nwifi.sta.getip()\n\n\nGets IP address, netmask, and gateway address in station mode.\n\n\nSyntax\n\n\nwifi.sta.getip()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nIP address, netmask, gateway address as string, for example \"192.168.0.111\". Returns \nnil\n if IP = \"0.0.0.0\".\n\n\nExample\n\n\n-- print current IP address, netmask, gateway\nprint(wifi.sta.getip())\n-- 192.168.0.111  255.255.255.0  192.168.0.1\nip = wifi.sta.getip()\nprint(ip)\n-- 192.168.0.111\nip, nm = wifi.sta.getip()\nprint(nm)\n-- 255.255.255.0\n\n\n\n\nSee also\n\n\nwifi.sta.getmac()\n\n\nwifi.sta.getmac()\n\n\nGets MAC address in station mode.\n\n\nSyntax\n\n\nwifi.sta.getmac()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nMAC address as string e.g. \"18:fe:34:a2:d7:34\"\n\n\nSee also\n\n\nwifi.sta.getip()\n\n\nwifi.sta.getrssi()\n\n\nGet RSSI(Received Signal Strength Indicator) of the Access Point which ESP8266 station connected to.\n\n\nSyntax\n\n\nwifi.sta.getrssi()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\n\n\nIf station is connected to an access point, \nrssi\n is returned.\n\n\nIf station is not connected to an access point, \nnil\n is returned.  \n\n\n\n\nExample\n\n\nRSSI=wifi.sta.getrssi()\nprint(\nRSSI is\n, RSSI)\n\n\n\n\nwifi.sta.setaplimit()\n\n\nSet Maximum number of Access Points to store in flash.\n - This value is written to flash\n\n\n\n\nAttention\n\n\nNew setting will not take effect until restart. \n\n\n\n\n\n\nNote\n\n\nIf 5 Access Points are stored and AP limit is set to 4, the AP at index 5 will remain until \nnode.restore()\n is called or AP limit is set to 5 and AP is overwritten.\n\n\n\n\nSyntax\n\n\nwifi.sta.setaplimit(qty)\n\n\nParameters\n\n\nqty\n Quantity of Access Points to store in flash. Range: 1-5 (Default: 1)\n\n\nReturns\n\n\n\n\ntrue\n  Success\n\n\nfalse\n Failure\n\n\n\n\nExample\n\n\nwifi.sta.setaplimit(5)\n\n\n\n\nSee also\n\n\n\n\nwifi.sta.getapinfo()\n\n\n\n\nwifi.sta.sethostname()\n\n\nSets station hostname.\n\n\nSyntax\n\n\nwifi.sta.sethostname(hostname)\n\n\nParameters\n\n\nhostname\n must only contain letters, numbers and hyphens('-') and be 32 characters or less with first and last character being alphanumeric\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nif (wifi.sta.sethostname(\nNodeMCU\n) == true) then\n    print(\nhostname was successfully changed\n)\nelse\n    print(\nhostname was not changed\n)\nend\n\n\n\n\nwifi.sta.setip()\n\n\nSets IP address, netmask, gateway address in station mode.\n\n\nSyntax\n\n\nwifi.sta.setip(cfg)\n\n\nParameters\n\n\ncfg\n table contain IP address, netmask, and gateway\n\n\n{\n  ip = \n192.168.0.111\n,\n  netmask = \n255.255.255.0\n,\n  gateway = \n192.168.0.1\n\n}\n\n\n\n\nReturns\n\n\ntrue if success, false otherwise\n\n\nSee also\n\n\nwifi.sta.setmac()\n\n\nwifi.sta.setmac()\n\n\nSets MAC address in station mode.\n\n\nSyntax\n\n\nwifi.sta.setmac(mac)\n\n\nParameters\n\n\nMAC address in string e.g. \"DE:AD:BE:EF:7A:C0\"\n\n\nReturns\n\n\ntrue if success, false otherwise\n\n\nExample\n\n\nprint(wifi.sta.setmac(\nDE:AD:BE:EF:7A:C0\n))\n\n\n\n\nSee also\n\n\nwifi.sta.setip()\n\n\nwifi.sta.sleeptype()\n\n\nConfigures the WiFi modem sleep type to be used while station is connected to an Access Point.\n\n\n\n\nNote\n\n\nDoes not apply to \nwifi.SOFTAP\n, \nwifi.STATIONAP\n or \nwifi.NULLMODE\n.\n\n\n\n\nSyntax\n\n\nwifi.sta.sleeptype(type_wanted)\n\n\nParameters\n\n\ntype_wanted\n one of the following:\n\n\n\n\nwifi.NONE_SLEEP\n to keep the modem on at all times\n\n\nwifi.LIGHT_SLEEP\n to allow the CPU to power down under some circumstances\n\n\nwifi.MODEM_SLEEP\n to power down the modem as much as possible\n\n\n\n\nReturns\n\n\nThe actual sleep mode set, as one of \nwifi.NONE_SLEEP\n, \nwifi.LIGHT_SLEEP\n or \nwifi.MODEM_SLEEP\n.\n\n\nwifi.sta.status()\n\n\nGets the current status in station mode.\n\n\nSyntax\n\n\nwifi.sta.status()\n\n\nParameters\n\n\nnil\n\n\nReturns\n\n\nThe current state which can be one of the following:\n\n\n\n\nwifi.STA_IDLE\n\n\nwifi.STA_CONNECTING\n\n\nwifi.STA_WRONGPWD\n\n\nwifi.STA_APNOTFOUND\n\n\nwifi.STA_FAIL\n\n\nwifi.STA_GOTIP\n\n\n\n\nwifi.ap Module\n\n\nwifi.ap.config()\n\n\nSets SSID and password in AP mode. Be sure to make the password at least 8 characters long! If you don't it will default to \nno\n password and not set the SSID! It will still work as an access point but use a default SSID like e.g. NODE_9997C3.\n\n\nSyntax\n\n\nwifi.ap.config(cfg)\n\n\nParameters\n\n\n\n\ncfg\n table to hold configuration\n\n\nssid\n SSID chars 1-32\n\n\npwd\n password chars 8-64\n\n\nauth\n authentication method, one of \nwifi.OPEN\n (default), \nwifi.WPA_PSK\n, \nwifi.WPA2_PSK\n, \nwifi.WPA_WPA2_PSK\n\n\nchannel\n channel number 1-14 default = 6\n\n\nhidden\n false = not hidden, true = hidden, default = false\n\n\nmax\n maximum number of connections 1-4 default=4\n\n\nbeacon\n beacon interval time in range 100-60000, default = 100\n\n\nsave\n save configuration to flash.\n\n\ntrue\n configuration \nwill\n be retained through power cycle. (Default)\n\n\nfalse\n configuration \nwill not\n be retained through power cycle.\n\n\n\n\n\n\nEvent callbacks will only be available if \nWIFI_SDK_EVENT_MONITOR_ENABLE\n is uncommented in \nuser_config.h\n\n\nPlease note: To ensure all SoftAP events are handled at boot time, all relevant callbacks must be registered as early as possible in \ninit.lua\n with either \nwifi.ap.config()\n or \nwifi.eventmon.register()\n.     \n\n\nstaconnected_cb\n: Callback executed when a new client has connected to the access point. (Optional)\n\n\nItems returned in table :\n\n\nMAC\n: MAC address of client that has connected.  \n\n\nAID\n: SDK provides no details concerning this return value.  \n\n\n\n\n\n\n\n\n\n\nstadisconnected_cb\n: Callback executed when a client has disconnected from the access point. (Optional)  \n\n\nItems returned in table :\n\n\nMAC\n: MAC address of client that has disconnected.  \n\n\nAID\n: SDK provides no details concerning this return value.  \n\n\n\n\n\n\n\n\n\n\nprobereq_cb\n: Callback executed when a probe request was received. (Optional)\n\n\nItems returned in table :\n\n\nMAC\n: MAC address of the client that is probing the access point.  \n\n\nRSSI\n: Received Signal Strength Indicator of client.  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\ntrue\n  Success\n\n\nfalse\n Failure\n\n\n\n\nExample:\n\n\n cfg={}\n cfg.ssid=\nmyssid\n\n cfg.pwd=\nmypassword\n\n wifi.ap.config(cfg)\n\n\n\n\nwifi.ap.deauth()\n\n\nDeauths (forcibly removes) a client from the ESP access point by sending a corresponding IEEE802.11 management packet (first) and removing the client from it's data structures (afterwards).\n\n\nThe IEEE802.11 reason code used is 2 for \"Previous authentication no longer valid\"(AUTH_EXPIRE).\n\n\nSyntax\n\n\nwifi.ap.deauth([MAC])\n\n\nParameters\n\n\n\n\nMAC\n address of station to be deauthed.\n\n\nNote: if this field is left blank, all currently connected stations will get deauthed.\n\n\n\n\n\n\n\n\nReturns\n\n\nReturns true unless called while the ESP is in the STATION opmode\n\n\nExample\n\n\nallowed_mac_list={\n18:fe:34:00:00:00\n, \n18:fe:34:00:00:01\n}\n\nwifi.eventmon.register(wifi.eventmon.AP_STACONNECTED, function(T)\n  print(\n\\n\\tAP - STATION CONNECTED\n..\n\\n\\tMAC: \n..T.MAC..\n\\n\\tAID: \n..T.AID)\n  if(allowed_mac_list~=nil) then\n    for _, v in pairs(allowed_mac_list) do\n      if(v == T.MAC) then return end\n    end\n  end\n  wifi.ap.deauth(T.MAC)\n  print(\n\\tStation DeAuthed!\n)\nend)\n\n\n\n\n\nSee also\n\n\nwifi.eventmon.register()\n\n\nwifi.eventmon.reason()\n\n\nwifi.ap.getbroadcast()\n\n\nGets broadcast address in AP mode.\n\n\nSyntax\n\n\nwifi.ap.getbroadcast()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nbroadcast address in string, for example \"192.168.0.255\",\nreturns \nnil\n if IP address = \"0.0.0.0\".\n\n\nExample\n\n\nbc = wifi.ap.getbroadcast()\nprint(bc)\n-- 192.168.0.255\n\n\n\n\nSee also\n\n\nwifi.ap.getip()\n\n\nwifi.ap.getclient()\n\n\nGets table of clients connected to device in AP mode.\n\n\nSyntax\n\n\nwifi.ap.getclient()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\ntable of connected clients\n\n\nExample\n\n\ntable={}\ntable=wifi.ap.getclient()\nfor mac,ip in pairs(table) do\n    print(mac,ip)\nend\n\n-- or shorter\nfor mac,ip in pairs(wifi.ap.getclient()) do\n    print(mac,ip)\nend\n\n\n\n\nwifi.ap.getconfig()\n\n\nGets the current SoftAP configuration.\n\n\nSyntax\n\n\nwifi.ap.getconfig(return_table)\n\n\nParameters\n\n\n\n\nreturn_table\n\n\ntrue\n returns data in a table\n\n\nfalse\n returns data in the old format (default)\n\n\n\n\n\n\n\n\nReturns\n\n\nIf \nreturn_table\n is true:\n\n\n\n\nconfig_table\n\n\nssid\n Network name\n\n\npwd\n Password, \nnil\n if no password was configured   - \nauth\n Authentication Method (\nwifi.OPEN\n, \nwifi.WPA_PSK\n, \nwifi.WPA2_PSK\n or \nwifi.WPA_WPA2_PSK\n)\n\n\nchannel\n Channel number\n\n\nhidden\n \nfalse\n = not hidden, \ntrue\n = hidden\n\n\nmax\n Maximum number of client connections\n\n\nbeacon\n Beacon interval\n\n\n\n\n\n\n\n\nIf \nreturn_table\n is false:\n\n\n\n\nssid, password, if \nbssid_set\n is equal to 0 then \nbssid\n is irrelevant\n\n\n\n\nExample\n\n\n--Get SoftAP configuration table (NEW FORMAT)\ndo\n  print(\n\\n  Current SoftAP configuration:\n)\n  for k,v in pairs(wifi.ap.getconfig(true)) do\n      print(\n   \n..k..\n :\n,v)\n  end\nend\n\n--Get current SoftAP configuration (OLD FORMAT)\ndo\n  local ssid, password=wifi.ap.getconfig()\n  print(\n\\n  Current SoftAP configuration:\\n   SSID : \n..ssid..\n    \n\\n   Password  :\n,password)\n  ssid, password=nil, nil\nend\n\n\n\n\nwifi.ap.getdefaultconfig()\n\n\nGets the default SoftAP configuration stored in flash.\n\n\nSyntax\n\n\nwifi.ap.getdefaultconfig(return_table)\n\n\nParameters\n\n\n\n\nreturn_table\n\n\ntrue\n returns data in a table\n\n\nfalse\n returns data in the old format (default)\n\n\n\n\n\n\n\n\nReturns\n\n\nIf \nreturn_table\n is true:\n\n\n\n\nconfig_table\n\n\nssid\n Network name\n\n\npwd\n Password, \nnil\n if no password was configured   - \nauth\n Authentication Method (\nwifi.OPEN\n, \nwifi.WPA_PSK\n, \nwifi.WPA2_PSK\n or \nwifi.WPA_WPA2_PSK\n)\n\n\nchannel\n Channel number\n\n\nhidden\n \nfalse\n = not hidden, \ntrue\n = hidden\n\n\nmax\n Maximum number of client connections\n\n\nbeacon\n Beacon interval\n\n\n\n\n\n\n\n\nIf \nreturn_table\n is false:\n\n\n\n\nssid, password, if \nbssid_set\n is equal to 0 then \nbssid\n is irrelevant\n\n\n\n\nExample\n\n\n--Get default SoftAP configuration table (NEW FORMAT)\ndo\n  print(\n\\n  Default SoftAP configuration:\n)\n  for k,v in pairs(wifi.ap.getdefaultconfig(true)) do\n      print(\n   \n..k..\n :\n,v)\n  end\nend\n\n--Get default SoftAP configuration (OLD FORMAT)\ndo\n  local ssid, password=wifi.ap.getdefaultconfig()\n  print(\n\\n  Default SoftAP configuration:\\n   SSID : \n..ssid..\n    \n\\n   Password  :\n,password)\n  ssid, password=nil, nil\nend\n\n\n\n\nwifi.ap.getip()\n\n\nGets IP address, netmask and gateway in AP mode.\n\n\nSyntax\n\n\nwifi.ap.getip()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nIP address, netmask, gateway address as string, for example \"192.168.0.111\", returns \nnil\n if IP address = \"0.0.0.0\".\n\n\nExample\n\n\n-- print current ip, netmask, gateway\nprint(wifi.ap.getip())\n-- 192.168.4.1  255.255.255.0  192.168.4.1\nip = wifi.ap.getip()\nprint(ip)\n-- 192.168.4.1\nip, nm = wifi.ap.getip()\nprint(nm)\n-- 255.255.255.0\nip, nm, gw = wifi.ap.getip()\nprint(gw)\n-- 192.168.4.1\n\n\n\n\nSee also\n\n\n\n\nwifi.ap.getmac()\n\n\n\n\nwifi.ap.getmac()\n\n\nGets MAC address in AP mode.\n\n\nSyntax\n\n\nwifi.ap.getmac()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nMAC address as string, for example \"1A-33-44-FE-55-BB\"\n\n\nSee also\n\n\nwifi.ap.getip()\n\n\nwifi.ap.setip()\n\n\nSets IP address, netmask and gateway address in AP mode.\n\n\nSyntax\n\n\nwifi.ap.setip(cfg)\n\n\nParameters\n\n\ncfg\n table contain IP address, netmask, and gateway\n\n\nReturns\n\n\ntrue if successful, false otherwise\n\n\nExample\n\n\ncfg =\n{\n    ip=\n192.168.1.1\n,\n    netmask=\n255.255.255.0\n,\n    gateway=\n192.168.1.1\n\n}\nwifi.ap.setip(cfg)\n\n\n\n\nSee also\n\n\nwifi.ap.setmac()\n\n\nwifi.ap.setmac()\n\n\nSets MAC address in AP mode.\n\n\nSyntax\n\n\nwifi.ap.setmac(mac)\n\n\nParameters\n\n\nMAC address in byte string, for example \"AC-1D-1C-B1-0B-22\"\n\n\nReturns\n\n\ntrue if success, false otherwise\n\n\nExample\n\n\nprint(wifi.ap.setmac(\nAC-1D-1C-B1-0B-22\n))\n\n\n\n\nSee also\n\n\nwifi.ap.setip()\n\n\nwifi.ap.dhcp Module\n\n\nwifi.ap.dhcp.config()\n\n\nConfigure the dhcp service. Currently only supports setting the start address of the dhcp address pool.\n\n\nSyntax\n\n\nwifi.ap.dhcp.config(dhcp_config)\n\n\nParameters\n\n\ndhcp_config\n table containing the start-IP of the DHCP address pool, eg. \"192.168.1.100\"\n\n\nReturns\n\n\npool_startip\n, \npool_endip\n\n\nExample\n\n\ndhcp_config ={}\ndhcp_config.start = \n192.168.1.100\n\nwifi.ap.dhcp.config(dhcp_config)\n\n\n\n\nwifi.ap.dhcp.start()\n\n\nStarts the DHCP service.\n\n\nSyntax\n\n\nwifi.ap.dhcp.start()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nboolean indicating success\n\n\nwifi.ap.dhcp.stop()\n\n\nStops the DHCP service.\n\n\nSyntax\n\n\nwifi.ap.dhcp.stop()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nboolean indicating success\n\n\nwifi.eventmon Module\n\n\nwifi.eventmon.register()\n\n\nRegister/unregister callbacks for WiFi event monitor.\n - After a callback is registered, this function may be called to update a callback's function at any time\n\n\n\n\nNote\n\n\nTo ensure all WiFi events are caught, the Wifi event monitor callbacks should be registered as early as possible in \ninit.lua\n. Any events that occur before callbacks are registered will be discarded!\n\n\n\n\nSyntax\n\n\nwifi.eventmon.register(Event[, function(T)])\n\n\nParameters\n\n\nEvent: WiFi event you would like to set a callback for.  \n\n\n\n\nValid WiFi events:  \n\n\nwifi.eventmon.STA_CONNECTED  \n\n\nwifi.eventmon.STA_DISCONNECTED  \n\n\nwifi.eventmon.STA_AUTHMODE_CHANGE  \n\n\nwifi.eventmon.STA_GOT_IP  \n\n\nwifi.eventmon.STA_DHCP_TIMEOUT  \n\n\nwifi.eventmon.AP_STACONNECTED  \n\n\nwifi.eventmon.AP_STADISCONNECTED  \n\n\nwifi.eventmon.AP_PROBEREQRECVED  \n\n\n\n\n\n\n\n\nReturns\n\n\nFunction:\n\n\nnil\n\n\nCallback:\n\nT: Table returned by event.  \n\n\n\n\nwifi.eventmon.STA_CONNECTED\n Station is connected to access point.  \n\n\nSSID\n: SSID of access point.  \n\n\nBSSID\n: BSSID of access point.  \n\n\nchannel\n: The channel the access point is on.  \n\n\n\n\n\n\nwifi.eventmon.STA_DISCONNECTED\n: Station was disconnected from access point.  \n\n\nSSID\n: SSID of access point.  \n\n\nBSSID\n: BSSID of access point.  \n\n\nreason\n: See \nwifi.eventmon.reason\n below.  \n\n\n\n\n\n\nwifi.eventmon.STA_AUTHMODE_CHANGE\n: Access point has changed authorization mode.    \n\n\nold_auth_mode\n: Old wifi authorization mode.  \n\n\nnew_auth_mode\n: New wifi authorization mode.  \n\n\n\n\n\n\nwifi.eventmon.STA_GOT_IP\n: Station got an IP address.  \n\n\nIP\n: The IP address assigned to the station.  \n\n\nnetmask\n: Subnet mask.  \n\n\ngateway\n: The IP address of the access point the station is connected to.  \n\n\n\n\n\n\nwifi.eventmon.STA_DHCP_TIMEOUT\n: Station DHCP request has timed out.  \n\n\nBlank table is returned.  \n\n\n\n\n\n\nwifi.eventmon.AP_STACONNECTED\n: A new client has connected to the access point.  \n\n\nMAC\n: MAC address of client that has connected.  \n\n\nAID\n: SDK provides no details concerning this return value.  \n\n\n\n\n\n\nwifi.eventmon.AP_STADISCONNECTED\n: A client has disconnected from the access point.  \n\n\nMAC\n: MAC address of client that has disconnected.  \n\n\nAID\n: SDK provides no details concerning this return value.  \n\n\n\n\n\n\nwifi.eventmon.AP_PROBEREQRECVED\n: A probe request was received.  \n\n\nMAC\n: MAC address of the client that is probing the access point.  \n\n\nRSSI\n: Received Signal Strength Indicator of client.  \n\n\n\n\n\n\nwifi.eventmon.WIFI_MODE_CHANGE\n: WiFi mode has changed.    \n\n\nold_auth_mode\n: Old WiFi mode.  \n\n\nnew_auth_mode\n: New WiFi mode.  \n\n\n\n\n\n\n\n\nExample\n\n\n wifi.eventmon.register(wifi.eventmon.STA_CONNECTED, function(T)\n print(\n\\n\\tSTA - CONNECTED\n..\n\\n\\tSSID: \n..T.SSID..\n\\n\\tBSSID: \n..\n T.BSSID..\n\\n\\tChannel: \n..T.channel)\n end)\n\n wifi.eventmon.register(wifi.eventmon.STA_DISCONNECTED, function(T)\n print(\n\\n\\tSTA - DISCONNECTED\n..\n\\n\\tSSID: \n..T.SSID..\n\\n\\tBSSID: \n..\n T.BSSID..\n\\n\\treason: \n..T.reason)\n end)\n\n wifi.eventmon.register(wifi.eventmon.STA_AUTHMODE_CHANGE, function(T)\n print(\n\\n\\tSTA - AUTHMODE CHANGE\n..\n\\n\\told_auth_mode: \n..\n T.old_auth_mode..\n\\n\\tnew_auth_mode: \n..T.new_auth_mode)\n end)\n\n wifi.eventmon.register(wifi.eventmon.STA_GOT_IP, function(T)\n print(\n\\n\\tSTA - GOT IP\n..\n\\n\\tStation IP: \n..T.IP..\n\\n\\tSubnet mask: \n..\n T.netmask..\n\\n\\tGateway IP: \n..T.gateway)\n end)\n\n wifi.eventmon.register(wifi.eventmon.STA_DHCP_TIMEOUT, function()\n print(\n\\n\\tSTA - DHCP TIMEOUT\n)\n end)\n\n wifi.eventmon.register(wifi.eventmon.AP_STACONNECTED, function(T)\n print(\n\\n\\tAP - STATION CONNECTED\n..\n\\n\\tMAC: \n..T.MAC..\n\\n\\tAID: \n..T.AID)\n end)\n\n wifi.eventmon.register(wifi.eventmon.AP_STADISCONNECTED, function(T)\n print(\n\\n\\tAP - STATION DISCONNECTED\n..\n\\n\\tMAC: \n..T.MAC..\n\\n\\tAID: \n..T.AID)\n end)\n\n wifi.eventmon.register(wifi.eventmon.AP_PROBEREQRECVED, function(T)\n print(\n\\n\\tAP - PROBE REQUEST RECEIVED\n..\n\\n\\tMAC: \n.. T.MAC..\n\\n\\tRSSI: \n..T.RSSI)\n end)\n\n wifi.eventmon.register(wifi.eventmon.WIFI_MODE_CHANGED, function(T)\n print(\n\\n\\tSTA - WIFI MODE CHANGED\n..\n\\n\\told_mode: \n..\n T.old_mode..\n\\n\\tnew_mode: \n..T.new_mode)\n end)\n\n\n\n\nSee also\n\n\n\n\nwifi.eventmon.unregister()\n\n\n\n\nwifi.eventmon.unregister()\n\n\nUnregister callbacks for WiFi event monitor.\n\n\nSyntax\n\n\nwifi.eventmon.unregister(Event)\n\n\nParameters\n\n\nEvent: WiFi event you would like to set a callback for.  \n\n\n\n\nValid WiFi events:\n\n\nwifi.eventmon.STA_CONNECTED  \n\n\nwifi.eventmon.STA_DISCONNECTED  \n\n\nwifi.eventmon.STA_AUTHMODE_CHANGE  \n\n\nwifi.eventmon.STA_GOT_IP  \n\n\nwifi.eventmon.STA_DHCP_TIMEOUT  \n\n\nwifi.eventmon.AP_STACONNECTED  \n\n\nwifi.eventmon.AP_STADISCONNECTED  \n\n\nwifi.eventmon.AP_PROBEREQRECVED  \n\n\nwifi.eventmon.WIFI_MODE_CHANGED  \n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n wifi.eventmon.unregister(wifi.eventmon.STA_CONNECTED)\n\n\n\n\nSee also\n\n\n\n\nwifi.eventmon.register()\n\n\n\n\nwifi.eventmon.reason\n\n\nTable containing disconnect reasons.\n\n\n\n\n\n\n\n\nDisconnect reason\n\n\nvalue\n\n\n\n\n\n\n\n\n\n\nwifi.eventmon.reason.UNSPECIFIED\n\n\n1\n\n\n\n\n\n\nwifi.eventmon.reason.AUTH_EXPIRE\n\n\n2\n\n\n\n\n\n\nwifi.eventmon.reason.AUTH_LEAVE\n\n\n3\n\n\n\n\n\n\nwifi.eventmon.reason.ASSOC_EXPIRE\n\n\n4\n\n\n\n\n\n\nwifi.eventmon.reason.ASSOC_TOOMANY\n\n\n5\n\n\n\n\n\n\nwifi.eventmon.reason.NOT_AUTHED\n\n\n6\n\n\n\n\n\n\nwifi.eventmon.reason.NOT_ASSOCED\n\n\n7\n\n\n\n\n\n\nwifi.eventmon.reason.ASSOC_LEAVE\n\n\n8\n\n\n\n\n\n\nwifi.eventmon.reason.ASSOC_NOT_AUTHED\n\n\n9\n\n\n\n\n\n\nwifi.eventmon.reason.DISASSOC_PWRCAP_BAD\n\n\n10\n\n\n\n\n\n\nwifi.eventmon.reason.DISASSOC_SUPCHAN_BAD\n\n\n11\n\n\n\n\n\n\nwifi.eventmon.reason.IE_INVALID\n\n\n13\n\n\n\n\n\n\nwifi.eventmon.reason.MIC_FAILURE\n\n\n14\n\n\n\n\n\n\nwifi.eventmon.reason.4WAY_HANDSHAKE_TIMEOUT\n\n\n15\n\n\n\n\n\n\nwifi.eventmon.reason.GROUP_KEY_UPDATE_TIMEOUT\n\n\n16\n\n\n\n\n\n\nwifi.eventmon.reason.IE_IN_4WAY_DIFFERS\n\n\n17\n\n\n\n\n\n\nwifi.eventmon.reason.GROUP_CIPHER_INVALID\n\n\n18\n\n\n\n\n\n\nwifi.eventmon.reason.PAIRWISE_CIPHER_INVALID\n\n\n19\n\n\n\n\n\n\nwifi.eventmon.reason.AKMP_INVALID\n\n\n20\n\n\n\n\n\n\nwifi.eventmon.reason.UNSUPP_RSN_IE_VERSION\n\n\n21\n\n\n\n\n\n\nwifi.eventmon.reason.INVALID_RSN_IE_CAP\n\n\n22\n\n\n\n\n\n\nwifi.eventmon.reason.802_1X_AUTH_FAILED\n\n\n23\n\n\n\n\n\n\nwifi.eventmon.reason.CIPHER_SUITE_REJECTED\n\n\n24\n\n\n\n\n\n\nwifi.eventmon.reason.BEACON_TIMEOUT\n\n\n200\n\n\n\n\n\n\nwifi.eventmon.reason.NO_AP_FOUND\n\n\n201\n\n\n\n\n\n\nwifi.eventmon.reason.AUTH_FAIL\n\n\n202\n\n\n\n\n\n\nwifi.eventmon.reason.ASSOC_FAIL\n\n\n203\n\n\n\n\n\n\nwifi.eventmon.reason.HANDSHAKE_TIMEOUT\n\n\n204", 
            "title": "wifi"
        }, 
        {
            "location": "/en/modules/wifi/#wifi-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-05-12  Zeroday  dnc40085  wifi.c      Important  The WiFi subsystem is maintained by background tasks that must run periodically. Any function or task that takes longer than 15ms (milliseconds) may cause the WiFi subsystem to crash. To avoid these potential crashes, it is advised that the WiFi subsystem be suspended with  wifi.suspend()  prior to the execution of any tasks or functions that exceed this 15ms guideline.   The NodeMCU WiFi control is spread across several tables:   wifi  for overall WiFi configuration  wifi.sta  for station mode functions  wifi.ap  for wireless access point (WAP or simply AP) functions  wifi.ap.dhcp  for DHCP server control  wifi.eventmon  for wifi event monitor", 
            "title": "WiFi Module"
        }, 
        {
            "location": "/en/modules/wifi/#wifigetchannel", 
            "text": "Gets the current WiFi channel.", 
            "title": "wifi.getchannel()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax", 
            "text": "wifi.getchannel()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters", 
            "text": "nil", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns", 
            "text": "current WiFi channel", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#wifigetdefaultmode", 
            "text": "Gets default WiFi operation mode.", 
            "title": "wifi.getdefaultmode()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_1", 
            "text": "wifi.getdefaultmode()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_1", 
            "text": "nil", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_1", 
            "text": "The WiFi mode, as one of the  wifi.STATION ,  wifi.SOFTAP ,  wifi.STATIONAP  or  wifi.NULLMODE  constants.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also", 
            "text": "wifi.getmode()  wifi.setmode()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifigetmode", 
            "text": "Gets WiFi operation mode.", 
            "title": "wifi.getmode()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_2", 
            "text": "wifi.getmode()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_2", 
            "text": "nil", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_2", 
            "text": "The WiFi mode, as one of the  wifi.STATION ,  wifi.SOFTAP ,  wifi.STATIONAP  or  wifi.NULLMODE  constants.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_1", 
            "text": "wifi.getdefaultmode()  wifi.setmode()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifigetphymode", 
            "text": "Gets WiFi physical mode.", 
            "title": "wifi.getphymode()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_3", 
            "text": "wifi.getphymode()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_3", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_3", 
            "text": "The current physical mode as one of  wifi.PHYMODE_B ,  wifi.PHYMODE_G  or  wifi.PHYMODE_N .", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_2", 
            "text": "wifi.setphymode()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifinullmodesleep", 
            "text": "Configures whether or not WiFi automatically goes to sleep in NULL_MODE. Enabled by default.   Note  This function  does not  store it's setting in flash, if auto sleep in NULL_MODE is not desired,  wifi.nullmodesleep(false)  must be called after power-up, restart, or wake from deep sleep.", 
            "title": "wifi.nullmodesleep()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_4", 
            "text": "wifi.nullmodesleep([enable])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_4", 
            "text": "enable  true  Enable WiFi auto sleep in NULL_MODE. (Default setting)  false  Disable WiFi auto sleep in NULL_MODE.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_4", 
            "text": "sleep_enabled  Current/New NULL_MODE sleep setting  If  wifi.nullmodesleep()  is called with no arguments, current setting is returned.  If  wifi.nullmodesleep()  is called with  enable  argument, confirmation of new setting is returned.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#wifiresume", 
            "text": "Wake up WiFi from suspended state or cancel pending wifi suspension.   Note  Wifi resume occurs asynchronously, this means that the resume request will only be processed when control of the processor is passed back to the SDK (after MyResumeFunction() has completed). The resume callback also executes asynchronously and will only execute after wifi has resumed normal operation.", 
            "title": "wifi.resume()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_5", 
            "text": "wifi.resume([resume_cb])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_5", 
            "text": "resume_cb  Callback to execute when WiFi wakes from suspension. \n !!! note \"Note:\"  Any previously provided callbacks will be replaced!", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_5", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example", 
            "text": "--Resume wifi from timed or indefinite sleep\nwifi.resume()\n\n--Resume wifi from timed or indefinite sleep w/ resume callback\nwifi.resume(function() print( WiFi resume ) end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_3", 
            "text": "wifi.suspend()  node.sleep()  node.dsleep()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifisetmode", 
            "text": "Configures the WiFi mode to use. NodeMCU can run in one of four WiFi modes:   Station mode, where the NodeMCU device joins an existing network  Access point (AP) mode, where it creates its own network that others can join  Station + AP mode, where it both creates its own network while at the same time being joined to another existing network  WiFi off   When using the combined Station + AP mode, the same channel will be used for both networks as the radio can only listen on a single channel.   Note  WiFi configuration will be retained until changed even if device is turned off.", 
            "title": "wifi.setmode()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_6", 
            "text": "wifi.setmode(mode[, save])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_6", 
            "text": "mode  value should be one of  wifi.STATION  for when the device is connected to a WiFi router. This is often done to give the device access to the Internet.  wifi.SOFTAP  for when the device is acting  only  as an access point. This will allow you to see the device in the list of WiFi networks (unless you hide the SSID, of course). In this mode your computer can connect to the device, creating a local area network. Unless you change the value, the NodeMCU device will be given a local IP address of 192.168.4.1 and assign your computer the next available IP address, such as 192.168.4.2.  wifi.STATIONAP  is the combination of  wifi.STATION  and  wifi.SOFTAP . It allows you to create a local WiFi connection  and  connect to another WiFi router.  wifi.NULLMODE  changing WiFi mode to NULL_MODE will put wifi into a low power state similar to MODEM_SLEEP, provided  wifi.nullmodesleep(false)  has not been called.    save  choose whether or not to save wifi mode to flash  true  WiFi mode configuration  will  be retained through power cycle. (Default)  false  WiFi mode configuration  will not  be retained through power cycle.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_6", 
            "text": "current mode after setup", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_1", 
            "text": "wifi.setmode(wifi.STATION)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_4", 
            "text": "wifi.getmode()  wifi.getdefaultmode()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifisetphymode", 
            "text": "Sets WiFi physical mode.   wifi.PHYMODE_B \n    802.11b, more range, low Transfer rate, more current draw  wifi.PHYMODE_G \n    802.11g, medium range, medium transfer rate, medium current draw  wifi.PHYMODE_N \n    802.11n, least range, fast transfer rate, least current draw (STATION ONLY)\nInformation from the Espressif datasheet v4.3      Parameters  Typical Power Usage      Tx 802.11b, CCK 11Mbps, P OUT=+17dBm  170 mA    Tx 802.11g, OFDM 54Mbps, P OUT =+15dBm  140 mA    Tx 802.11n, MCS7 65Mbps, P OUT =+13dBm  120 mA    Rx 802.11b, 1024 bytes packet length, -80dBm  50 mA    Rx 802.11g, 1024 bytes packet length, -70dBm  56 mA    Rx 802.11n, 1024 bytes packet length, -65dBm  56 mA", 
            "title": "wifi.setphymode()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_7", 
            "text": "wifi.setphymode(mode)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_7", 
            "text": "mode  one of the following   wifi.PHYMODE_B  wifi.PHYMODE_G  wifi.PHYMODE_N", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_7", 
            "text": "physical mode after setup", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_5", 
            "text": "wifi.getphymode()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistartsmart", 
            "text": "Starts to auto configuration, if success set up SSID and password automatically.  Intended for use with SmartConfig apps, such as Espressif's  Android   iOS app .  Only usable in  wifi.STATION  mode.   Important  SmartConfig is disabled by default and can be enabled by setting  WIFI_SMART_ENABLE  in  user_config.h  before you build the firmware.", 
            "title": "wifi.startsmart()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_8", 
            "text": "wifi.startsmart(type, callback)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_8", 
            "text": "type  0 for ESP_TOUCH, or 1 for AIR_KISS.  callback  a callback function of the form  function(ssid, password) end  which gets called after configuration.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_8", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_2", 
            "text": "wifi.setmode(wifi.STATION)\nwifi.startsmart(0,\n    function(ssid, password)\n        print(string.format( Success. SSID:%s ; PASSWORD:%s , ssid, password))\n    end\n)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_6", 
            "text": "wifi.stopsmart()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistopsmart", 
            "text": "Stops the smart configuring process.", 
            "title": "wifi.stopsmart()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_9", 
            "text": "wifi.stopsmart()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_9", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_9", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_7", 
            "text": "wifi.startsmart()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifisuspend", 
            "text": "Suspend Wifi to reduce current consumption.    Note  Wifi suspension occurs asynchronously, this means that the suspend request will only be processed when control of the processor is passed back to the SDK (after MySuspendFunction() has completed). The suspend callback also executes asynchronously and will only execute after wifi has been successfully been suspended.", 
            "title": "wifi.suspend()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_10", 
            "text": "wifi.suspend({duration[, suspend_cb, resume_cb, preserve_mode]})", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_10", 
            "text": "duration  Suspend duration in microseconds(\u03bcs). If a suspend duration of  0  is specified, suspension will be indefinite (Range: 0 or 50000 - 268435454 \u03bcs (0:4:28.000454))  suspend_cb  Callback to execute when WiFi is suspended. (Optional)  resume_cb  Callback to execute when WiFi wakes from suspension. (Optional)  preserve_mode  preserve current WiFi mode through node sleep. (Optional, Default: true)    If true, Station and StationAP modes will automatically reconnect to previously configured Access Point when NodeMCU resumes.  If false, discard WiFi mode and leave NodeMCU in  wifi.NULL_MODE . WiFi mode will be restored to original mode on restart.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_10", 
            "text": "suspend_state  if no parameters are provided, current WiFi suspension state will be returned  States:  0  WiFi is awake.  1  WiFi suspension is pending. (Waiting for idle task)  2  WiFi is suspended.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_3", 
            "text": "--get current wifi suspension state\nprint(wifi.suspend())\n\n--Suspend WiFi for 10 seconds with suspend/resume callbacks\n cfg={}\n cfg.duration=10*1000*1000\n cfg.resume_cb=function() print( WiFi resume ) end\n cfg.suspend_cb=function() print( WiFi suspended ) end\n\n wifi.suspend(cfg)\n\n--Suspend WiFi for 10 seconds with suspend/resume callbacks and discard WiFi mode\n cfg={}\n cfg.duration=10*1000*1000\n cfg.resume_cb=function() print( WiFi resume ) end\n cfg.suspend_cb=function() print( WiFfi suspended ) end\n cfg.preserve_mode=false\n\n wifi.suspend(cfg)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_8", 
            "text": "wifi.resume()  node.sleep()  node.dsleep()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifista-module", 
            "text": "", 
            "title": "wifi.sta Module"
        }, 
        {
            "location": "/en/modules/wifi/#wifistaautoconnect", 
            "text": "Auto connects to AP in station mode.", 
            "title": "wifi.sta.autoconnect()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_11", 
            "text": "wifi.sta.autoconnect(auto)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_11", 
            "text": "auto  0 to disable auto connecting, 1 to enable auto connecting", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_11", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_4", 
            "text": "wifi.sta.autoconnect(1)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_9", 
            "text": "wifi.sta.config()  wifi.sta.connect()  wifi.sta.disconnect()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistachangeap", 
            "text": "Select Access Point from list returned by  wifi.sta.getapinfo()", 
            "title": "wifi.sta.changeap()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_12", 
            "text": "wifi.sta.changeap(ap_index)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_12", 
            "text": "ap_index  Index of Access Point you would like to change to. (Range:1-5)\n - Corresponds to index used by  wifi.sta.getapinfo()  and  wifi.sta.getapindex()", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_12", 
            "text": "true   Success  false  Failure", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_5", 
            "text": "wifi.sta.changeap(4)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_10", 
            "text": "wifi.sta.getapinfo()  wifi.sta.getapindex()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistaclearconfig", 
            "text": "Clears the currently saved WiFi station configuration, erasing it from the flash. May be useful for certain factory-reset \nscenarios when a full  node.restore()  is not desired, or to prepare for using End-User Setup  so that the SoftAP is able to lock onto a single hardware radio channel.", 
            "title": "wifi.sta.clearconfig()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_13", 
            "text": "wifi.sta.clearconfig()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_13", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_13", 
            "text": "true   Success  false  Failure", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_11", 
            "text": "wifi.sta.config()  node.restore()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistaconfig", 
            "text": "Sets the WiFi station configuration.   Note  It is not advised to assume that the WiFi is connected at any time during initialization start-up. WiFi connection status should be validated either by using a WiFi event callback or by polling the status on a timer.", 
            "title": "wifi.sta.config()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_14", 
            "text": "wifi.sta.config(station_config)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_14", 
            "text": "station_config  table containing configuration data for station  ssid  string which is less than 32 bytes.  pwd  string which is 0-64. Empty string indicates an open WiFi access point.  Note: WPA requires a minimum of 8-characters, but the ESP8266 can also connect to a WEP access point (a 40-bit WEP key can be provided as its corresponding 5-character ASCII string).  auto  defaults to true  true  to enable auto connect and connect to access point, hence with  auto=true  there's no need to call  wifi.sta.connect()  false  to disable auto connect and remain disconnected from access point    bssid  string that contains the MAC address of the access point (optional)  You can set BSSID if you have multiple access points with the same SSID.  If you set BSSID for a specific SSID and would like to configure station to connect to the same SSID only without the BSSID requirement, you MUST first configure to station to a different SSID first, then connect to the desired SSID  The following formats are valid:  \"DE:C1:A5:51:F1:ED\"  \"AC-1D-1C-B1-0B-22\"  \"DE AD BE EF 7A C0\"      save  Save station configuration to flash.   true  configuration  will  be retained through power cycle.  (Default).  false  configuration  will not  be retained through power cycle.    Event callbacks will only be available if  WIFI_SDK_EVENT_MONITOR_ENABLE  is uncommented in  user_config.h  Please note: To ensure all station events are handled at boot time, all relevant callbacks must be registered as early as possible in  init.lua  with either  wifi.sta.config()  or  wifi.eventmon.register() .       connected_cb : Callback to execute when station is connected to an access point. (Optional)  Items returned in table :  SSID : SSID of access point.  (format: string)  BSSID : BSSID of access point.  (format: string)  channel : The channel the access point is on.  (format: number)      disconnected_cb : Callback to execute when station is disconnected from an access point. (Optional)  Items returned in table :  SSID : SSID of access point.   (format: string)  BSSID : BSSID of access point. (format: string)   REASON : See  wifi.eventmon.reason  below. (format: number)        authmode_change_cb : Callback to execute when the access point has changed authorization mode. (Optional)      Items returned in table :  old_auth_mode : Old wifi authorization mode. (format: number)    new_auth_mode : New wifi authorization mode. (format: number)    got_ip_cb : Callback to execute when the station received an IP address from the access point. (Optional)  Items returned in table :  IP : The IP address assigned to the station.  (format: string)  netmask : Subnet mask.  (format: string)  gateway : The IP address of the access point the station is connected to. (format: string)        dhcp_timeout_cb : Station DHCP request has timed out. (Optional)  Blank table is returned.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_14", 
            "text": "true   Success  false  Failure", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_6", 
            "text": "--connect to Access Point (DO NOT save config to flash)\nstation_cfg={}\nstation_cfg.ssid= NODE-AABBCC \nstation_cfg.pwd= password \nwifi.sta.config(station_cfg)\n\n--connect to Access Point (DO save config to flash)\nstation_cfg={}\nstation_cfg.ssid= NODE-AABBCC \nstation_cfg.pwd= password \nstation_cfg.save=true\nwifi.sta.config(station_cfg)\n\n--connect to Access Point with specific MAC address  \nstation_cfg={}\nstation_cfg.ssid= NODE-AABBCC \nstation_cfg.pwd= password \nstation_cfg.bssid= AA:BB:CC:DD:EE:FF \nwifi.sta.config(station_cfg)\n\n--configure station but don't connect to Access point\nstation_cfg={}\nstation_cfg.ssid= NODE-AABBCC \nstation_cfg.pwd= password \nstation_cfg.auto=false\nwifi.sta.config(station_cfg)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_12", 
            "text": "wifi.sta.clearconfig()  wifi.sta.connect()  wifi.sta.disconnect()  wifi.sta.apinfo()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistaconnect", 
            "text": "Connects to the configured AP in station mode. You only ever need to call this if auto-connect was disabled in  wifi.sta.config() .", 
            "title": "wifi.sta.connect()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_15", 
            "text": "wifi.sta.connect([connected_cb])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_15", 
            "text": "connected_cb : Callback to execute when station is connected to an access point. (Optional)  Items returned in table :  SSID : SSID of access point.  (format: string)  BSSID : BSSID of access point.  (format: string)  channel : The channel the access point is on.  (format: number)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_15", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_13", 
            "text": "wifi.sta.disconnect()  wifi.sta.config()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistadisconnect", 
            "text": "Disconnects from AP in station mode.   Note  Please note that disconnecting from Access Point does not reduce power consumption. If power saving is your goal, please refer to the description for  wifi.NULLMODE  in the function  wifi.setmode()  for more details.", 
            "title": "wifi.sta.disconnect()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_16", 
            "text": "wifi.sta.disconnect([disconnected_cb])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_16", 
            "text": "disconnected_cb : Callback to execute when station is disconnected from an access point. (Optional)  Items returned in table :  SSID : SSID of access point.   (format: string)  BSSID : BSSID of access point. (format: string)   REASON : See  wifi.eventmon.reason  below. (format: number)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_16", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_14", 
            "text": "wifi.sta.config()  wifi.sta.connect()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagetap", 
            "text": "Scans AP list as a Lua table into callback function.", 
            "title": "wifi.sta.getap()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_17", 
            "text": "wifi.sta.getap([[cfg], format,] callback(table))", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_17", 
            "text": "cfg  table that contains scan configuration  ssid  SSID == nil, don't filter SSID  bssid  BSSID == nil, don't filter BSSID  channel  channel == 0, scan all channels, otherwise scan set channel (default is 0)  show_hidden  show_hidden == 1, get info for router with hidden SSID (default is 0)    format  select output table format, defaults to 0  0: old format (SSID : Authmode, RSSI, BSSID, Channel), any duplicate SSIDs will be discarded  1: new format (BSSID : SSID, RSSI, auth mode, Channel)    callback(table)  a callback function to receive the AP table when the scan is done. This function receives a table, the key is the BSSID, the value is other info in format: SSID, RSSID, auth mode, channel.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_17", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_7", 
            "text": "-- print AP list in old format (format not defined)\nfunction listap(t)\n    for k,v in pairs(t) do\n        print(k..  :  ..v)\n    end\nend\nwifi.sta.getap(listap)\n\n-- Print AP list that is easier to read\nfunction listap(t) -- (SSID : Authmode, RSSI, BSSID, Channel)\n    print( \\n ..string.format( %32s , SSID ).. \\tBSSID\\t\\t\\t\\t  RSSI\\t\\tAUTHMODE\\tCHANNEL )\n    for ssid,v in pairs(t) do\n        local authmode, rssi, bssid, channel = string.match(v,  ([^,]+),([^,]+),([^,]+),([^,]+) )\n        print(string.format( %32s ,ssid).. \\t ..bssid.. \\t   ..rssi.. \\t\\t ..authmode.. \\t\\t\\t ..channel)\n    end\nend\nwifi.sta.getap(listap)\n\n-- print AP list in new format\nfunction listap(t)\n    for k,v in pairs(t) do\n        print(k..  :  ..v)\n    end\nend\nwifi.sta.getap(1, listap)\n\n-- Print AP list that is easier to read\nfunction listap(t) -- (SSID : Authmode, RSSI, BSSID, Channel)\n    print( \\n\\t\\t\\tSSID\\t\\t\\t\\t\\tBSSID\\t\\t\\t  RSSI\\t\\tAUTHMODE\\t\\tCHANNEL )\n    for bssid,v in pairs(t) do\n        local ssid, rssi, authmode, channel = string.match(v,  ([^,]+),([^,]+),([^,]+),([^,]*) )\n        print(string.format( %32s ,ssid).. \\t ..bssid.. \\t   ..rssi.. \\t\\t ..authmode.. \\t\\t\\t ..channel)\n    end\nend\nwifi.sta.getap(1, listap)\n\n--check for specific AP\nfunction listap(t)\n    print( \\n\\t\\t\\tSSID\\t\\t\\t\\t\\tBSSID\\t\\t\\t  RSSI\\t\\tAUTHMODE\\t\\tCHANNEL )\n    for bssid,v in pairs(t) do\n        local ssid, rssi, authmode, channel = string.match(v,  ([^,]+),([^,]+),([^,]+),([^,]*) )\n        print(string.format( %32s ,ssid).. \\t ..bssid.. \\t   ..rssi.. \\t\\t ..authmode.. \\t\\t\\t ..channel)\n    end\nend\nscan_cfg = {}\nscan_cfg.ssid =  myssid \nscan_cfg.bssid =  AA:AA:AA:AA:AA:AA \nscan_cfg.channel = 0\nscan_cfg.show_hidden = 1\nwifi.sta.getap(scan_cfg, 1, listap)\n\n--get RSSI for currently configured AP\nfunction listap(t)\n    for bssid,v in pairs(t) do\n        local ssid, rssi, authmode, channel = string.match(v,  ([^,]+),([^,]+),([^,]+),([^,]*) )\n        print( CURRENT RSSI IS:  ..rssi)\n    end\nend\nssid, tmp, bssid_set, bssid=wifi.sta.getconfig()\n\nscan_cfg = {}\nscan_cfg.ssid = ssid\nif bssid_set == 1 then scan_cfg.bssid = bssid else scan_cfg.bssid = nil end\nscan_cfg.channel = wifi.getchannel()\nscan_cfg.show_hidden = 0\nssid, tmp, bssid_set, bssid=nil, nil, nil, nil\nwifi.sta.getap(scan_cfg, 1, listap)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_15", 
            "text": "wifi.sta.getip()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagetapindex", 
            "text": "Get index of current Access Point stored in AP cache.", 
            "title": "wifi.sta.getapindex()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_18", 
            "text": "wifi.sta.getapindex()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_18", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_18", 
            "text": "current_index  index of currently selected Access Point. (Range:1-5)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_8", 
            "text": "print( the index of the currently selected AP is:  ..wifi.sta.getapindex())", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_16", 
            "text": "wifi.sta.getapindex()  wifi.sta.apinfo()  wifi.sta.apchange()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagetapinfo", 
            "text": "Get information of APs cached by ESP8266 station.   Note Any Access Points configured with save disabled  wifi.sta.config({save=false})  will populate this list (appearing to overwrite APs stored in flash) until restart.", 
            "title": "wifi.sta.getapinfo()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_19", 
            "text": "wifi.sta.getapinfo()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_19", 
            "text": "nil", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_19", 
            "text": "ap_info  qty  quantity of APs returned  1-5  index of AP. (the index corresponds to index used by  wifi.sta.changeap()  and  wifi.sta.getapindex() )  ssid   ssid of Access Point  pwd  password for Access Point,  nil  if no password was configured   bssid  MAC address of Access Point  nil  will be returned if no MAC address was configured during station configuration.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_9", 
            "text": "--print stored access point info\ndo\n  for k,v in pairs(wifi.sta.getapinfo()) do\n    if (type(v)== table ) then\n      print(   ..k..  :  ..type(v))\n      for k,v in pairs(v) do\n        print( \\t\\t ..k..  :  ..v)\n      end\n    else\n      print(   ..k..  :  ..v)\n    end\n  end\nend\n\n--print stored access point info(formatted)\ndo\n  local x=wifi.sta.getapinfo()\n  local y=wifi.sta.getapindex()\n  print( \\n Number of APs stored in flash: , x.qty)\n  print(string.format(   %-6s %-32s %-64s %-18s ,  index: ,  SSID: ,  Password: ,  BSSID: )) \n  for i=1, (x.qty), 1 do\n    print(string.format(  %s%-6d %-32s %-64s %-18s ,(i==y and   or    ), i, x[i].ssid, x[i].pwd and x[i].pwd or type(nil), x[i].bssid and x[i].bssid or type(nil)))\n  end\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_17", 
            "text": "wifi.sta.getapindex()  wifi.sta.setaplimit()  wifi.sta.changeap()  wifi.sta.config()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagetbroadcast", 
            "text": "Gets the broadcast address in station mode.", 
            "title": "wifi.sta.getbroadcast()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_20", 
            "text": "wifi.sta.getbroadcast()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_20", 
            "text": "nil", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_20", 
            "text": "broadcast address as string, for example \"192.168.0.255\",\nreturns  nil  if IP address = \"0.0.0.0\".", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_18", 
            "text": "wifi.sta.getip()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagetconfig", 
            "text": "Gets the WiFi station configuration.", 
            "title": "wifi.sta.getconfig()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_21", 
            "text": "wifi.sta.getconfig()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_21", 
            "text": "return_table  true  returns data in a table  false  returns data in the old format (default)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_21", 
            "text": "If  return_table  is  true :   config_table  ssid  ssid of Access Point.  pwd  password to Access Point,  nil  if no password was configured   bssid_set  will return  true  if the station was configured specifically to connect to the AP with the matching  bssid .   bssid  If a connection has been made to the configured AP this field will contain the AP's MAC address. Otherwise \"ff:ff:ff:ff:ff:ff\" will be returned.     If  return_table  is  false :   ssid, password, bssid_set, bssid, if  bssid_set  is equal to  0  then  bssid  is irrelevant", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_10", 
            "text": "--Get current Station configuration (NEW FORMAT)\ndo\nlocal sta_config=wifi.sta.getconfig(true)\nprint(string.format( \\tCurrent station config\\n\\tssid:\\ %s\\ \\tpassword:\\ %s\\ \\n\\tbssid:\\ %s\\ \\tbssid_set:%s , sta_config.ssid, sta_config.pwd, sta_config.bssid, (sta_config.bssid_set and  true  or  false )))\nend\n\n--Get current Station configuration (OLD FORMAT)\nssid, password, bssid_set, bssid=wifi.sta.getconfig()\nprint( \\nCurrent Station configuration:\\nSSID :  ..ssid\n.. \\nPassword  :  ..password\n.. \\nBSSID_set  :  ..bssid_set\n.. \\nBSSID:  ..bssid.. \\n )\nssid, password, bssid_set, bssid=nil, nil, nil, nil", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_19", 
            "text": "wifi.sta.getdefaultconfig()  wifi.sta.connect()  wifi.sta.disconnect()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagetdefaultconfig", 
            "text": "Gets the default WiFi station configuration stored in flash.", 
            "title": "wifi.sta.getdefaultconfig()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_22", 
            "text": "wifi.sta.getdefaultconfig(return_table)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_22", 
            "text": "return_table  true  returns data in a table  false  returns data in the old format (default)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_22", 
            "text": "If  return_table  is  true :   config_table  ssid  ssid of Access Point.  pwd  password to Access Point,  nil  if no password was configured  bssid_set  will return  true  if the station was configured specifically to connect to the AP with the matching  bssid .   bssid  If a connection has been made to the configured AP this field will contain the AP's MAC address. Otherwise \"ff:ff:ff:ff:ff:ff\" will be returned.     If  return_table  is  false :   ssid, password, bssid_set, bssid, if  bssid_set  is equal to  0  then  bssid  is irrelevant", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_11", 
            "text": "--Get default Station configuration (NEW FORMAT)\ndo\nlocal def_sta_config=wifi.sta.getdefaultconfig(true)\nprint(string.format( \\tDefault station config\\n\\tssid:\\ %s\\ \\tpassword:\\ %s\\ \\n\\tbssid:\\ %s\\ \\tbssid_set:%s , def_sta_config.ssid, def_sta_config.pwd, def_sta_config.bssid, (def_sta_config.bssid_set and  true  or  false )))\nend\n\n--Get default Station configuration (OLD FORMAT)\nssid, password, bssid_set, bssid=wifi.sta.getdefaultconfig()\nprint( \\nCurrent Station configuration:\\nSSID :  ..ssid\n.. \\nPassword  :  ..password\n.. \\nBSSID_set  :  ..bssid_set\n.. \\nBSSID:  ..bssid.. \\n )\nssid, password, bssid_set, bssid=nil, nil, nil, nil", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_20", 
            "text": "wifi.sta.getconfig()  wifi.sta.connect()  wifi.sta.disconnect()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagethostname", 
            "text": "Gets current station hostname.", 
            "title": "wifi.sta.gethostname()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_23", 
            "text": "wifi.sta.gethostname()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_23", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_23", 
            "text": "currently configured hostname", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_12", 
            "text": "print( Current hostname is: \\ ..wifi.sta.gethostname().. \\ )", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagetip", 
            "text": "Gets IP address, netmask, and gateway address in station mode.", 
            "title": "wifi.sta.getip()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_24", 
            "text": "wifi.sta.getip()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_24", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_24", 
            "text": "IP address, netmask, gateway address as string, for example \"192.168.0.111\". Returns  nil  if IP = \"0.0.0.0\".", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_13", 
            "text": "-- print current IP address, netmask, gateway\nprint(wifi.sta.getip())\n-- 192.168.0.111  255.255.255.0  192.168.0.1\nip = wifi.sta.getip()\nprint(ip)\n-- 192.168.0.111\nip, nm = wifi.sta.getip()\nprint(nm)\n-- 255.255.255.0", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_21", 
            "text": "wifi.sta.getmac()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagetmac", 
            "text": "Gets MAC address in station mode.", 
            "title": "wifi.sta.getmac()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_25", 
            "text": "wifi.sta.getmac()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_25", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_25", 
            "text": "MAC address as string e.g. \"18:fe:34:a2:d7:34\"", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_22", 
            "text": "wifi.sta.getip()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistagetrssi", 
            "text": "Get RSSI(Received Signal Strength Indicator) of the Access Point which ESP8266 station connected to.", 
            "title": "wifi.sta.getrssi()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_26", 
            "text": "wifi.sta.getrssi()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_26", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_26", 
            "text": "If station is connected to an access point,  rssi  is returned.  If station is not connected to an access point,  nil  is returned.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_14", 
            "text": "RSSI=wifi.sta.getrssi()\nprint( RSSI is , RSSI)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#wifistasetaplimit", 
            "text": "Set Maximum number of Access Points to store in flash.\n - This value is written to flash   Attention  New setting will not take effect until restart.     Note  If 5 Access Points are stored and AP limit is set to 4, the AP at index 5 will remain until  node.restore()  is called or AP limit is set to 5 and AP is overwritten.", 
            "title": "wifi.sta.setaplimit()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_27", 
            "text": "wifi.sta.setaplimit(qty)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_27", 
            "text": "qty  Quantity of Access Points to store in flash. Range: 1-5 (Default: 1)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_27", 
            "text": "true   Success  false  Failure", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_15", 
            "text": "wifi.sta.setaplimit(5)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_23", 
            "text": "wifi.sta.getapinfo()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistasethostname", 
            "text": "Sets station hostname.", 
            "title": "wifi.sta.sethostname()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_28", 
            "text": "wifi.sta.sethostname(hostname)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_28", 
            "text": "hostname  must only contain letters, numbers and hyphens('-') and be 32 characters or less with first and last character being alphanumeric", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_28", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_16", 
            "text": "if (wifi.sta.sethostname( NodeMCU ) == true) then\n    print( hostname was successfully changed )\nelse\n    print( hostname was not changed )\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#wifistasetip", 
            "text": "Sets IP address, netmask, gateway address in station mode.", 
            "title": "wifi.sta.setip()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_29", 
            "text": "wifi.sta.setip(cfg)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_29", 
            "text": "cfg  table contain IP address, netmask, and gateway  {\n  ip =  192.168.0.111 ,\n  netmask =  255.255.255.0 ,\n  gateway =  192.168.0.1 \n}", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_29", 
            "text": "true if success, false otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_24", 
            "text": "wifi.sta.setmac()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistasetmac", 
            "text": "Sets MAC address in station mode.", 
            "title": "wifi.sta.setmac()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_30", 
            "text": "wifi.sta.setmac(mac)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_30", 
            "text": "MAC address in string e.g. \"DE:AD:BE:EF:7A:C0\"", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_30", 
            "text": "true if success, false otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_17", 
            "text": "print(wifi.sta.setmac( DE:AD:BE:EF:7A:C0 ))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_25", 
            "text": "wifi.sta.setip()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifistasleeptype", 
            "text": "Configures the WiFi modem sleep type to be used while station is connected to an Access Point.   Note  Does not apply to  wifi.SOFTAP ,  wifi.STATIONAP  or  wifi.NULLMODE .", 
            "title": "wifi.sta.sleeptype()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_31", 
            "text": "wifi.sta.sleeptype(type_wanted)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_31", 
            "text": "type_wanted  one of the following:   wifi.NONE_SLEEP  to keep the modem on at all times  wifi.LIGHT_SLEEP  to allow the CPU to power down under some circumstances  wifi.MODEM_SLEEP  to power down the modem as much as possible", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_31", 
            "text": "The actual sleep mode set, as one of  wifi.NONE_SLEEP ,  wifi.LIGHT_SLEEP  or  wifi.MODEM_SLEEP .", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#wifistastatus", 
            "text": "Gets the current status in station mode.", 
            "title": "wifi.sta.status()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_32", 
            "text": "wifi.sta.status()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_32", 
            "text": "nil", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_32", 
            "text": "The current state which can be one of the following:   wifi.STA_IDLE  wifi.STA_CONNECTING  wifi.STA_WRONGPWD  wifi.STA_APNOTFOUND  wifi.STA_FAIL  wifi.STA_GOTIP", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#wifiap-module", 
            "text": "", 
            "title": "wifi.ap Module"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapconfig", 
            "text": "Sets SSID and password in AP mode. Be sure to make the password at least 8 characters long! If you don't it will default to  no  password and not set the SSID! It will still work as an access point but use a default SSID like e.g. NODE_9997C3.", 
            "title": "wifi.ap.config()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_33", 
            "text": "wifi.ap.config(cfg)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_33", 
            "text": "cfg  table to hold configuration  ssid  SSID chars 1-32  pwd  password chars 8-64  auth  authentication method, one of  wifi.OPEN  (default),  wifi.WPA_PSK ,  wifi.WPA2_PSK ,  wifi.WPA_WPA2_PSK  channel  channel number 1-14 default = 6  hidden  false = not hidden, true = hidden, default = false  max  maximum number of connections 1-4 default=4  beacon  beacon interval time in range 100-60000, default = 100  save  save configuration to flash.  true  configuration  will  be retained through power cycle. (Default)  false  configuration  will not  be retained through power cycle.    Event callbacks will only be available if  WIFI_SDK_EVENT_MONITOR_ENABLE  is uncommented in  user_config.h  Please note: To ensure all SoftAP events are handled at boot time, all relevant callbacks must be registered as early as possible in  init.lua  with either  wifi.ap.config()  or  wifi.eventmon.register() .       staconnected_cb : Callback executed when a new client has connected to the access point. (Optional)  Items returned in table :  MAC : MAC address of client that has connected.    AID : SDK provides no details concerning this return value.        stadisconnected_cb : Callback executed when a client has disconnected from the access point. (Optional)    Items returned in table :  MAC : MAC address of client that has disconnected.    AID : SDK provides no details concerning this return value.        probereq_cb : Callback executed when a probe request was received. (Optional)  Items returned in table :  MAC : MAC address of the client that is probing the access point.    RSSI : Received Signal Strength Indicator of client.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_33", 
            "text": "true   Success  false  Failure", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_18", 
            "text": "cfg={}\n cfg.ssid= myssid \n cfg.pwd= mypassword \n wifi.ap.config(cfg)", 
            "title": "Example:"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapdeauth", 
            "text": "Deauths (forcibly removes) a client from the ESP access point by sending a corresponding IEEE802.11 management packet (first) and removing the client from it's data structures (afterwards).  The IEEE802.11 reason code used is 2 for \"Previous authentication no longer valid\"(AUTH_EXPIRE).", 
            "title": "wifi.ap.deauth()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_34", 
            "text": "wifi.ap.deauth([MAC])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_34", 
            "text": "MAC  address of station to be deauthed.  Note: if this field is left blank, all currently connected stations will get deauthed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_34", 
            "text": "Returns true unless called while the ESP is in the STATION opmode", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_19", 
            "text": "allowed_mac_list={ 18:fe:34:00:00:00 ,  18:fe:34:00:00:01 }\n\nwifi.eventmon.register(wifi.eventmon.AP_STACONNECTED, function(T)\n  print( \\n\\tAP - STATION CONNECTED .. \\n\\tMAC:  ..T.MAC.. \\n\\tAID:  ..T.AID)\n  if(allowed_mac_list~=nil) then\n    for _, v in pairs(allowed_mac_list) do\n      if(v == T.MAC) then return end\n    end\n  end\n  wifi.ap.deauth(T.MAC)\n  print( \\tStation DeAuthed! )\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_26", 
            "text": "wifi.eventmon.register()  wifi.eventmon.reason()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapgetbroadcast", 
            "text": "Gets broadcast address in AP mode.", 
            "title": "wifi.ap.getbroadcast()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_35", 
            "text": "wifi.ap.getbroadcast()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_35", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_35", 
            "text": "broadcast address in string, for example \"192.168.0.255\",\nreturns  nil  if IP address = \"0.0.0.0\".", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_20", 
            "text": "bc = wifi.ap.getbroadcast()\nprint(bc)\n-- 192.168.0.255", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_27", 
            "text": "wifi.ap.getip()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapgetclient", 
            "text": "Gets table of clients connected to device in AP mode.", 
            "title": "wifi.ap.getclient()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_36", 
            "text": "wifi.ap.getclient()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_36", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_36", 
            "text": "table of connected clients", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_21", 
            "text": "table={}\ntable=wifi.ap.getclient()\nfor mac,ip in pairs(table) do\n    print(mac,ip)\nend\n\n-- or shorter\nfor mac,ip in pairs(wifi.ap.getclient()) do\n    print(mac,ip)\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapgetconfig", 
            "text": "Gets the current SoftAP configuration.", 
            "title": "wifi.ap.getconfig()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_37", 
            "text": "wifi.ap.getconfig(return_table)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_37", 
            "text": "return_table  true  returns data in a table  false  returns data in the old format (default)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_37", 
            "text": "If  return_table  is true:   config_table  ssid  Network name  pwd  Password,  nil  if no password was configured   -  auth  Authentication Method ( wifi.OPEN ,  wifi.WPA_PSK ,  wifi.WPA2_PSK  or  wifi.WPA_WPA2_PSK )  channel  Channel number  hidden   false  = not hidden,  true  = hidden  max  Maximum number of client connections  beacon  Beacon interval     If  return_table  is false:   ssid, password, if  bssid_set  is equal to 0 then  bssid  is irrelevant", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_22", 
            "text": "--Get SoftAP configuration table (NEW FORMAT)\ndo\n  print( \\n  Current SoftAP configuration: )\n  for k,v in pairs(wifi.ap.getconfig(true)) do\n      print(     ..k..  : ,v)\n  end\nend\n\n--Get current SoftAP configuration (OLD FORMAT)\ndo\n  local ssid, password=wifi.ap.getconfig()\n  print( \\n  Current SoftAP configuration:\\n   SSID :  ..ssid..\n     \\n   Password  : ,password)\n  ssid, password=nil, nil\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapgetdefaultconfig", 
            "text": "Gets the default SoftAP configuration stored in flash.", 
            "title": "wifi.ap.getdefaultconfig()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_38", 
            "text": "wifi.ap.getdefaultconfig(return_table)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_38", 
            "text": "return_table  true  returns data in a table  false  returns data in the old format (default)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_38", 
            "text": "If  return_table  is true:   config_table  ssid  Network name  pwd  Password,  nil  if no password was configured   -  auth  Authentication Method ( wifi.OPEN ,  wifi.WPA_PSK ,  wifi.WPA2_PSK  or  wifi.WPA_WPA2_PSK )  channel  Channel number  hidden   false  = not hidden,  true  = hidden  max  Maximum number of client connections  beacon  Beacon interval     If  return_table  is false:   ssid, password, if  bssid_set  is equal to 0 then  bssid  is irrelevant", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_23", 
            "text": "--Get default SoftAP configuration table (NEW FORMAT)\ndo\n  print( \\n  Default SoftAP configuration: )\n  for k,v in pairs(wifi.ap.getdefaultconfig(true)) do\n      print(     ..k..  : ,v)\n  end\nend\n\n--Get default SoftAP configuration (OLD FORMAT)\ndo\n  local ssid, password=wifi.ap.getdefaultconfig()\n  print( \\n  Default SoftAP configuration:\\n   SSID :  ..ssid..\n     \\n   Password  : ,password)\n  ssid, password=nil, nil\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapgetip", 
            "text": "Gets IP address, netmask and gateway in AP mode.", 
            "title": "wifi.ap.getip()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_39", 
            "text": "wifi.ap.getip()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_39", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_39", 
            "text": "IP address, netmask, gateway address as string, for example \"192.168.0.111\", returns  nil  if IP address = \"0.0.0.0\".", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_24", 
            "text": "-- print current ip, netmask, gateway\nprint(wifi.ap.getip())\n-- 192.168.4.1  255.255.255.0  192.168.4.1\nip = wifi.ap.getip()\nprint(ip)\n-- 192.168.4.1\nip, nm = wifi.ap.getip()\nprint(nm)\n-- 255.255.255.0\nip, nm, gw = wifi.ap.getip()\nprint(gw)\n-- 192.168.4.1", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_28", 
            "text": "wifi.ap.getmac()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapgetmac", 
            "text": "Gets MAC address in AP mode.", 
            "title": "wifi.ap.getmac()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_40", 
            "text": "wifi.ap.getmac()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_40", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_40", 
            "text": "MAC address as string, for example \"1A-33-44-FE-55-BB\"", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_29", 
            "text": "wifi.ap.getip()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapsetip", 
            "text": "Sets IP address, netmask and gateway address in AP mode.", 
            "title": "wifi.ap.setip()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_41", 
            "text": "wifi.ap.setip(cfg)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_41", 
            "text": "cfg  table contain IP address, netmask, and gateway", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_41", 
            "text": "true if successful, false otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_25", 
            "text": "cfg =\n{\n    ip= 192.168.1.1 ,\n    netmask= 255.255.255.0 ,\n    gateway= 192.168.1.1 \n}\nwifi.ap.setip(cfg)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_30", 
            "text": "wifi.ap.setmac()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapsetmac", 
            "text": "Sets MAC address in AP mode.", 
            "title": "wifi.ap.setmac()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_42", 
            "text": "wifi.ap.setmac(mac)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_42", 
            "text": "MAC address in byte string, for example \"AC-1D-1C-B1-0B-22\"", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_42", 
            "text": "true if success, false otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_26", 
            "text": "print(wifi.ap.setmac( AC-1D-1C-B1-0B-22 ))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_31", 
            "text": "wifi.ap.setip()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapdhcp-module", 
            "text": "", 
            "title": "wifi.ap.dhcp Module"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapdhcpconfig", 
            "text": "Configure the dhcp service. Currently only supports setting the start address of the dhcp address pool.", 
            "title": "wifi.ap.dhcp.config()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_43", 
            "text": "wifi.ap.dhcp.config(dhcp_config)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_43", 
            "text": "dhcp_config  table containing the start-IP of the DHCP address pool, eg. \"192.168.1.100\"", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_43", 
            "text": "pool_startip ,  pool_endip", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_27", 
            "text": "dhcp_config ={}\ndhcp_config.start =  192.168.1.100 \nwifi.ap.dhcp.config(dhcp_config)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapdhcpstart", 
            "text": "Starts the DHCP service.", 
            "title": "wifi.ap.dhcp.start()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_44", 
            "text": "wifi.ap.dhcp.start()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_44", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_44", 
            "text": "boolean indicating success", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#wifiapdhcpstop", 
            "text": "Stops the DHCP service.", 
            "title": "wifi.ap.dhcp.stop()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_45", 
            "text": "wifi.ap.dhcp.stop()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_45", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_45", 
            "text": "boolean indicating success", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#wifieventmon-module", 
            "text": "", 
            "title": "wifi.eventmon Module"
        }, 
        {
            "location": "/en/modules/wifi/#wifieventmonregister", 
            "text": "Register/unregister callbacks for WiFi event monitor.\n - After a callback is registered, this function may be called to update a callback's function at any time   Note  To ensure all WiFi events are caught, the Wifi event monitor callbacks should be registered as early as possible in  init.lua . Any events that occur before callbacks are registered will be discarded!", 
            "title": "wifi.eventmon.register()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_46", 
            "text": "wifi.eventmon.register(Event[, function(T)])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_46", 
            "text": "Event: WiFi event you would like to set a callback for.     Valid WiFi events:    wifi.eventmon.STA_CONNECTED    wifi.eventmon.STA_DISCONNECTED    wifi.eventmon.STA_AUTHMODE_CHANGE    wifi.eventmon.STA_GOT_IP    wifi.eventmon.STA_DHCP_TIMEOUT    wifi.eventmon.AP_STACONNECTED    wifi.eventmon.AP_STADISCONNECTED    wifi.eventmon.AP_PROBEREQRECVED", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_46", 
            "text": "Function:  nil  Callback: \nT: Table returned by event.     wifi.eventmon.STA_CONNECTED  Station is connected to access point.    SSID : SSID of access point.    BSSID : BSSID of access point.    channel : The channel the access point is on.      wifi.eventmon.STA_DISCONNECTED : Station was disconnected from access point.    SSID : SSID of access point.    BSSID : BSSID of access point.    reason : See  wifi.eventmon.reason  below.      wifi.eventmon.STA_AUTHMODE_CHANGE : Access point has changed authorization mode.      old_auth_mode : Old wifi authorization mode.    new_auth_mode : New wifi authorization mode.      wifi.eventmon.STA_GOT_IP : Station got an IP address.    IP : The IP address assigned to the station.    netmask : Subnet mask.    gateway : The IP address of the access point the station is connected to.      wifi.eventmon.STA_DHCP_TIMEOUT : Station DHCP request has timed out.    Blank table is returned.      wifi.eventmon.AP_STACONNECTED : A new client has connected to the access point.    MAC : MAC address of client that has connected.    AID : SDK provides no details concerning this return value.      wifi.eventmon.AP_STADISCONNECTED : A client has disconnected from the access point.    MAC : MAC address of client that has disconnected.    AID : SDK provides no details concerning this return value.      wifi.eventmon.AP_PROBEREQRECVED : A probe request was received.    MAC : MAC address of the client that is probing the access point.    RSSI : Received Signal Strength Indicator of client.      wifi.eventmon.WIFI_MODE_CHANGE : WiFi mode has changed.      old_auth_mode : Old WiFi mode.    new_auth_mode : New WiFi mode.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_28", 
            "text": "wifi.eventmon.register(wifi.eventmon.STA_CONNECTED, function(T)\n print( \\n\\tSTA - CONNECTED .. \\n\\tSSID:  ..T.SSID.. \\n\\tBSSID:  ..\n T.BSSID.. \\n\\tChannel:  ..T.channel)\n end)\n\n wifi.eventmon.register(wifi.eventmon.STA_DISCONNECTED, function(T)\n print( \\n\\tSTA - DISCONNECTED .. \\n\\tSSID:  ..T.SSID.. \\n\\tBSSID:  ..\n T.BSSID.. \\n\\treason:  ..T.reason)\n end)\n\n wifi.eventmon.register(wifi.eventmon.STA_AUTHMODE_CHANGE, function(T)\n print( \\n\\tSTA - AUTHMODE CHANGE .. \\n\\told_auth_mode:  ..\n T.old_auth_mode.. \\n\\tnew_auth_mode:  ..T.new_auth_mode)\n end)\n\n wifi.eventmon.register(wifi.eventmon.STA_GOT_IP, function(T)\n print( \\n\\tSTA - GOT IP .. \\n\\tStation IP:  ..T.IP.. \\n\\tSubnet mask:  ..\n T.netmask.. \\n\\tGateway IP:  ..T.gateway)\n end)\n\n wifi.eventmon.register(wifi.eventmon.STA_DHCP_TIMEOUT, function()\n print( \\n\\tSTA - DHCP TIMEOUT )\n end)\n\n wifi.eventmon.register(wifi.eventmon.AP_STACONNECTED, function(T)\n print( \\n\\tAP - STATION CONNECTED .. \\n\\tMAC:  ..T.MAC.. \\n\\tAID:  ..T.AID)\n end)\n\n wifi.eventmon.register(wifi.eventmon.AP_STADISCONNECTED, function(T)\n print( \\n\\tAP - STATION DISCONNECTED .. \\n\\tMAC:  ..T.MAC.. \\n\\tAID:  ..T.AID)\n end)\n\n wifi.eventmon.register(wifi.eventmon.AP_PROBEREQRECVED, function(T)\n print( \\n\\tAP - PROBE REQUEST RECEIVED .. \\n\\tMAC:  .. T.MAC.. \\n\\tRSSI:  ..T.RSSI)\n end)\n\n wifi.eventmon.register(wifi.eventmon.WIFI_MODE_CHANGED, function(T)\n print( \\n\\tSTA - WIFI MODE CHANGED .. \\n\\told_mode:  ..\n T.old_mode.. \\n\\tnew_mode:  ..T.new_mode)\n end)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_32", 
            "text": "wifi.eventmon.unregister()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifieventmonunregister", 
            "text": "Unregister callbacks for WiFi event monitor.", 
            "title": "wifi.eventmon.unregister()"
        }, 
        {
            "location": "/en/modules/wifi/#syntax_47", 
            "text": "wifi.eventmon.unregister(Event)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wifi/#parameters_47", 
            "text": "Event: WiFi event you would like to set a callback for.     Valid WiFi events:  wifi.eventmon.STA_CONNECTED    wifi.eventmon.STA_DISCONNECTED    wifi.eventmon.STA_AUTHMODE_CHANGE    wifi.eventmon.STA_GOT_IP    wifi.eventmon.STA_DHCP_TIMEOUT    wifi.eventmon.AP_STACONNECTED    wifi.eventmon.AP_STADISCONNECTED    wifi.eventmon.AP_PROBEREQRECVED    wifi.eventmon.WIFI_MODE_CHANGED", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wifi/#returns_47", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wifi/#example_29", 
            "text": "wifi.eventmon.unregister(wifi.eventmon.STA_CONNECTED)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/wifi/#see-also_33", 
            "text": "wifi.eventmon.register()", 
            "title": "See also"
        }, 
        {
            "location": "/en/modules/wifi/#wifieventmonreason", 
            "text": "Table containing disconnect reasons.     Disconnect reason  value      wifi.eventmon.reason.UNSPECIFIED  1    wifi.eventmon.reason.AUTH_EXPIRE  2    wifi.eventmon.reason.AUTH_LEAVE  3    wifi.eventmon.reason.ASSOC_EXPIRE  4    wifi.eventmon.reason.ASSOC_TOOMANY  5    wifi.eventmon.reason.NOT_AUTHED  6    wifi.eventmon.reason.NOT_ASSOCED  7    wifi.eventmon.reason.ASSOC_LEAVE  8    wifi.eventmon.reason.ASSOC_NOT_AUTHED  9    wifi.eventmon.reason.DISASSOC_PWRCAP_BAD  10    wifi.eventmon.reason.DISASSOC_SUPCHAN_BAD  11    wifi.eventmon.reason.IE_INVALID  13    wifi.eventmon.reason.MIC_FAILURE  14    wifi.eventmon.reason.4WAY_HANDSHAKE_TIMEOUT  15    wifi.eventmon.reason.GROUP_KEY_UPDATE_TIMEOUT  16    wifi.eventmon.reason.IE_IN_4WAY_DIFFERS  17    wifi.eventmon.reason.GROUP_CIPHER_INVALID  18    wifi.eventmon.reason.PAIRWISE_CIPHER_INVALID  19    wifi.eventmon.reason.AKMP_INVALID  20    wifi.eventmon.reason.UNSUPP_RSN_IE_VERSION  21    wifi.eventmon.reason.INVALID_RSN_IE_CAP  22    wifi.eventmon.reason.802_1X_AUTH_FAILED  23    wifi.eventmon.reason.CIPHER_SUITE_REJECTED  24    wifi.eventmon.reason.BEACON_TIMEOUT  200    wifi.eventmon.reason.NO_AP_FOUND  201    wifi.eventmon.reason.AUTH_FAIL  202    wifi.eventmon.reason.ASSOC_FAIL  203    wifi.eventmon.reason.HANDSHAKE_TIMEOUT  204", 
            "title": "wifi.eventmon.reason"
        }, 
        {
            "location": "/en/modules/wps/", 
            "text": "WPS Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2017-01-01\n\n\nFrank Exoo\n\n\nFrank Exoo\n\n\nwps.c\n\n\n\n\n\n\n\n\nWPS\n allows devices to be added to an existing network without entering the network credentials.\n\n\n\n\nDanger\n\n\nUse this with caution. There are serious security concerns about using WPS.\n\n\nWPA/WPA2 networks that have the WPS feature enabled are \nvery easy to crack\n. Once the WPS pin has been stolen \nthe router gives out the password\n even if it has been changed.\n\n\nYou should use WPA/WPA2 with the WPS feature disabled.\n\n\n\n\nwps.disable()\n\n\nDisable WiFi WPS function.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nwps.enable()\n\n\nEnable WiFi WPS function.\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nnil\n\n\nwps.start()\n\n\nStart WiFi WPS function. WPS must be enabled prior calling this function.\n\n\n\n\nNote\n\n\nThis function only configures the station with the AP's info, it does not connect to AP automatically.\n\n\n\n\nSyntax\n\n\nwps.start([function(status)])\n\n\nParameters\n\n\n\n\nfunction(status)\n callback function for when the WPS function ends.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n  --Basic example\n  wifi.setmode(wifi.STATION)\n  wps.enable()\n  wps.start(function(status)\n    if status == wps.SUCCESS then\n      wps.disable()\n      print(\nWPS: Success, connecting to AP...\n)\n      wifi.sta.connect()\n      return\n    elseif status == wps.FAILED then\n      print(\nWPS: Failed\n)\n    elseif status == wps.TIMEOUT then\n      print(\nWPS: Timeout\n)\n    elseif status == wps.WEP then\n      print(\nWPS: WEP not supported\n)\n    elseif status == wps.SCAN_ERR then\n      print(\nWPS: AP not found\n)\n    else\n      print(status)\n    end\n    wps.disable()\n  end)\n\n  --Full example\n  do\n    -- Register wifi station event callbacks\n    wifi.eventmon.register(wifi.eventmon.STA_CONNECTED, function(T)\n      print(\n\\n\\tSTA - CONNECTED\n..\n\\n\\tSSID: \n..T.SSID..\n\\n\\tBSSID: \n..\n      T.BSSID..\n\\n\\tChannel: \n..T.channel)\n    end)\n    wifi.eventmon.register(wifi.eventmon.STA_GOT_IP, function(T)\n      print(\n\\n\\tSTA - GOT IP\n..\n\\n\\tStation IP: \n..T.IP..\n\\n\\tSubnet mask: \n..\n      T.netmask..\n\\n\\tGateway IP: \n..T.gateway)\n    end)\n\n    wifi.setmode(wifi.STATION)\n\n    wps_retry_func = function() \n      if wps_retry_count == nil then wps_retry_count = 0 end\n      if wps_retry_count \n 3 then \n        wps.disable()\n        wps.enable()\n        wps_retry_count = wps_retry_count + 1\n        wps_retry_timer = tmr.create()\n        wps_retry_timer:alarm(3000, tmr.ALARM_SINGLE, function() wps.start(wps_cb) end)\n        print(\nretry #\n..wps_retry_count)\n      else\n        wps_retry_count = nil\n        wps_retry_timer = nil\n        wps_retry_func = nil\n        wps_cb = nil\n      end\n    end\n\n    wps_cb = function(status)\n      if status == wps.SUCCESS then\n        wps.disable()\n        print(\nWPS: success, connecting to AP...\n)\n        wifi.sta.connect()\n        wps_retry_count = nil\n        wps_retry_timer = nil\n        wps_retry_func = nil\n        wps_cb = nil\n        return\n      elseif status == wps.FAILED then\n        print(\nWPS: Failed\n)\n        wps_retry_func()\n        return\n      elseif status == wps.TIMEOUT then\n        print(\nWPS: Timeout\n)\n        wps_retry_func()\n        return\n      elseif status == wps.WEP then\n        print(\nWPS: WEP not supported\n)\n      elseif status == wps.SCAN_ERR then\n        print(\nWPS: AP not found\n)\n        wps_retry_func()\n        return\n      else\n        print(status)\n      end\n      wps.disable()\n      wps_retry_count = nil\n      wps_retry_timer = nil\n      wps_retry_func = nil\n      wps_cb = nil\n    end\n    wps.enable()\n    wps.start(wps_cb)\n  end", 
            "title": "wps"
        }, 
        {
            "location": "/en/modules/wps/#wps-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2017-01-01  Frank Exoo  Frank Exoo  wps.c     WPS  allows devices to be added to an existing network without entering the network credentials.   Danger  Use this with caution. There are serious security concerns about using WPS.  WPA/WPA2 networks that have the WPS feature enabled are  very easy to crack . Once the WPS pin has been stolen  the router gives out the password  even if it has been changed.  You should use WPA/WPA2 with the WPS feature disabled.", 
            "title": "WPS Module"
        }, 
        {
            "location": "/en/modules/wps/#wpsdisable", 
            "text": "Disable WiFi WPS function.", 
            "title": "wps.disable()"
        }, 
        {
            "location": "/en/modules/wps/#parameters", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wps/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wps/#wpsenable", 
            "text": "Enable WiFi WPS function.", 
            "title": "wps.enable()"
        }, 
        {
            "location": "/en/modules/wps/#parameters_1", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wps/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wps/#wpsstart", 
            "text": "Start WiFi WPS function. WPS must be enabled prior calling this function.   Note  This function only configures the station with the AP's info, it does not connect to AP automatically.", 
            "title": "wps.start()"
        }, 
        {
            "location": "/en/modules/wps/#syntax", 
            "text": "wps.start([function(status)])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/wps/#parameters_2", 
            "text": "function(status)  callback function for when the WPS function ends.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/wps/#returns_2", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/wps/#example", 
            "text": "--Basic example\n  wifi.setmode(wifi.STATION)\n  wps.enable()\n  wps.start(function(status)\n    if status == wps.SUCCESS then\n      wps.disable()\n      print( WPS: Success, connecting to AP... )\n      wifi.sta.connect()\n      return\n    elseif status == wps.FAILED then\n      print( WPS: Failed )\n    elseif status == wps.TIMEOUT then\n      print( WPS: Timeout )\n    elseif status == wps.WEP then\n      print( WPS: WEP not supported )\n    elseif status == wps.SCAN_ERR then\n      print( WPS: AP not found )\n    else\n      print(status)\n    end\n    wps.disable()\n  end)\n\n  --Full example\n  do\n    -- Register wifi station event callbacks\n    wifi.eventmon.register(wifi.eventmon.STA_CONNECTED, function(T)\n      print( \\n\\tSTA - CONNECTED .. \\n\\tSSID:  ..T.SSID.. \\n\\tBSSID:  ..\n      T.BSSID.. \\n\\tChannel:  ..T.channel)\n    end)\n    wifi.eventmon.register(wifi.eventmon.STA_GOT_IP, function(T)\n      print( \\n\\tSTA - GOT IP .. \\n\\tStation IP:  ..T.IP.. \\n\\tSubnet mask:  ..\n      T.netmask.. \\n\\tGateway IP:  ..T.gateway)\n    end)\n\n    wifi.setmode(wifi.STATION)\n\n    wps_retry_func = function() \n      if wps_retry_count == nil then wps_retry_count = 0 end\n      if wps_retry_count   3 then \n        wps.disable()\n        wps.enable()\n        wps_retry_count = wps_retry_count + 1\n        wps_retry_timer = tmr.create()\n        wps_retry_timer:alarm(3000, tmr.ALARM_SINGLE, function() wps.start(wps_cb) end)\n        print( retry # ..wps_retry_count)\n      else\n        wps_retry_count = nil\n        wps_retry_timer = nil\n        wps_retry_func = nil\n        wps_cb = nil\n      end\n    end\n\n    wps_cb = function(status)\n      if status == wps.SUCCESS then\n        wps.disable()\n        print( WPS: success, connecting to AP... )\n        wifi.sta.connect()\n        wps_retry_count = nil\n        wps_retry_timer = nil\n        wps_retry_func = nil\n        wps_cb = nil\n        return\n      elseif status == wps.FAILED then\n        print( WPS: Failed )\n        wps_retry_func()\n        return\n      elseif status == wps.TIMEOUT then\n        print( WPS: Timeout )\n        wps_retry_func()\n        return\n      elseif status == wps.WEP then\n        print( WPS: WEP not supported )\n      elseif status == wps.SCAN_ERR then\n        print( WPS: AP not found )\n        wps_retry_func()\n        return\n      else\n        print(status)\n      end\n      wps.disable()\n      wps_retry_count = nil\n      wps_retry_timer = nil\n      wps_retry_func = nil\n      wps_cb = nil\n    end\n    wps.enable()\n    wps.start(wps_cb)\n  end", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2801/", 
            "text": "WS2801 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-07-12\n\n\nEspressif example\n, \nKonrad Beckmann\n\n\nKonrad Beckmann\n\n\nws2801.c\n\n\n\n\n\n\n\n\nws2801.init()\n\n\nInitializes the module and sets the pin configuration.\n\n\nSyntax\n\n\nws2801.init(pin_clk, pin_data)\n\n\nParameters\n\n\n\n\npin_clk\n pin for the clock. Supported are GPIO 0, 2, 4, 5.\n\n\npin_data\n pin for the data. Supported are GPIO 0, 2, 4, 5.\n\n\n\n\nReturns\n\n\nnil\n\n\nws2801.write()\n\n\nSends a string of RGB Data in 24 bits to WS2801. Don't forget to call \nws2801.init()\n before.\n\n\nSyntax\n\n\nws2801.write(string)\n\n\nParameters\n\n\n\n\nstring\n payload to be sent to one or more WS2801.\n  It should be composed from an RGB triplet per element.\n\n\nR1\n the first pixel's red channel value (0-255)\n\n\nG1\n the first pixel's green channel value (0-255)\n\n\nB1\n the first pixel's blue channel value (0-255)\n\n... You can connect a lot of WS2801...\n\n\nR2\n, \nG2\n, \nB2\n are the next WS2801's Red, Green, and Blue channel values\n\n\n\n\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nws2801.write(string.char(255,0,0, 0,255,0, 0,0,255))", 
            "title": "ws2801"
        }, 
        {
            "location": "/en/modules/ws2801/#ws2801-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-07-12  Espressif example ,  Konrad Beckmann  Konrad Beckmann  ws2801.c", 
            "title": "WS2801 Module"
        }, 
        {
            "location": "/en/modules/ws2801/#ws2801init", 
            "text": "Initializes the module and sets the pin configuration.", 
            "title": "ws2801.init()"
        }, 
        {
            "location": "/en/modules/ws2801/#syntax", 
            "text": "ws2801.init(pin_clk, pin_data)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2801/#parameters", 
            "text": "pin_clk  pin for the clock. Supported are GPIO 0, 2, 4, 5.  pin_data  pin for the data. Supported are GPIO 0, 2, 4, 5.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2801/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2801/#ws2801write", 
            "text": "Sends a string of RGB Data in 24 bits to WS2801. Don't forget to call  ws2801.init()  before.", 
            "title": "ws2801.write()"
        }, 
        {
            "location": "/en/modules/ws2801/#syntax_1", 
            "text": "ws2801.write(string)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2801/#parameters_1", 
            "text": "string  payload to be sent to one or more WS2801.\n  It should be composed from an RGB triplet per element.  R1  the first pixel's red channel value (0-255)  G1  the first pixel's green channel value (0-255)  B1  the first pixel's blue channel value (0-255) \n... You can connect a lot of WS2801...  R2 ,  G2 ,  B2  are the next WS2801's Red, Green, and Blue channel values", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2801/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2801/#example", 
            "text": "ws2801.write(string.char(255,0,0, 0,255,0, 0,0,255))", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/", 
            "text": "WS2812 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2015-02-05\n\n\nTill Klocke\n, \nThomas So\u00ebte\n\n\nTill Klocke\n\n\nws2812.c\n\n\n\n\n\n\n\n\nws2812 is a library to handle ws2812-like led strips.\nIt works at least on WS2812, WS2812b, APA104, SK6812 (RGB or RGBW).\n\n\nThe library uses UART1 routed on GPIO2 (Pin D4 on NodeMCU DEVKIT) to\ngenerate the bitstream. It can use UART0 routed to TXD0 as well to\nhandle two led strips at the same time.\n\n\nWARNING\n: In dual mode, you will loose access to the Lua's console\nthrough the serial port (it will be reconfigured to support WS2812-like \nprotocol). If you want to keep access to Lua's console, you will have to \nuse an other input channel like a TCP server (see \nexample\n)\n\n\nws2812.init()\n\n\nInitialize UART1 and GPIO2, should be called once and before write().\nInitialize UART0 (TXD0) too if \nws2812.MODE_DUAL\n is set.\n\n\nSyntax\n\n\nws2812.init([mode])\n\n\nParameters\n\n\n\n\nmode\n (optional) either \nws2812.MODE_SINGLE\n (default if omitted) or \nws2812.MODE_DUAL\n\n\n\n\nIn \nws2812.MODE_DUAL\n mode you will be able to handle two strips in parallel but will lose access to Lua's serial console as it shares the same UART and PIN.\n\n\nReturns\n\n\nnil\n\n\nws2812.write()\n\n\nSend data to one or two led strip using its native format which is generally Green,Red,Blue for RGB strips\nand Green,Red,Blue,White for RGBW strips.\n\n\nSyntax\n\n\nws2812.write(data1, [data2])\n\n\nParameters\n\n\n\n\ndata1\n payload to be sent to one or more WS2812 like leds through GPIO2\n\n\ndata2\n (optional) payload to be sent to one or more WS2812 like leds through TXD0 (\nws2812.MODE_DUAL\n mode required)\n\n\n\n\nPayload type could be:\n- \nnil\n nothing is done\n- \nstring\n representing bytes to send\n- \nws2812.buffer\n see \nBuffer module\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nws2812.init()\nws2812.write(string.char(255, 0, 0, 255, 0, 0)) -- turn the two first RGB leds to green\n\n\n\n\nws2812.init()\nws2812.write(string.char(0, 0, 0, 255, 0, 0, 0, 255)) -- turn the two first RGBW leds to white\n\n\n\n\nws2812.init(ws2812.MODE_DUAL)\nws2812.write(string.char(255, 0, 0, 255, 0, 0), string.char(0, 255, 0, 0, 255, 0)) -- turn the two first RGB leds to green on the first strip and red on the second strip\n\n\n\n\nws2812.init(ws2812.MODE_DUAL)\nws2812.write(nil, string.char(0, 255, 0, 0, 255, 0)) -- turn the two first RGB leds to red on the second strip, do nothing on the first\n\n\n\n\nBuffer module\n\n\nFor more advanced animations, it is useful to keep a \"framebuffer\" of the strip,\ninteract with it and flush it to the strip.\n\n\nFor this purpose, the ws2812 library offers a read/write buffer. This buffer has a \n__tostring\n method so that it can be printed. This is useful for debugging.\n\n\nExample\n\n\nLed chaser with a RGBW strip\n\n\nws2812.init()\nlocal i, buffer = 0, ws2812.newBuffer(300, 4); buffer:fill(0, 0, 0, 0); tmr.create():alarm(50, 1, function()\n  i = i + 1\n  buffer:fade(2)\n  buffer:set(i % buffer:size() + 1, 0, 0, 0, 255)\n  ws2812.write(buffer)\nend)\n\n\n\n\nws2812.newBuffer()\n\n\nAllocate a new memory buffer to store led values.\n\n\nSyntax\n\n\nws2812.newBuffer(numberOfLeds, bytesPerLed)\n\n\nParameters\n\n\n\n\nnumberOfLeds\n length of the led strip\n\n\nbytesPerLed\n 3 for RGB strips and 4 for RGBW strips\n\n\n\n\nReturns\n\n\nws2812.buffer\n\n\nws2812.buffer:get()\n\n\nReturn the value at the given position\n\n\nSyntax\n\n\nbuffer:get(index)\n\n\nParameters\n\n\n\n\nindex\n position in the buffer (1 for first led)\n\n\n\n\nReturns\n\n\n(color)\n\n\nExample\n\n\nbuffer = ws2812.newBuffer(32, 4)\nprint(buffer:get(1))\n0   0   0   0\n\n\n\n\nws2812.buffer:set()\n\n\nSet the value at the given position\n\n\nSyntax\n\n\nbuffer:set(index, color)\n\n\nParameters\n\n\n\n\nindex\n position in the buffer (1 for the first led)\n\n\ncolor\n payload of the color\n\n\n\n\nPayload could be:\n- \nnumber, number, ...\n you should pass as many arguments as \nbytesPerLed\n\n- \ntable\n should contains \nbytesPerLed\n numbers\n- \nstring\n should contains \nbytesPerLed\n bytes\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nbuffer = ws2812.newBuffer(32, 3)\nbuffer:set(1, 255, 0, 0) -- set the first led green for a RGB strip\n\n\n\n\nbuffer = ws2812.newBuffer(32, 4)\nbuffer:set(1, {0, 0, 0, 255}) -- set the first led white for a RGBW strip\n\n\n\n\nbuffer = ws2812.newBuffer(32, 3)\nbuffer:set(1, string.char(255, 0, 0)) -- set the first led green for a RGB strip\n\n\n\n\nws2812.buffer:size()\n\n\nReturn the size of the buffer in number of leds\n\n\nSyntax\n\n\nbuffer:size()\n\n\nParameters\n\n\nnone\n\n\nReturns\n\n\nint\n\n\nws2812.buffer:fill()\n\n\nFill the buffer with the given color.\nThe number of given bytes must match the number of bytesPerLed of the buffer\n\n\nSyntax\n\n\nbuffer:fill(color)\n\n\nParameters\n\n\n\n\ncolor\n bytes of the color, you should pass as many arguments as \nbytesPerLed\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nbuffer:fill(0, 0, 0) -- fill the buffer with black for a RGB strip\n\n\n\n\nws2812.buffer:dump()\n\n\nReturns the contents of the buffer (the pixel values) as a string. This can then be saved to a file or sent over a network.\n\n\nSyntax\n\n\nbuffer:dump()\n\n\nReturns\n\n\nA string containing the pixel values. \n\n\nExample\n\n\nlocal s = buffer:dump() \n\n\n\n\nws2812.buffer:replace()\n\n\nInserts a string (or a buffer) into another buffer with an offset.\nThe buffer must have the same number of colors per led or an error will be thrown.\n\n\nSyntax\n\n\nbuffer:replace(source[, offset])\n\n\nParameters\n\n\n\n\nsource\n the pixel values to be set into the buffer. This is either a string or a buffer.\n\n\noffset\n the offset where the source is to be placed in the buffer. Default is 1. Negative values can be used.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nbuffer:replace(anotherbuffer:dump()) -- copy one buffer into another via a string\nbuffer:replace(anotherbuffer) -- copy one buffer into another\nnewbuffer = buffer.sub(1)     -- make a copy of a buffer into a new buffer\n\n\n\n\nws2812.buffer:mix()\n\n\nThis is a general method that loads data into a buffer that is a linear combination of data from other buffers. It can be used to copy a buffer or,\nmore usefully, do a cross fade. The pixel values are computed as integers and then range limited to [0, 255]. This means that negative\nfactors work as expected, and that the order of combining buffers does not matter.\n\n\nSyntax\n\n\nbuffer:mix(factor1, buffer1, ...)\n\n\nParameters\n\n\n\n\nfactor1\n This is the factor that the contents of \nbuffer1\n are multiplied by. This factor is scaled by a factor of 256. Thus \nfactor1\n value of 256 is a factor of 1.0.\n\n\nbuffer1\n This is the source buffer. It must be of the same shape as the destination buffer.\n\n\n\n\nThere can be any number of factor/buffer pairs.\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- loads buffer with a crossfade between buffer1 and buffer2\nbuffer:mix(256 - crossmix, buffer1, crossmix, buffer2)\n\n-- multiplies all values in buffer by 0.75\n-- This can be used in place of buffer:fade\nbuffer:mix(192, buffer)\n\n\n\n\nws2812.buffer:power()\n\n\nComputes the total energy requirement for the buffer. This is merely the total sum of all the pixel values (which assumes that each color in each\npixel consumes the same amount of power). A real WS2812 (or WS2811) has three constant current drivers of 20mA -- one for each of R, G and B. The\npulse width modulation will cause the \naverage\n current to scale linearly with pixel value. \n\n\nSyntax\n\n\nbuffer:power()\n\n\nReturns\n\n\nAn integer which is the sum of all the pixel values.\n\n\nExample\n\n\n-- Dim the buffer to no more than the PSU can provide\nlocal psu_current_ma = 1000\nlocal led_current_ma = 20\nlocal led_sum = psu_current_ma * 255 / led_current_ma\n\nlocal p = buffer:power()\nif p \n led_sum then\n  buffer:mix(256 * led_sum / p, buffer) -- power is now limited\nend\n\n\n\n\nws2812.buffer:fade()\n\n\nFade in or out. Defaults to out. Multiply or divide each byte of each led with/by the given value. Useful for a fading effect. \n\n\nSyntax\n\n\nbuffer:fade(value [, direction])\n\n\nParameters\n\n\n\n\nvalue\n value by which to divide or multiply each byte\n\n\ndirection\n ws2812.FADE_IN or ws2812.FADE_OUT. Defaults to ws2812.FADE_OUT\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nbuffer:fade(2)\nbuffer:fade(2, ws2812.FADE_IN)\n\n\n\n\nws2812.buffer:shift()\n\n\nShift the content of (a piece of) the buffer in positive or negative direction. This allows simple animation effects. A slice of the buffer can be specified by using the \nstandard start and end offset Lua notation. Negative values count backwards from the end of the buffer.\n\n\nSyntax\n\n\nbuffer:shift(value [, mode[, i[, j]]])\n\n\nParameters\n\n\n\n\nvalue\n number of pixels by which to rotate the buffer. Positive values rotate forwards, negative values backwards. \n\n\nmode\n is the shift mode to use. Can be one of \nws2812.SHIFT_LOGICAL\n or \nws2812.SHIFT_CIRCULAR\n. In case of SHIFT_LOGICAL, the freed pixels are set to 0 (off). In case of SHIFT_CIRCULAR, the buffer is treated like a ring buffer, inserting the pixels falling out on one end again on the other end. Defaults to SHIFT_LOGICAL. \n\n\ni\n is the first offset in the buffer to be affected. Negative values are permitted and count backwards from the end. Default is 1.\n\n\nj\n is the last offset in the buffer to be affected. Negative values are permitted and count backwards from the end. Default is -1.\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\nbuffer:shift(3)\n\n\n\n\nws2812.buffer:sub()\n\n\nThis implements the extraction function like \nstring.sub\n. The indexes are in leds and all the same rules apply.\n\n\nSyntax\n\n\nbuffer1:sub(i[, j])\n\n\nParameters\n\n\n\n\ni\n This is the start of the extracted data. Negative values can be used.\n\n\nj\n this is the end of the extracted data. Negative values can be used. The default is -1.\n\n\n\n\nReturns\n\n\nA buffer containing the extracted piece.\n\n\nExample\n\n\nb = buffer:sub(1,10)\n\n\n\n\nws2812.buffer:__concat()\n\n\nThis implements the \n..\n operator to concatenate two buffers. They must have the same number of colors per led.\n\n\nSyntax\n\n\nbuffer1 .. buffer2\n\n\nParameters\n\n\n\n\nbuffer1\n this is the start of the resulting buffer\n\n\nbuffer2\n this is the end of the resulting buffer\n\n\n\n\nReturns\n\n\nThe concatenated buffer.\n\n\nExample\n\n\nws2812.write(buffer1 .. buffer2)", 
            "title": "ws2812"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2015-02-05  Till Klocke ,  Thomas So\u00ebte  Till Klocke  ws2812.c     ws2812 is a library to handle ws2812-like led strips.\nIt works at least on WS2812, WS2812b, APA104, SK6812 (RGB or RGBW).  The library uses UART1 routed on GPIO2 (Pin D4 on NodeMCU DEVKIT) to\ngenerate the bitstream. It can use UART0 routed to TXD0 as well to\nhandle two led strips at the same time.  WARNING : In dual mode, you will loose access to the Lua's console\nthrough the serial port (it will be reconfigured to support WS2812-like \nprotocol). If you want to keep access to Lua's console, you will have to \nuse an other input channel like a TCP server (see  example )", 
            "title": "WS2812 Module"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812init", 
            "text": "Initialize UART1 and GPIO2, should be called once and before write().\nInitialize UART0 (TXD0) too if  ws2812.MODE_DUAL  is set.", 
            "title": "ws2812.init()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax", 
            "text": "ws2812.init([mode])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters", 
            "text": "mode  (optional) either  ws2812.MODE_SINGLE  (default if omitted) or  ws2812.MODE_DUAL   In  ws2812.MODE_DUAL  mode you will be able to handle two strips in parallel but will lose access to Lua's serial console as it shares the same UART and PIN.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812write", 
            "text": "Send data to one or two led strip using its native format which is generally Green,Red,Blue for RGB strips\nand Green,Red,Blue,White for RGBW strips.", 
            "title": "ws2812.write()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_1", 
            "text": "ws2812.write(data1, [data2])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_1", 
            "text": "data1  payload to be sent to one or more WS2812 like leds through GPIO2  data2  (optional) payload to be sent to one or more WS2812 like leds through TXD0 ( ws2812.MODE_DUAL  mode required)   Payload type could be:\n-  nil  nothing is done\n-  string  representing bytes to send\n-  ws2812.buffer  see  Buffer module", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example", 
            "text": "ws2812.init()\nws2812.write(string.char(255, 0, 0, 255, 0, 0)) -- turn the two first RGB leds to green  ws2812.init()\nws2812.write(string.char(0, 0, 0, 255, 0, 0, 0, 255)) -- turn the two first RGBW leds to white  ws2812.init(ws2812.MODE_DUAL)\nws2812.write(string.char(255, 0, 0, 255, 0, 0), string.char(0, 255, 0, 0, 255, 0)) -- turn the two first RGB leds to green on the first strip and red on the second strip  ws2812.init(ws2812.MODE_DUAL)\nws2812.write(nil, string.char(0, 255, 0, 0, 255, 0)) -- turn the two first RGB leds to red on the second strip, do nothing on the first", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#buffer-module", 
            "text": "For more advanced animations, it is useful to keep a \"framebuffer\" of the strip,\ninteract with it and flush it to the strip.  For this purpose, the ws2812 library offers a read/write buffer. This buffer has a  __tostring  method so that it can be printed. This is useful for debugging.", 
            "title": "Buffer module"
        }, 
        {
            "location": "/en/modules/ws2812/#example_1", 
            "text": "Led chaser with a RGBW strip  ws2812.init()\nlocal i, buffer = 0, ws2812.newBuffer(300, 4); buffer:fill(0, 0, 0, 0); tmr.create():alarm(50, 1, function()\n  i = i + 1\n  buffer:fade(2)\n  buffer:set(i % buffer:size() + 1, 0, 0, 0, 255)\n  ws2812.write(buffer)\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812newbuffer", 
            "text": "Allocate a new memory buffer to store led values.", 
            "title": "ws2812.newBuffer()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_2", 
            "text": "ws2812.newBuffer(numberOfLeds, bytesPerLed)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_2", 
            "text": "numberOfLeds  length of the led strip  bytesPerLed  3 for RGB strips and 4 for RGBW strips", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_2", 
            "text": "ws2812.buffer", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812bufferget", 
            "text": "Return the value at the given position", 
            "title": "ws2812.buffer:get()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_3", 
            "text": "buffer:get(index)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_3", 
            "text": "index  position in the buffer (1 for first led)", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_3", 
            "text": "(color)", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_2", 
            "text": "buffer = ws2812.newBuffer(32, 4)\nprint(buffer:get(1))\n0   0   0   0", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812bufferset", 
            "text": "Set the value at the given position", 
            "title": "ws2812.buffer:set()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_4", 
            "text": "buffer:set(index, color)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_4", 
            "text": "index  position in the buffer (1 for the first led)  color  payload of the color   Payload could be:\n-  number, number, ...  you should pass as many arguments as  bytesPerLed \n-  table  should contains  bytesPerLed  numbers\n-  string  should contains  bytesPerLed  bytes", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_4", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_3", 
            "text": "buffer = ws2812.newBuffer(32, 3)\nbuffer:set(1, 255, 0, 0) -- set the first led green for a RGB strip  buffer = ws2812.newBuffer(32, 4)\nbuffer:set(1, {0, 0, 0, 255}) -- set the first led white for a RGBW strip  buffer = ws2812.newBuffer(32, 3)\nbuffer:set(1, string.char(255, 0, 0)) -- set the first led green for a RGB strip", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812buffersize", 
            "text": "Return the size of the buffer in number of leds", 
            "title": "ws2812.buffer:size()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_5", 
            "text": "buffer:size()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_5", 
            "text": "none", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_5", 
            "text": "int", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812bufferfill", 
            "text": "Fill the buffer with the given color.\nThe number of given bytes must match the number of bytesPerLed of the buffer", 
            "title": "ws2812.buffer:fill()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_6", 
            "text": "buffer:fill(color)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_6", 
            "text": "color  bytes of the color, you should pass as many arguments as  bytesPerLed", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_6", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_4", 
            "text": "buffer:fill(0, 0, 0) -- fill the buffer with black for a RGB strip", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812bufferdump", 
            "text": "Returns the contents of the buffer (the pixel values) as a string. This can then be saved to a file or sent over a network.", 
            "title": "ws2812.buffer:dump()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_7", 
            "text": "buffer:dump()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_7", 
            "text": "A string containing the pixel values.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_5", 
            "text": "local s = buffer:dump()", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812bufferreplace", 
            "text": "Inserts a string (or a buffer) into another buffer with an offset.\nThe buffer must have the same number of colors per led or an error will be thrown.", 
            "title": "ws2812.buffer:replace()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_8", 
            "text": "buffer:replace(source[, offset])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_7", 
            "text": "source  the pixel values to be set into the buffer. This is either a string or a buffer.  offset  the offset where the source is to be placed in the buffer. Default is 1. Negative values can be used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_8", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_6", 
            "text": "buffer:replace(anotherbuffer:dump()) -- copy one buffer into another via a string\nbuffer:replace(anotherbuffer) -- copy one buffer into another\nnewbuffer = buffer.sub(1)     -- make a copy of a buffer into a new buffer", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812buffermix", 
            "text": "This is a general method that loads data into a buffer that is a linear combination of data from other buffers. It can be used to copy a buffer or,\nmore usefully, do a cross fade. The pixel values are computed as integers and then range limited to [0, 255]. This means that negative\nfactors work as expected, and that the order of combining buffers does not matter.", 
            "title": "ws2812.buffer:mix()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_9", 
            "text": "buffer:mix(factor1, buffer1, ...)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_8", 
            "text": "factor1  This is the factor that the contents of  buffer1  are multiplied by. This factor is scaled by a factor of 256. Thus  factor1  value of 256 is a factor of 1.0.  buffer1  This is the source buffer. It must be of the same shape as the destination buffer.   There can be any number of factor/buffer pairs.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_9", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_7", 
            "text": "-- loads buffer with a crossfade between buffer1 and buffer2\nbuffer:mix(256 - crossmix, buffer1, crossmix, buffer2)\n\n-- multiplies all values in buffer by 0.75\n-- This can be used in place of buffer:fade\nbuffer:mix(192, buffer)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812bufferpower", 
            "text": "Computes the total energy requirement for the buffer. This is merely the total sum of all the pixel values (which assumes that each color in each\npixel consumes the same amount of power). A real WS2812 (or WS2811) has three constant current drivers of 20mA -- one for each of R, G and B. The\npulse width modulation will cause the  average  current to scale linearly with pixel value.", 
            "title": "ws2812.buffer:power()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_10", 
            "text": "buffer:power()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_10", 
            "text": "An integer which is the sum of all the pixel values.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_8", 
            "text": "-- Dim the buffer to no more than the PSU can provide\nlocal psu_current_ma = 1000\nlocal led_current_ma = 20\nlocal led_sum = psu_current_ma * 255 / led_current_ma\n\nlocal p = buffer:power()\nif p   led_sum then\n  buffer:mix(256 * led_sum / p, buffer) -- power is now limited\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812bufferfade", 
            "text": "Fade in or out. Defaults to out. Multiply or divide each byte of each led with/by the given value. Useful for a fading effect.", 
            "title": "ws2812.buffer:fade()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_11", 
            "text": "buffer:fade(value [, direction])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_9", 
            "text": "value  value by which to divide or multiply each byte  direction  ws2812.FADE_IN or ws2812.FADE_OUT. Defaults to ws2812.FADE_OUT", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_11", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_9", 
            "text": "buffer:fade(2)\nbuffer:fade(2, ws2812.FADE_IN)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812buffershift", 
            "text": "Shift the content of (a piece of) the buffer in positive or negative direction. This allows simple animation effects. A slice of the buffer can be specified by using the \nstandard start and end offset Lua notation. Negative values count backwards from the end of the buffer.", 
            "title": "ws2812.buffer:shift()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_12", 
            "text": "buffer:shift(value [, mode[, i[, j]]])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_10", 
            "text": "value  number of pixels by which to rotate the buffer. Positive values rotate forwards, negative values backwards.   mode  is the shift mode to use. Can be one of  ws2812.SHIFT_LOGICAL  or  ws2812.SHIFT_CIRCULAR . In case of SHIFT_LOGICAL, the freed pixels are set to 0 (off). In case of SHIFT_CIRCULAR, the buffer is treated like a ring buffer, inserting the pixels falling out on one end again on the other end. Defaults to SHIFT_LOGICAL.   i  is the first offset in the buffer to be affected. Negative values are permitted and count backwards from the end. Default is 1.  j  is the last offset in the buffer to be affected. Negative values are permitted and count backwards from the end. Default is -1.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_12", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_10", 
            "text": "buffer:shift(3)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812buffersub", 
            "text": "This implements the extraction function like  string.sub . The indexes are in leds and all the same rules apply.", 
            "title": "ws2812.buffer:sub()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_13", 
            "text": "buffer1:sub(i[, j])", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_11", 
            "text": "i  This is the start of the extracted data. Negative values can be used.  j  this is the end of the extracted data. Negative values can be used. The default is -1.", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_13", 
            "text": "A buffer containing the extracted piece.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_11", 
            "text": "b = buffer:sub(1,10)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/ws2812/#ws2812buffer__concat", 
            "text": "This implements the  ..  operator to concatenate two buffers. They must have the same number of colors per led.", 
            "title": "ws2812.buffer:__concat()"
        }, 
        {
            "location": "/en/modules/ws2812/#syntax_14", 
            "text": "buffer1 .. buffer2", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/ws2812/#parameters_12", 
            "text": "buffer1  this is the start of the resulting buffer  buffer2  this is the end of the resulting buffer", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/ws2812/#returns_14", 
            "text": "The concatenated buffer.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/ws2812/#example_12", 
            "text": "ws2812.write(buffer1 .. buffer2)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/xpt2046/", 
            "text": "XPT2046 Module\n\n\n\n\n\n\n\n\nSince\n\n\nOrigin / Contributor\n\n\nMaintainer\n\n\nSource\n\n\n\n\n\n\n\n\n\n\n2017-03-09\n\n\nStarofall\n/\nFrank Exoo\n\n\nFrank Exoo\n\n\nxpt2046.c\n\n\n\n\n\n\n\n\nXPT2046 is a touch controller used by several cheap displays - often in combination with the ILI9341 display controller.\nThe module is built based on the libraries of \nspapadim\n and \nPaulStoffregen\n.\n\n\nxpt2046.init()\n\n\nInitiates the XPT2046 module to read touch values from the display. It is required to call \nspi.setup()\n before calling \nxpt2046.init\n (see example).\nAs the ucg lib also requires \nspi.setup()\n to be called before it is important to only call it once in total and to activate \nspi.FULLDUPLEX\n.\nThe \nclock_div\n used in \nspi.setup()\n should be 16 or higher, as lower values might produces inaccurate results.\n\n\nSyntax\n\n\nxpt2046.init(cs_pin, irq_pin, height, width)\n\n\nParameters\n\n\n\n\ncs_pin\n GPIO pin for cs\n\n\nirq_pin\n GPIO pin for irq\n\n\nheight\n display height in pixel\n\n\nwidth\n display width in pixel\n\n\n\n\nReturns\n\n\nnil\n\n\nExample\n\n\n-- Setup spi with `clock_div` of 16 and spi.FULLDUPLEX\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 16,spi.FULLDUPLEX)\n-- SETTING UP DISPLAY (using ucg module)\nlocal disp = ucg.ili9341_18x240x320_hw_spi(8, 4, 0)\ndisp:begin(0)\n-- SETTING UP TOUCH\nxpt2046.init(2,1,320,240)\nxpt2046.setCalibration(198, 1776, 1762, 273)\n\n\n\n\nxpt2046.setCalibration()\n\n\nSets the calibration of the display. Calibration values can be optained by using \nxpt2046.getRaw()\n and read the values in the edges.\n\n\nSyntax\n\n\nxpt2046.setCalibration(x1, y1, x2, y2)\n\n\nParameters\n\n\n\n\nx1\n raw x value at top left\n\n\ny1\n raw y value at top left\n\n\nx2\n raw x value at bottom right\n\n\ny2\n raw y value at bottom right\n\n\n\n\nReturns\n\n\nnil\n\n\nxpt2046.isTouched()\n\n\nChecks if the touch panel is touched.\n\n\nSyntax\n\n\nxpt2046.isTouched()\n\n\nReturns\n\n\ntrue\n if the display is touched, else \nfalse\n\n\nExample\n\n\nif(xpt2046.isTouched()) then\n    local x, y = xpt2046.getPosition()\n    print(x .. \n-\n .. y)\nend\n\n\n\n\nxpt2046.getPosition()\n\n\nReturns the position the display is touched using the calibration values and given width and height.\nCan be used in an interrupt pin callback to return the coordinates when the touch screen is touched.\n\n\nSyntax\n\n\nxpt2046.getPosition()\n\n\nReturns\n\n\nreturns both the x and the y position.\n\n\nExample\n\n\n-- Setup spi with `clock_div` of 16 and spi.FULLDUPLEX\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 16,spi.FULLDUPLEX)\n-- SETTING UP TOUCH\ncs_pin  = 2 -- GPIO4\nirq_pin = 3 -- GPIO0\nheight  = 240\nwidth = 320\nxpt2046.init(cs_pin, irq_pin, width, height)\nxpt2046.setCalibration(198, 1776, 1762, 273)\ngpio.mode(irq_pin,gpio.INT,gpio.PULLUP)\ngpio.trig(irq_pin, \ndown\n, function()\n    print(xpt2046.getPosition())\nend)\n\n\n\n\nxpt2046.getPositionAvg()\n\n\nTo create better measurements this function reads the position three times and averages the two positions with the least distance.\n\n\nSyntax\n\n\nxpt2046.getPositionAvg()\n\n\nReturns\n\n\nreturns both the x and the y position.\n\n\nExample\n\n\nlocal x, y = xpt2046.getPositionAvg()\nprint(x .. \n-\n .. y)\n\n\n\n\nxpt2046.getRaw()\n\n\nReads the raw value from the display. Useful for debugging and custom conversions.\n\n\nSyntax\n\n\nxpt2046.getRaw()\n\n\nReturns\n\n\nreturns both the x and the y position as a raw value.\n\n\nExample\n\n\nlocal rawX, rawY = xpt2046.getRaw()\nprint(rawX .. \n-\n .. rawY)", 
            "title": "xpt2046"
        }, 
        {
            "location": "/en/modules/xpt2046/#xpt2046-module", 
            "text": "Since  Origin / Contributor  Maintainer  Source      2017-03-09  Starofall / Frank Exoo  Frank Exoo  xpt2046.c     XPT2046 is a touch controller used by several cheap displays - often in combination with the ILI9341 display controller.\nThe module is built based on the libraries of  spapadim  and  PaulStoffregen .", 
            "title": "XPT2046 Module"
        }, 
        {
            "location": "/en/modules/xpt2046/#xpt2046init", 
            "text": "Initiates the XPT2046 module to read touch values from the display. It is required to call  spi.setup()  before calling  xpt2046.init  (see example).\nAs the ucg lib also requires  spi.setup()  to be called before it is important to only call it once in total and to activate  spi.FULLDUPLEX .\nThe  clock_div  used in  spi.setup()  should be 16 or higher, as lower values might produces inaccurate results.", 
            "title": "xpt2046.init()"
        }, 
        {
            "location": "/en/modules/xpt2046/#syntax", 
            "text": "xpt2046.init(cs_pin, irq_pin, height, width)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/xpt2046/#parameters", 
            "text": "cs_pin  GPIO pin for cs  irq_pin  GPIO pin for irq  height  display height in pixel  width  display width in pixel", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/xpt2046/#returns", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/xpt2046/#example", 
            "text": "-- Setup spi with `clock_div` of 16 and spi.FULLDUPLEX\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 16,spi.FULLDUPLEX)\n-- SETTING UP DISPLAY (using ucg module)\nlocal disp = ucg.ili9341_18x240x320_hw_spi(8, 4, 0)\ndisp:begin(0)\n-- SETTING UP TOUCH\nxpt2046.init(2,1,320,240)\nxpt2046.setCalibration(198, 1776, 1762, 273)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/xpt2046/#xpt2046setcalibration", 
            "text": "Sets the calibration of the display. Calibration values can be optained by using  xpt2046.getRaw()  and read the values in the edges.", 
            "title": "xpt2046.setCalibration()"
        }, 
        {
            "location": "/en/modules/xpt2046/#syntax_1", 
            "text": "xpt2046.setCalibration(x1, y1, x2, y2)", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/xpt2046/#parameters_1", 
            "text": "x1  raw x value at top left  y1  raw y value at top left  x2  raw x value at bottom right  y2  raw y value at bottom right", 
            "title": "Parameters"
        }, 
        {
            "location": "/en/modules/xpt2046/#returns_1", 
            "text": "nil", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/xpt2046/#xpt2046istouched", 
            "text": "Checks if the touch panel is touched.", 
            "title": "xpt2046.isTouched()"
        }, 
        {
            "location": "/en/modules/xpt2046/#syntax_2", 
            "text": "xpt2046.isTouched()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/xpt2046/#returns_2", 
            "text": "true  if the display is touched, else  false", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/xpt2046/#example_1", 
            "text": "if(xpt2046.isTouched()) then\n    local x, y = xpt2046.getPosition()\n    print(x ..  -  .. y)\nend", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/xpt2046/#xpt2046getposition", 
            "text": "Returns the position the display is touched using the calibration values and given width and height.\nCan be used in an interrupt pin callback to return the coordinates when the touch screen is touched.", 
            "title": "xpt2046.getPosition()"
        }, 
        {
            "location": "/en/modules/xpt2046/#syntax_3", 
            "text": "xpt2046.getPosition()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/xpt2046/#returns_3", 
            "text": "returns both the x and the y position.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/xpt2046/#example_2", 
            "text": "-- Setup spi with `clock_div` of 16 and spi.FULLDUPLEX\nspi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 16,spi.FULLDUPLEX)\n-- SETTING UP TOUCH\ncs_pin  = 2 -- GPIO4\nirq_pin = 3 -- GPIO0\nheight  = 240\nwidth = 320\nxpt2046.init(cs_pin, irq_pin, width, height)\nxpt2046.setCalibration(198, 1776, 1762, 273)\ngpio.mode(irq_pin,gpio.INT,gpio.PULLUP)\ngpio.trig(irq_pin,  down , function()\n    print(xpt2046.getPosition())\nend)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/xpt2046/#xpt2046getpositionavg", 
            "text": "To create better measurements this function reads the position three times and averages the two positions with the least distance.", 
            "title": "xpt2046.getPositionAvg()"
        }, 
        {
            "location": "/en/modules/xpt2046/#syntax_4", 
            "text": "xpt2046.getPositionAvg()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/xpt2046/#returns_4", 
            "text": "returns both the x and the y position.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/xpt2046/#example_3", 
            "text": "local x, y = xpt2046.getPositionAvg()\nprint(x ..  -  .. y)", 
            "title": "Example"
        }, 
        {
            "location": "/en/modules/xpt2046/#xpt2046getraw", 
            "text": "Reads the raw value from the display. Useful for debugging and custom conversions.", 
            "title": "xpt2046.getRaw()"
        }, 
        {
            "location": "/en/modules/xpt2046/#syntax_5", 
            "text": "xpt2046.getRaw()", 
            "title": "Syntax"
        }, 
        {
            "location": "/en/modules/xpt2046/#returns_5", 
            "text": "returns both the x and the y position as a raw value.", 
            "title": "Returns"
        }, 
        {
            "location": "/en/modules/xpt2046/#example_4", 
            "text": "local rawX, rawY = xpt2046.getRaw()\nprint(rawX ..  -  .. rawY)", 
            "title": "Example"
        }
    ]
}